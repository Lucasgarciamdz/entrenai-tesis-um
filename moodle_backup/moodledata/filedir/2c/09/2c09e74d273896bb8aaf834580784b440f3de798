Retomamos entonces esto que estábamos viendo, cuáles son de alguna manera los... En realidad, hacks no son hacks, pero esto es lo que ha tenido que implementar TCP y aprender de los implementadores, de los diseñadores a lo largo del tiempo para tratar de ajustarse a las condiciones del mundo real. Y especialmente en lo que refiere a las condiciones de la red. Vamos a ver el tema de los hacks duplicados porque es interesante. Y esto es tan, tan, tan fácil. Me buscaron una pizarra normal y no es esto. Cuando podremos volver. Anyway, imaginemos esto que es todo un pedazo de espacio de secuencia. Recordemos que para lo que es data, para la aplicación, para el TCP es un problema de espacio de secuencia. Imaginemos que TCP ha tenido que cortar este espacio de secuencia en eso. Eh, Diego, ¿cómo estás? Buenas noches. No estás presentando nada, te aviso. Mira que bien, pero me encanta verme a mí mismo. Gracias, gracias. Ahí vamos, ahora sí. Bien, entonces recordemos para TCP el problema es espacio de secuencia. Lo que para la aplicación es data, para TCP es espacio de secuencia. Tengo que empujar desde el lado, al otro lado de esa es mi misión. Bien, entonces imaginemos todo ese espacio de secuencia y tiene que empujar TCP de un lado a otro. Lo que yo he puesto verticalmente ahí como cortes es los PMTU, que es la mejor unidad en que TCP puede segmentar esto para hacer estos problemas en unitario, si se quiere. Es decir, cada segmento ahora es mi problema. Pero internamente TCP siempre sigue pensando en bytes, espacio de secuencias. No, entonces si uno pusiera acá, entonces nosotros estábamos redondeando por hacerlo cómodo, como si fuera un PMTU de aproximadamente de 1K, entonces imaginemos que esto es 1K. Bien sabemos, insisto mucho en eso, porque a veces, de acuerdo al humor del día, nosotros somos más o menos insistentes con ser más precisos con los 1,5K, pero bueno, imaginemos, entonces un PMTU de 1K. ¿Qué irá pasando en los distintos momentos de tiempo? Esto es el espacio de secuencia que tiene el TCP, ya lo ha recortado en sus segmentos y empieza a enviar segmentos. Entonces, le vamos a poner este segmento 1, 2. Ahora vamos a hablar en los segmentos. Entonces. Vamos a ir switchando entre segmentos y espacios de secuencia. ¿Qué irá haciendo TCP? Lo que ustedes se imaginan. Vamos a ver cómo me sale. Toma esto. A ver cómo se puede dibujar mejor esto. Imagínense entonces, este espacio de data, TCP ya lo toma en espacio de secuencia, ya ha ido enviando, es decir, ha ido enviando uno tras otro. Estos segmentos a destino. Normalmente imaginamos de izquierda a derecha. El destino, lo que hace a medida que va leyendo esto, imaginemos que los va leyendo sin errores, a medida que llegan, ¿qué irá haciendo el destino? Acá yo no quiero hacerlo, pero no sea tan largo, por eso sería, hagámoslo, no sea tan babo-franco. Es decir, esto ocurre en un momento de tiempo, imaginemos la línea de tiempo que va hacia abajo, como lo veníamos dibujando. Imaginemos que tenemos una situación de ventana de congestión muy favorable, con lo cual esto puede salir casi uno detrás del otro. Es decir, en este flujo que había en este grafo, estamos, por ejemplo, acá, azul, que es la ventana de congestión. Está bien abierta, y también la ventana de recepción, obviamente. Por lo cuanto yo, imaginemos que tenga una ventana generosa de 4K, que yo la he ido aprovechando. El lado transmisor lo que hace es enviar cada uno de estos segmentos. ¿Qué va a ir haciendo el lado receptor? El lado receptor va a ir hackeando al espacio de secuencia que haya podido consumir exitosamente. Es decir, ¿ustedes dónde lo dibujarían a los hacks? Para ser bien, bien precisos. ¿Dónde deberían ir esos hacks? Hola. ¿Dónde estamos arreglando las líneas, supongo? Si estos hacks vendrían acá. Una vez que el lado receptor ha podido consumir completamente, ojo, fíjense que acá la flechita esta viene arriba de este, porque bien puede ser que el hack, lo vamos a hacer incluso más evidente, que el hack a esto haya venido mientras se estaban transmitiendo los otros. No tiene por qué ser super serial o secuencial, ¿no? Es decir, a medida que se van enviando, van llegando los hacks y siguen enviándose. Bien, imaginemos entonces qué significa este hack a un K. Significa que el receptor pudo consumir ese un K, correcto. Lo que es importante saber es que los hacks son acumulativos al espacio de secuencia. No te hackea el paquete, sino te hackea espacio de secuencia consumido. Por lo tanto, este hack acá va a decir, yo te hackeo a 2K+1. ¿El +1? Es una cuestión meramente de sintaxis. Perdón, un K+1, disculpenme. Un K+1. El hack se escribe como el siguiente byte que estoy listo para recibir, más que el último byte que te recibí bien. Pero es una cuestión meramente de cómo se escribe el protocolo, no es semánticamente nada, es sintaxis, nada más. ¿De qué numerito te pongo ahí? Si es todo lo que consumí o el próximo momento libre. Bien, es el próximo que estoy listo para recibir. Seguimos con esto. Este hack, ¿qué dirá del lado del receptor? ¿Qué les parece? 2K+1. Ajá, 2K+1. Dice hack 2K+1. Y ocurre que al 3 le cayó el rayo, rayo disante, y ya. Y el 3 está kaput. O mejor dicho, el 3 estaba como dato, pero este se pierde. Y el 4 llega. Entonces, ¿qué pasará? ¿Qué les parece? Cuando llegue el 4 al lado receptor, teniendo presente que tiene una sola línea de espacio de secuencia para hackear. ¿Qué hackearía? Llegó 4, faltó el 3. Una cosa por decir. Mi no tener cómo decir eso, lo siento. Ya vamos a ver la cabecita, tiene nada más que 20 bytes. Y diciendo que llegó el 4 y no habiendo dicho... Mi no poder decirlo, mi solo poder decir todo lo que he leído correctamente hasta ahora. Y nada, hackea el 4. Uy, pero estoy mintiendo, loco. El 3 nunca llegó, ¿cómo es que hubiera que ir al 4? Entonces, no le mando nada y espero porque tal vez... No, porque eso es hack time out. Sabemos lo horrible que es el hack time out. No hagamos hack time out. Yo estoy vivo, no he desaparecido de este planeta, estoy ahí. ¿Qué es lo más que puedo decir? Así con cara de histérico. ¿Qué es lo más que puedo decir? Volver a mandar el 2. Y sí, no queda otro bloco, ¿qué le vamos a hacer? Entonces, eso es lo que efectivamente ocurre. Cuando llega el 4, lamentablemente no puede hackear el espacio de secuencia 4. Por lo tanto, en este momento de tiempo estamos yendo hacia abajo. En realidad, el tiempo fluye hacia abajo, este se perdió. Va a venir, lamentablemente, otro hack 2+1. Y ese es el origen del hack duplicado. ¿Por qué es el origen del hack duplicado? El TCP transmisor no es ningún tontín. Y dice, "Oh, oh, oh, acá hay hack duplicado". Quiere decir que yo puedo inferir que hay paquetes en el medio que se han ido perdiendo. No sé si el 3, ni hablar que si acá ha habido... Obviamente, si esto ha seguido hacia adelante. Y acá, yo lo hice por super simplificarlo, pero bien podría ser que esto acá, toda una secuencia de segmentos. Y yo sigo, "tuc, tuc, tuc, tuc, tuc". Hack duplicado. Si ustedes recibieron varios hack duplicados, por ejemplo, en esa posición, ¿qué podrían inferir? Yo soy transmisor, ¿no? Recuerden, yo no soy Dios, no veo todo el universo. Yo veo lo que yo puedo enviar y lo que leo al recibir. Envieso 6 y recibí 2K, 2K, 2K, 2K, 2K. ¿Qué pasó acá? ¿De qué puedo estar seguro yo como transmisor? Puedo suponer que no haya llegado al 3. ¿Que no haya llegado al 3? Claro, puede ser el 3 o el 4, pero estoy casi seguro que el 3 no. Ahí vamos a ver que puedo ser optimista o pesimista. La visión optimista sería, "Hm, seamos optimistas del 3 nomás, el que no fue, reenvió el 3". La visión pesimista es, "Se perdió el 3, el 4, el 5 y el S-Hack duplicado corresponde a 6. No tengo manera de correlacionarlo. Sí, ya vamos a ver la cabecera, no me da tanta info". Que siempre, como en todo diseño, es un trade-off, ¿no? Un compromiso. O inflo la cabecera con super información, con todos los detalles, o lo optimizo para el caso más común que es que no haya perdido. Y esa fue originalmente la decisión de diseño que hicieron los creadores del protocolo. Entonces, de todas maneras, lo que es importante en este momento es entender el origen de los hacks duplicados. De hecho, en este escenario, ¿cuántos hacks recibiría? Duplicado. Imaginando que todos pasaron excepto el 3. Solamente el 2. Ok, sí, sí, no puedo avanzar del 2, esto está clarísimo. Pero imaginemos que lleguemos al 4, al 5, al 6, ¿cuántos hacks duplicados recibiría? Es decir, este, cuando fue procesado por lado receptor, me renvió a este. Este, cuando fue procesado por el receptor, también no le quedó otra que decirle acá, es decir, 3 más, ¿no? Es decir, que hay como 3 duplicados. Y este, el 6, no le quedó otra. Quiere decir acá, sencillamente porque no tengo yo como lado receptor, a la derecha del dibujo este, no tengo ese pedacito y me falta, así que me quedó ahí. Entonces, fíjense. Y ahora sí volvemos al tema de la penalización. Pero, ¿por qué eso? ¿Por qué esos están duplicados? El 4, el 5, el 6, si cuando se perdió el 3, no le mandé el del 4, le volví a mandar. Yo todavía no mandé el 3, ojo. Ahí, yo envié toda esta ristra, que era lo que me permitía la ventana de congestión y de recepción en este momento, mínimo las dos, me permitían enviar eso 6K, tac, tac, tac, lo envié. Y ahora espero un hack al 6K+1. Pero me viene hack al 1K+1, hack al 2K+1, pasa un tiempín y me viene hack al 2K+1, hack al 2K+1, hack al 2K+1. ¿Se entiende? No sé, ¿cuál es el cuestionamiento? Que todos esos repetidos, que o sea, llegó en 2K+1, ¿cuántas veces llegó? Montón, porque tantos como más allá del 3 hubo. Llegó uno, dos, tres veces. Que es lo que he tratado de dibujar acá con estos puntitos. Con cada uno de los OK, que lo pongo así como un check del lavador receptor. Vamos a poner una cosa. Así, con cada uno de los check, check, check, del lavador receptor me viene un hack. Pero como lamentablemente este es SPA es acumulativo, y no puedo mentir, no puedo dibujar que me llegó el 3, porque el 3 efectivamente acá vimos que se perdió. No me queda otra que pegarme acá. Esa situación es muy distinta a, yo como transmisor envío esta ristra y me viene hack al 1K+1, hack al 2K+1 y después cric, cric, cric, cric, cric, cric, cric, coinciden conmigo que es muy distinta la situación. El hack duplicado me indica, hay algo en el medio que se ha perdido. Se ha perdido un poco. Y un hack timeout, como bien venimos diciendo, puede ser se cayó totalmente en la red. Totalmente, parcialmente, es decir, en definitiva. Se cayó algo en el medio de origen-destino, o se cayó el destino directamente, no sé, qué sé yo. Si no tengo nada de feedback, puedo presuponer lo peor. Entonces, de ahí es que TCP tiene ese comportamiento de bajar a la mitad la ventana de congestión si hay hack duplicado y violentarla a un PMTU si hay hack timeout. Esto que habíamos dibujado acá. Déjenme, acá me faltó algo poner, escribirlo acá, que esta es la ventana de ese eje de congestión. ¿Con qué escribís? ¿Con el mouse? Sí. Muy bien. ¿Muy mal? No, no, no, digo al contrario. Muy buen pulso para escribir con el mouse. Y eso que estoy escribiendo con la derecha haciendo surdo. ¿Estás en tus licuadoras también? Sí, no, no, pero con este mouse vertical, obviamente. Bien. Bárbaro. Bien. ¿Se entendió, muchachos? ¿No? Es importante esto. Entonces, ahí se ve, fíjense cómo es recontra, caso particularense TCP. Si es un hack timeout, apunta un PMTU. Si es hack duplicado, a media, bajo a la mitad la ventana de congestión actual y así sucesivamente, si se hiciera falta. Y tiene un montón de estos casos particulares. Consecuencia, ¿qué onda la implementación de TCP? ¿Será así un pedacito de código en 20 líneas implementamos TCP? No, debe ser bastante largo. De hecho, si ustedes ven la fuente del código de Linux, por decir, la implementación de TCP es como 5 veces o no sé si más, debe ser, habría que verlo. En su momento eran como 5 a 7 veces la cantidad de código comparado con UDP. Y tiene timers por todos lados porque tengo que memorizar que había enviado este segmento para decir, ah, no, hay una condición de hack timeout, considerarlo como un evento, actuar en consecuencia. Un flor de despelote, fundamentalmente porque es recontra stateful. Si mantiene el estado de, fíjense que ahora mantenemos un estado per segmento. Acá, cuando nosotros empezamos acá, hablamos estado sin conexión, conectando, conectado. Pero si ponemos la lupa, TCP tiene que cuidar cada uno de los segmentitos que ha ido enviando y un timer de que hack timeout este, duplicado de este, reviento este, recalculo esto. Entonces, mucho estado. Muy gordo el cerebrito de TCP para cada una de sus conexiones. Eso es importante. Es decir, el hecho de tener un protocolo que nos hace, nos hace todo por nosotros, muchachos. Esto de retransmitir, asegurar que llegue ordenado, todo tiene su costo. Y ese costo es lo que estamos tratando de visualizar ahora. Slow start. Nuevamente, todas pequeñas cositas que tiene que hacer TCP para proteger a la que no conoce. ¿Quién es la que no conoce? A la red. Porque la red no habla. La red solamente o pasa o pierde. Slow start es lo que yo más o menos intenté acá. Es una manera en que TCP hace un, es loco porque le llama slow start, pero es el arranque de una exponencial. De una cadencia exponencial. Como ustedes saben muy bien, una curva exponencial tiene un inicio tranqui, slow, y después tiene una subida rápida. En la segunda pandemia, por ejemplo, o sea, alguna vez han visto con una pandemia. Veamos por qué. Aquí es interesante ver cómo es que el slow start implementa este inicio exponencial. La idea es que la ventana al arranque es efectivamente un PMTU. Es decir, sin penalización, sin haber habido act timeout, arranco la conexión asumiendo lo peor. Porque nuevamente todos los TCP tenemos que cuidarla que no habla, que es la red. Entonces yo arranco en lo peor. Arranco asumiendo que acá ha habido congestión. Arranco con un PMTU, pero arranco con los timers de los timers de retransmisión frescos. Timers de retransmisión frescos. ¿Cómo se yo? ¿A qué distancia está el otro lado? ¿Distancia? Es en realidad el tiempo. El RTP. El RTT. ¿Y dónde lo medí? ¿Cuándo lo medí? Me lo entrego una... Acá el primer SYN y ACK. Bien, perfecto. Acá ya tengo un feedback. Yo sé que el otro guacho está a 100 milisegundos. Entonces ya tengo una buena referencia para act timeout. Pero arranco penalizado, autopenalizado en slow start, en una ventana de un PMTU. Bien, volvamos. Ok, entonces vamos a ver cómo va saliendo esto. Imaginémonos que nuevamente tenemos todo esto para enviar. Tenemos estos cortecitos. A ver, déjeme, lo voy a cortar más chiquitito para que sea más gráfico. Pim, pim, pim, pim, pim. Si tengo un PMTU y esto ya está recortado en un PMTU, ¿qué es lo que puedo enviar? Uno de estos, ¿cierto? Esto es lo que va hacia allá. Un PMTU. Arrancamos con slow start. ¿Qué voy haciendo? Voy aumentando el tamaño de la ventana en base a la cantidad de ACKs que me van llegando. ACKs buenos, no ACKs duplicados. Si yo envié esto, me llega un ACK. ¿En cuánto aumento la ventana? En uno. En uno. Entonces acá teníamos que la window de congestión era uno. Estamos asumiendo entonces que acá me llegó un ACK. Me llegó un ACK. Por lo tanto, en el próximo estado que tenemos que la window es dos. Por lo tanto, yo avanzo acá y me autopermito a enviar dos. Bien, estos dos, si todo anda bien, ¿cuántos ACKs voy a recibir por estos dos? Uno solo. Pero en espacio de PMTU, medidos en PMTU, en unidades de avance de PMTU. Está muy bien. Podría hacer uno solo, de acuerdo al timing. Podría haber una optimización y decir, "ah, te llegaron juntitos, hacemos un solo ACK a todos". Pero imaginemos, pensemoslo en espacio de MTU. En principio, el otro lado me estaría ACKeando a este y a este. Antes me ACKaba acá. Por lo tanto, ¿cuántos ACKs tengo acá? Dos. Dos ACKs. Nuevamente, ya vamos a ver los detalles más íntimos del caso. Pero, si tengo dos ACKs y tenía la ventana en dos, ¿cuánto es la próxima ventana? Cuatro. Fíjense, esto ustedes ya lo están percibiendo. ¿Qué comportamiento va a tener esto? Tengo ventana... Exponencial. Ventana cuatro, significa, fíjense que acá yo estoy tomando el cuidado de dibujarlos, más o menos mapeándolo desde arriba del espacio de secuencia que tenemos que ir empujando hacia el otro lado. ¿Y qué pasará si ahora tengo cuatro ACKs? Recibe cuatro ACKs. ¿Cómo? No nada, recibe cuatro ACKs. ¿Recibe cuatro ACKs y cuánto va a ser el próximo tamaño de ventana? Ocho. Ocho, bien. Ahora, y fíjense nuevamente acá los tantos "if" que tiene el protocolo. "If, if, if, if". ¿Qué es lo que ocurre? Esto, como ustedes bien perciben, tiene un comportamiento exponencial, lo cual permite arrancar, que es lo que uno observa con el F5, lo que discutíamos recién, que pronto, "pfff", arranca rápido. Pero, para evitar esto que yo aquí dibujé como un comportamiento, esta parte, hacer esta parte más gentil, el "slow start" solamente es válido hasta la mitad de la ventana. Hasta la mitad de la ventana de recepción. Y ahí se para el "slow start", quiere decir que acá, que vendría a ser "windows" de Rx, sobre 2. Toda esta parte es exponencial y acá continúa alineada. La alinealidad se da en vez de sumar por cada "hack", en vez de seguir acumulando por cada "hack", acumula un solo salto de ventana cuando logró, es decir, ese aumento acá es solamente cuando logra pasar todo esto que había pasado acá. Eso quiere decir que va duplicando el tamaño de la ventana hasta un determinado punto, hasta la mitad de la ventana de recepción, y después de ahí empieza a aumentarlo linealmente. A medida que logra pasar esos 4, se permite solamente aumentar en 1. Cuando pasó los 5, se aumenta en 1 a 6. Cuando pasó los 6, se aumenta en 1 a 7. Para hacer ese comportamiento como exponencial y después, "chk", lineal. ¿Por qué? Porque el objetivo de TCP, asumiendo que la red esté bien, fíjense que acá no se perdió nada, acá no hubo ningún feedback negativo de la red. Esencialmente, TCP siendo cuidadoso en su arranque. Arrancar rápido y después tratar de lograr esto, donde esto es lograr que la ventana de recepción coincida con la ventana de congestión. ¿Cómo hacemos lo más feliz a un TCP el día de su cumpleaños? Le hacemos que la ventana de congestión sea igual a la recepción y un TCP va a estar contentito ahí trabajando hermoso. Cuando se enoja, cuando se pone en tristeza el TCP, con "act duplicated", con "act timeout" y se autopenaliza, se latiga y baja la ventana de congestión nuevamente para cuidar la red. ¿Quedó claro eso? Sí, bro. ¿Sí? Bien. La primera parte es "slow start" y la segunda parte es "speed". Disculpe, eso que dijo que era hasta 4 y después del 5, 6... No, ese número es un número esencialmente para recordar lo que dije, que es hasta la mitad de la ventana, no hasta 4. Bien, perfecto. Y hasta esto, esto, es W sobre 2. Eso era nada más por un ejemplo sencillo que yo tomé acá con los numeritos, acá. No es hasta W4, acá estaría asumiendo que 4 PMTU, justo la mitad de la ventana de recepción que me puso el lado receptor. Esto asumiría una ventana de 8K, por ejemplo, y yo llegué hasta 4, y entonces de ahí empiezo a subirla linealmente. Entonces, "slow start" con "congestion avoidance". Lo vamos a dejar acá escrito. Este periodo... De acá a acá es uno y este periodo de acá a acá es otro. Este periodo... Tengan presente que esto del "act time out" nosotros lo estamos dibujando acá es para ahorrarnos, deberíamos arrancar de cero en el tiempo porque la conexión arrancó fresquita, pero el fenómeno se repite. Mejor dicho, el comportamiento es el mismo. Entonces esto es "slow start". Por cierto, como les venía diciendo, el libro "Internet Core Protocols" tiene esto pero súper recontra claro. Y habla mucho más de lo que decimos nosotros, se puede aprender perfecto de él. Y esto es "congestion avoidance". Bien, seguimos. Veamos que otro retoque es "hacks" tiene TCP. "Delayed hacks". Alguien por ahí dijo, y con buen tino, de que acá por ahí TCP, el otro TCP podría dar el gusto de hacerme un solo paquetito de hack. Esto es que dibujé "hack" acá, "hack" acá. ¿De qué dependerá eso? ¿Qué les parece? Escenario, entonces, empuje uno. "Hack", "slow start". Empujo ahora dos, tengo permiso para dos. Y esos dos segmentos van muy "juntitos", entre comillas. Y le llegan al receptor casi, no simultáneamente, pero le llegan uno tras el otro al receptor. Entonces, ¿el receptor qué podría decir acá para ahorrar tráfico de regreso? ¿Qué les parece? Si el "hack" es inclusivo. ¿Que envíe solo el último "hack"? Claro, el último "hack". Porque como es inclusivo, como todo en estos tiempos, entonces, incluiría también a los "hack" anteriores. Entonces, alcanzaría con este y me puedo ahorrar este "hack". Y para eso, ¿el receptor qué tendría que hacer? ¿Tendría que ser impaciente o paciente? Impaciente. Le toca esperar a ver si llega más o no. Claro, exacto. Impaciente sería así tipo "talk", de decir, "me llegó bien, ahí va el "hack", me llegó el otro, ahí va el "hack". Entonces, ¿qué debería hacer? Y, pará, pará, tranquilo, tranquilo. Recibiste un segmento, lo chequeaste, hermoso, lo pusiste en el buffer porque no tenía errores, está listo para que la aplicación lo consuma. Paráte unos milisegunditos a ver si es que no viene otro atrás. A ver si nos ahorramos a enviar nada más un segmento de 40 bytes sin data. Imaginando que yo no tengo nada para decirle de regreso al otro. De tal manera de que yo pueda acumular más espacio de secuencia que me viene ahorrándome "hacks" de regreso. Ese concepto es simple de entender. Ese es el concepto de "delay hacks". Pero no solo me permite eso, demorar el "hack" y no ser tan "talk". Cuando digo "talk" se entiende, ¿no? "Talk" de trastorno obsesivo compulsivo. Que sería el TCP acá, así, obsesivamente, decir "hack, hack, hack, apenas te leo". "Momente, tranqui, pará, pará, pará". Te llegó este segmento. Vamos a este otro dibujo. Te llegó este segmento, ¿no? Normalmente vos tendrías que "hackar" pero vos te tomás un "tiempin". Ese tiempo es para... Tiene dos razones de ser. Una es que te lleguen más segmentos, ahorrarte "hacks" de regreso. Pero hay otra razón interesante que se llama "pigbacking". "Pigbacking" es algo así, más o menos, como... - "Hacko koich". - "Hacko koich", ¿sabes tú? Gracias. Exactamente eso. ¿Qué será "pigbacking"? ¿Cómo se podría aplicar acá "pigbacking"? A Pateco. Si yo me demoro en enviar el "hack", ¿quién puede estar interesado en responder algo a lo que le acaban de decir? Digo, yo estoy en el lado B, he recibido data del lado A. Se lo estoy subiendo a la aplicación. Si las cosas se dan más o menos rápido y la aplicación está despiertita, bien puede ser que la aplicación consuma esta data y tenga algo para responder. A nivel de protocolo de aplicación. HTTP, ustedes saben que funciona con el... Después se establece la conexión, ¿qué hace el cliente en HTTP? Protocolo de aplicación, altura de aplicación. ¿Qué escribe como HTTP? Miren, se lo estoy dibujando con las letritas. Hace un... - Un "get". - Un "get". Espacio, barra. Sí, o barra lo que fuera, barra index HTML. ¿Y qué hace en consecuencia el HTTP server? Si yo le hago un... conecto, "syncynac hack", yo, al lado del cliente, hago un "get" barra index HTML, ¿qué va a hacer el server? Claro, tiene que decirle que le llegó el "get" a un "hack" del "get". Sí, sí, eso haría TCP. Pero la aplicación, server, la aplicación, ¿qué hace en consecuencia? Responde con la página que está pidiendo. Bien, perfecto. ¿Qué también me dirá? ¿Significa qué? ¿Lo que entra por acá? El lado B... A ver, pará. Vamos a hacer mejor. Sube por acá, la aplicación procesa y tiene algo para responder quizás. ¿Qué pasará si yo demoro el "hack"? Entonces, recuerden, el "hack" no es un paquete aparte, sino que es una sobrecarga misma de la cabecera de TCP. Yo en vez de responderle un "hack" vacío, ¿qué le voy a poder responder? No solo te "hackeo" que te recibí bien, sino además... El primer tramo de información. Claro, de data, de data posta. Entonces, fíjense. Yo, lado receptor de TCP, al no ser un "toc", "hackeando" ahí como loco, esperando un poquitito, le doy la chance a la aplicación de que lea la data, la consuma, escriba su buffer de transmisión y cuando yo tengo que construir el "hack" a todo ese espacio, en realidad no solo le envío el "hack" y le digo, te "hackeo" a lo que me escribiste, sino que además te estoy enviando la respuesta, "piggybacking". Sí, a cocho del "hack" va la respuesta de data posta, ¿no? Es decir, cargadito el paquete en vez de ser 40. Ese procesamiento se tiene que dar más rápido que el "timeout". Ah, bien. Porque si no, nos rompe todo. ¿Cuál es el peligro de eso? Me encantó. Es peligroso. Si tardás mucho tiempo en procesar la información, o esperas demasiado para el "piggybacking". ¿Cuál es el más tiempo que tenemos que comparar? ¿Cuáles son los órdenes de magnitud que tenemos que comparar? ¿El "roundtrip time"? ¿Contra? El "roundtrip" está muy bien, ¿contra? A ver, si RTT es 100 milisegundos, y yo tardo, disculpen, tengo algo atravesado. Y yo tardo 200 milisegundos en procesarlo, ¿será negocio? Esperar. Dependiendo del "timeout". Ahí está. Pero por eso, si es 100 milisegundos, el otro debe estar estimando un "timeout" en 125, 150. Me digo que no es negocio esperar, porque justamente, exactamente lo que acaban de decir. Si yo espero demasiado, en vez de hacer "the talk", me convierto en un vago TCP receptor, lo que va a ocurrir es que el pobre otro, a pesar de que anduvo todo bien, va a decir, "no, no me llegó nunca, acta de mouse". Ventana a un PMTU, ventana de congestión. Como siempre, toda ingeniería, como bien sabremos, insistimos, es un compromiso. Entonces, ahí hay "timings" involucrados. Yo, como laboreceptor, puedo darle tiempo a la aplicación a que responda para que haga "piggybacking", si ese tiempo es fundamentalmente menor, el tiempo de procesamiento comparado con el RTT, que tengo en control del otro lado. Digamos, yo, por decir, si tengo un RTT de 100 milisegundos, y bueno, aplicación, te doy un milisegundo para que responda. Dos, cinco milisegundos. Pero no te voy a dar 200 milisegundos. Porque este "hack" quema, me quema en los dedos. Porque el otro lado, si no lo recibe pronto, va a creer que ha habido "hack timeout". Entonces, ese es, de alguna manera, el compromiso. Ustedes lo ven acá, lo hemos puesto. Fíjense, permite "piggybacking", es lo que disminuye el tráfico, justamente porque acumulamos espacio para "hackear". Acá, y esta, nuevamente. Acá, esta sí es información recibida de una entidad alienígena o celestial, donde los que dicen la RFC dicen, "Muchachos, no más de 500 milisegundos, muchachos, no más de dos PMTU sin "hackear". Quiere decir que si yo leo uno, dos, al tercero, ya me obligo a dos. En realidad, cuando leí el segundo, ya, no más de dos PMTU. No, al tercero, yo ya me obligo a "hackearlo" y no hago todo este firulete de esperar para que la aplicación responda y qué sé yo. Esos números mágicos que ven ahí, 500 milisegundos, dos segmentos, vienen de la RFC y vienen estrictamente de campo. De ver cómo se comportaba el protocolo en campo, de estimar cuáles son las demoras que hay en la Internet en general y poner números de compromiso. Bien. ¿Cuál es el RTT real? -Ese número, profe, perdón, ¿se actualiza? -Ah, buena pregunta. No sabría responderte, debería fijarme, pero sería interesante. Todo se configura, por cierto. Puede que la RFC no lo actualice, tampoco es taxativo, pero si ustedes agarran un... Voy a presentar otro plantado, esto lo pueden ver si ustedes quisieran en sus instancias en la cloud. Ahí tenemos un... ¿Se ve ahí el shell mío? -Sí. -Lo voy a aumentar un poquito. Bien, Pablo. A ver si lo puedo aumentar con este pod. Bueno, no importa. Whatever lo que quieras. Acá hay un... Bien. Vamos a proceder a probar este... Fine. Yo voy a... Fine. (HABLAN A LA VEZ) ¿Recuerdan dónde estaban los PROC y PCP? Digo, que siempre me... -PROC SISNET... -Ah, gracias. Exacto. PROC SISNET... Fíjense, tiene algunas configurabilidades. -Se ve re pequeño, Juan. -Ah, ¿se ve re pequeño? -Dale un par de control más. No aguanta. -No aguanta. Bueno, ahí está. Option más. ¿Qué es eso de control? Eso de control es para gente pobre. Nosotros usamos... -Después tengo para contarte una... Un... ¿Cómo se llama? Un desvarío que hice este fin de semana. -Bueno, dale. -De la última versión de Windows 10. -Ah, el LS. -Lo queremos a todos. -Miren, ¿qué les quería mostrar acá antes de que yo me desvaríe en el tema? Todo eso son los configurables que tiene un Linux moderno en cuanto a TCP. En particular... Y ahí se me han perdido algunos allá en la pantalla. A ver... Ah, es cierto, porque esta porquería encima... Que te mantiene la... Vamos de vuelta. Ahí me voy. No sé si acá hay alguno en particular con ese timer, habría que ver. Fíjense si es el "retrace 1", "retrace 2", son los "hack timeout". Estábamos viendo los "hack duplicados". No sé si es este "fhack" o este "dshack", no recuerdo, pero hay alguno de esos que es. Todo esto son... Si ustedes lo "catean", del verbo "catear", fíjense que son números que a veces es cantidad y en algunos casos representan segundos o milisegundos. Por ejemplo, no sé qué se dice. Este está hecho en milisegundos, 7200 milisegundos. Sí, dos horas, está bien. Y uno los cambia haciendo cosas tan complicadísimas como las siguientes. Tienen que ser "route", así que hacen un "sudo", hacen un "echo", por ejemplo, si quieren "TCP keep alive timeout" y le hacen "sudo t". Y ahora ya tienen un nuevo valor en 3600. Ahí "clic", le cambiaron al kernel este. Entonces, un poco respondiendo a tu pregunta, más allá de lo que diga la RFC, los sistemas operativos tienen mecanismos de configuración que te permiten optimizar eso de acuerdo al contexto en donde vos estás usando esto. Por ejemplo, recuerdo de mi tiempo en Google que todos estos parámetros estaban todos "recontra" retocados en los "datacenters" porque son "datacenters" con muy baja latencia, que tienen otro tipo de comportamiento. Estaban todos estos, estaban todos súper "recontra" tuneados, ajustados para un problema de laburo dentro de "datacenters" de alta capacidad de ancho de banda. Porque estos son "defaults" razonables para una máquina que está en la Internet. Como dice, en la Internet, interactuando con Internet. Para flujos dentro de un "datacenter" con "links" de alta velocidad y poca pérdida, esto se suele retocar. Era modo de mostrarles eso. Bien, dejo de presentar y volvemos. El del "slow start" dice uno. ¿Cómo? ¿Decís "slow start" ahí? Bien, buenísimo. Sí, lo encontré. Ah, genial, genial. Yo recuerdo, por ejemplo, por decir algo recuerdo en algún caso para sacar un poco más de jugo. Si ustedes ven, hay uno en particular que es "TCP/WMEM" y "TCP/RMEM". "Write Memory" y "Receive Memory" es el tamaño de buffer de recepción y buffer de transmisión. Por default. Así que hay mucho para jugar. Y recuerdo haber ajustado, en una situación en la cual queríamos sacar más "throughput" a una red, haber ajustado, aumentado los "TCP/WMEM" y "RMEM". Son gratis, ¿no? Le aumento el valor que tengan ahí, le pongo lo que sea y ya está. No sé por qué vienen tan bajos estos, desgraciado. Tiene tres valores igual. Ajá, claro. Son como tres ajustes. Fijate que "4096", "16384" y "4MB". Es decir, "4K", "16K" y "4MB". Ajá, bien. Así hacen un "MAN PROC". ¿Qué era "MAN PROC"? "MAN 5 PROC" creo que era. No me quiero ir al tema, pero me encanta tanto esto, por favor. Si hacen un "MAN 5 PROC" les describe eso y ahí pueden ver los detalles. Yo no me acuerdo ahora los detalles, pero una creo que es la ventana máxima, otra la de "Folder 16K" y la otra no me acuerdo. Recuerdo distintas situaciones de presión de memoria o algo así. Bueno, no me quiero ir al tema. Vamos. Volvemos al tema. Pero ahí, nada, se superentiende entonces que hay mucho configurable. Esta es la manera de hacerlo en Linux. Que no tiene por qué ser la manera, pero esta es la manera simple, orientada a archivos en que en general los sistemas UNIX aproximan este tipo de settings. Volvemos. Pregunta. ¿Cuál es el RTT? Yo me di este RTT. ¿Será estable este RTT? Depende de la congestión de la red. Bien, ok. Me di 100 milisegundos. Después será 101, 99, 100, o saltará mucho así. ¿Ustedes qué experiencia tienen con eso? ¿Qué tan estable? Sí, es bastante inestable. Inestable. Dependerá si tenés hermanos o hijos que torrentean mucho. Ya vamos a ver sobre los torrentes un momentito después. Dependerá si están Netflixeando, si estás solo a las 3, 4 de la mañana, que la red está hermosa, menos que estén todos tus vecinos jugando, no sé, algún juego que necesitan mucho antes de ir a banda. Es decir, ¿a qué voy con esto? ¿Qué trato de dibujar? Yo no controlo la situación de congestión de la red. Y es un valor muy inestable. ¿Qué mecanismo, recurso matemático, puedo usar para hacer smoothing? No una smooth de frutilla, sino smooth de un valor que es muy inestable. ¿Conocen ustedes algún tipo de smootheador? Un promedio. ¿Cómo se implementa ese promedio? Bien, un promedio. Primera implementación, naive, sería... Bueno, yo promedio todo lo que me di hasta ahora. Voy sampleando, obviamente, con cada interacción con el lado remoto, más allá de que esto fuese sin SYNAC, acá va a haber mucho data, en ambos sentidos. Por lo tanto, voy a tener muchas verticalidades acá, RTTs, para ir sampleando. He sampleado 100, 110, 95, 150, 170. Una primera implementación naive sería, memorizo todos los RTTs, me salgo la pantalla a propósito, todos los RTTs, esta conexión que lleva días y días, y los voy promediando para calcular el RTT actual. Esa implementación tiene algún problemín, ¿no? Necesitas mucha memoria. Memoria infinita en principio, o tan infinita como es orden N, tan infinita con cantidad de paquetes hayan. Está bien la idea del promedio, pero ese no es el mejor algoritmo para mantener un promedio. ¿Qué otra manera se le ocurre que podríamos hacer un promedio? El último valor más el nuevo dividido por 2, y ese se asigna como el último valor. El último valor más el nuevo dividido por 2. Ajá, y lo vas acumulando. Quiere decir que, vamos a ver si me sale, hasta ahora las matemáticas no son mi... Me encanta la matemática, me hizo bueno. Pero hasta ahora, vamos a ver si me sale con una... Voy a volver a una ventana. No me acuerdo si BC permitía... Déjeme probar una cosita. ¡Oh, sí! ¡Bien! Entonces, vamos a hacer que el promedio sea... Arrancamos con el primer valor, 100 milisegundos. Hacemos que el sampleo, el nuevo sample, sea 150. Un momento. Que igual a 100. Sample igual a 150. Y hacemos que... ¿Vos cuál era tu sugerencia? P igual a P más S dividido. Listo. Ese valor va a ser ahora... 125. Bien. ¿Qué pasa si ahora tengo un sampleo? No hace falta... Imagínense, no sé, 95. 110. ¿Cómo lo ven ustedes? ¿Va oscilando mucho, poco, el algoritmo que propuso su compañero? Imagínense que vuelvo a samplear ahora 140, por ejemplo. Vamos a hacer una cosa, vamos a hacer que me lo muestre con cada... Y oscila bastante. Y oscila mucho. Está, ojo, está muy buena la idea, pero fíjense cómo oscila. Va de 132 a 106, con algo que sabemos, que el R(t) es súper variable. ¿Cómo podríamos hacer que este P más S dividido por 2, que está muy buena la idea, que en realidad si lo pensamos a 0.5 de P a 0.5 de S, cierto? P más S dividido por 2. Uh, prof, se jugó con la matemática, pero sería así básicamente, ¿cierto? Es lo mismo que P más S sobre 2. Sí. ¿Coincide? Bien. ¿Cómo podríamos hacer para que sea más estable esto? ¿A cuál de los dos factores le daríamos más peso? Al viejo. A la memoria, al que va corriendo, al P, al promedio, movil, moving average. Si usan cripto, ustedes ya conocen el moving average. No me hagan trampa, el MACD lo han visto ahí en Binance, todo, así que no se me hagan acá los inocentes que no han visto un moving average nunca. ¿Cómo modificaría estos factores? 70-25, por ejemplo. Ah, now we're talking. Ah, casi we're talking. Tenemos un problema en Houston, we have a problem. 70-25. ¿Qué va a ocurrir? Me va a ir al piso. ¿Qué debería hacer? ¿70 cuánto? 75. O sea, me falta el... Ok, te quedaste corto. Bien, ok. ¿Qué pasa ahora? Si está, fíjense, el 99 que está corriendo le pongo un 140. Y bueno, fíjense que a medida que le voy poniendo, fíjense que interesante cómo va como de a poquito aproximándome, no lo move y de 140 se va como aproximando. Después de muchas pruebas, si ahora se mejoró la red y baja a 100, se va a ir de a poquito, plin, plin, plin, plin, plin. Como algo que sea más duro todavía. Súper duro. ¿Cuánto le pongo a cada factor? 99. Ah, bueno, está bien. Eso es súper, súper, súper. Está bien. Vamos a hacerlo superín. Ahora, algo así de 140, fíjense que tarda en llegar 140, tarda en moverse. Obviamente, como estaban sugiriendo recién, si le ponemos un 99 y .01 va a ser durísimo de moverse. Fíjense, está ahí. Bien, en esa situación de compromiso, nuevamente, en una sesión espiritista, a los implementadores de TCP les llegó la información de que el mejor era 0.8. En esa... Esperen que vuelvo a presentar porque yo estoy... Volvía la diapo. Nuevamente, entonces a... Magia ocurre, magia ocurre, magia ocurre, magia ocurre... A los implementadores de TCP les llegó la señal alienígena o extradimensional de que el número es 0.8. Obviamente estoy haciendo algo ridículo de eso, sencillamente con pruebas y de ver este comportamiento y de ver la... El jitter, jitter, es la palabra correcta para esta inestabilidad de la latencia, o al menos en este caso la RTT, 0.8 se encontró como un buen compromiso para hacer exactamente ese cálculo que hacíamos recién. Fíjense que en ese cálculo no tengo que almacenar más que el valor actual de la RTT. Y yo lo voy retroalimentando con la próxima muestra, pero no tengo que almacenar toda una historia, ni siquiera dos o tres. El RTT actual y yo le meto un 80% del actual y un 20% del nuevo sample, y lo vuelvo a almacenar. Y así mantengo un moving average. Y con eso trato de suavizar estos coletazos que puede tener. Act time out. ¿A cuánto lo hacemos igual? ¿A exactamente el RTT que tenemos? No, más alto. ¿Cuánto más alto? No vale leer la pizarra. Un 20%. Ah, bien. ¿Qué pasa si lo hacemos igual? ¿Cuál es el riesgo? Que cualquier problemilla que haga automáticamente alarga el time out. Bien, perfecto. Es demasiado riesgoso ponerlo justo. Tomémoslo, yo no recuerdo, nosotros en los diápagos hemos puesto entre 1 y 2, pero está bien, creo que estaba en el orden del 25% más arriba. Depende, obviamente, la red también es configurable. Quiero que me describan cuál es el problema de hacerlo bastante alto. Imagínense que fuera 10 veces el RTT. Está mal, obviamente, me hace ruido en la cabeza, está mal, pero... ¿Cómo va a afectar el comportamiento de TCP que me recontrafume el act time out en 10 veces el RTT? Recuerden, nosotros nos gusta explorar, para entender un valor razonable, nosotros exploramos los extremos. El extremo que tocamos recién es que fuera igual al RTT y con el jitter de latencia es demasiado peligroso porque el otro puede enseguida interpretar, mejor yo puedo interpretarlo como un act time out, obviamente porque estoy demasiado histérico con el act time out igual al RTT. Un extremo. El otro extremo, 10 veces el RTT. Listo, ponle por 10 de cacho y vamos para adelante. ¿Cuál...? La red está infrautilizada. Easy, tranqui, tranqui, tranqui. Entendamos el problema y respondamos bien. ¿Cuándo yo reacciono contra un act time out? Casi que me estoy respondiendo. Cuando pasa mucho tiempo y nada más haya una QC de recibo. Quiere decir que el peligro de hacerlo es muy grande. Si la red está bien, no pasa nada, loco. Si el act time out es act time out. Por lo tanto, si no tengo act time out, no hay act time out. Así que le puedo poner un valor infinito y ya está. ¿Por qué nunca hay act time out? Porque todo anda bien. Sabemos que esta es una situación unicorniana tipo Rainbow, que no es así. Pero en principio lo importante de entender es que el valor alto de act time out me modifica mi tiempo de reacción y retransmisión. Y retransmisión es cuando algo falló. Entonces es menos, como decir, tiene menos impacto hacerlo más grande, alejarse del RTT que acercarse al RTT. Porque al dejar el RTT, hacer el act time out sustancialmente más grande que el RTT, el único impacto es mi tiempo de reacción a retransmisión. Porque es justamente frente a act time out. Y es muchísimo más riesgoso acercarlo al RTT. Por eso que está entre 1 y 2. No me acuerdo, eso debe estar sacado de algún RFC, no me acuerdo cuál es el valor. Recién decimos 25%, pero honestamente no lo recuerdo. Bien, ¿se entendió esto? Son cosas súper interesantes de ver cómo es el juego, ¿no? Hay de tiempos. Fast retransmit. Fast retransmit lo vimos ya de una manera implícita. Y básicamente es, me siento, I'm feeling lucky o I'm not feeling lucky. Con el 3. Si yo tengo act duplicados, ese mismo senador que tenemos ahí. ¿Cómo sería mi comportamiento? I'm feeling lucky. Me siento afortunado. O estoy optimista hoy. ¿Y si yo hago act duplicados? Suponer que los otros sí le llegaron. Exacto. Y solamente retransmitir el 3. Ahí. Rezando los dedos, I'm feeling lucky. Entonces, eso se llama, básicamente, perdón, me confundí. Este es el fast recovery, no el fast retransmit. El fast recovery es solamente envío del segmento consecutivo, ahí sería el 3, de toda esa secuencia de act duplicados. Y de paso, infló la ventana de congestión momentáneamente para acomodarme, es como para tratar de recuperarme rápido de la situación de act duplicados. Ese es el fast recovery. Y el fast retransmit es, en realidad, el siguiente. Que también se da, era mayor o igual que decía, si hay más de 3 DUCs. A ver acá, ustedes son, nuevamente, recuerden que no vemos el universo, vemos solamente nuestro lado. Y hemos transmitido 1, 2, 3, 4, 5, 6 y recibimos. acá 2K, tac, tac, tac, tac, tac. Y el 3 hay que retransmitirlo. Casi que seguro. Ahora, yo soy TCP. ¿Cuándo retransmite un TCP, señorcito? ¿Cuándo retransmite un TCP? ¿Cuáles son las reglas que he aprendido de retransmisión de TCP? Crillos. Cuando me llegue a 1CK repetido. Ah, ah, ah, error, no. ¿Qué es lo que hemos aprendido hasta ahora? ¿Cuándo retransmite TCP con lo que hemos aprendido hasta ahora? ¿Cuándo retransmite TCP con lo que hemos aprendido hasta ahora? ¿Cuándo retransmite TCP con lo que hemos aprendido hasta ahora? Este "sequence number" me va a ir expresando cuánto voy avanzando yo en el espacio de secuencia. Justamente es este que está acá. O mejor dicho, acá creo que tenía uno que había puesto mejor. Este "sequence number" representa de mi lado de transmisión cuánto estoy en el espacio de secuencia. Este segmento que te envío ahora, ¿Cuál es el "offset" de su arranque de espacio de secuencia? Más el tamaño, esto va a ser el espacio de secuencia que te estoy enviando. Es decir, hay que recordar que este "TCP" lo que empuja es espacio de secuencia. Acá está empujando el espacio entre un "k" y dos "k", entre dos "k" y tres "k" con este segmento. Y entonces, por ejemplo, si mostramos este, el complicado de este tres que se perdió, en el "sequence number" acá diría tres mil, perdón, dos mil, dos "k". Porque estamos acá. Y en su tamaño dirá lo que tenga como tamaño, con lo cual el otro sabe qué posición ocupa. Porque como bien sabemos, la red IP no te garantiza entrega ordenada. Por lo tanto, estos seis que fueron pueden llegar en cualquier orden y el otro lado tiene que poder reposicionarlos. Entonces, huele igual a fragmentación, pero es muy diferente a fragmentación, porque esta es la capa de transporte, la que está peleando por cada segmento. Y que mantiene timers por cada segmento. Y si tienen que retransmitir, retransmite cada segmento, a diferencia de la fragmentación, que como vimos, un fragmentito perdido, perdimos todo el atagrama. Acá se pierde un segmento y yo, TCP transmisor, sé que es ese segmento. Todo lo que acabamos de ver. Soy optimista, retransmito el tres nada más, espero que me llegue el "hack", todo eso por cada segmento de espacio de secuencia. Entonces, hacia secuencia de empuje, es este, "acknowledgement number", ¿qué será? Si este tiene la dimensión de 32 bits, ¿qué será el "acknowledgement number"? Para decir la posición, como habíamos dicho, 2K+1. Ajá, exacto, lo que yo le hackeo, es mi personalidad receptora, ¿no? Mi personalidad transmisora dice "sequence number", mi personalidad receptora dice "y de paso", te voy hackeando a este. Pregunta, es opcional, ¿no? Yo lo puedo ahí omitir. Juan, ¿me esperás un segundito que voy a bootear mi máquina y vuelvo? Porque quiero estar al final, mostrar una cosita, ¿me esperás? ¿Pero puedo seguir con esto? Sí, sí, sí. Ah, ok, seguí, por supuesto. No, no, no, pero digo, voy a reiniciar esta cagada. Ah, sí, sí, sí, no corto, no corto antes, si acá tengo nada más que unos 40 minutos más. Mentira, mentira, debo tener 10, 15. Sí, sí, te esperamos. Bien, entonces, "sequence number" es mi gorrito transmisor y "acknowledgement number" es mi gorrito receptor donde te hackeo. Fíjense que algo interesante es que el "ack" viaja siempre. ¿Cuál es el único, el único segmento de una conexión que no tiene "ack"? El "syn", el "syn". El "syn". Todos los otros tienen "ack". Siempre tengo algo para hackear, aunque sea lo mismo. Siempre tengo algo para hackear. Será repetido o no, de acuerdo a si el otro sabe que me empujó data o no. Pero si el otro está quieto, no te transmito nada porque está recibiendo. Yo soy el lado B, estoy "del", "recibir", "delay", no tengo nada del protocolo de aplicación, no tiene nada para responder. Estoy quieto, no son "acks" duplicados los que recibo, porque sencillamente el otro lado me está hackeando lo último que yo le dije. Como yo no estoy transmitiendo nada más, ok, sí, es el mismo "ack", pero yo no he empujado espacio de secuencia. Entonces no es que empuje espacio de secuencia y me quedó pegado el "ack" a un espacio de secuencia que no se empujó. Sencillamente está viniendo el mismo valor porque yo no tengo nada nuevo para transmitir en mi sentido de transmisor, de B hacia A. ¿Eso sería cuando termine de transmitir el último segmento, digamos? No, no, no, ¿por qué? Hacer el último segmento. Bien, puede ser un protocolo, va, viene, va, viene, va, viene. No pensemos solo HTTP, de "get/", no. Pensemos una comunicación, por ejemplo, una comunicación como esta, más allá de que esté usando UDP por otras cuestiones que vamos a aprender. Pero si es HTTP, va, viene, va, viene, es permanente, no, viaja, se... Viaja, se... En los dos sentidos hay espacio de secuencia empujado, en los dos sentidos hay espacio de secuencia "acknowledgeado", no. Y cada paquete va tratando de empujar y hacer "ack" de lo que ha ido recibiendo uno de otro lado. Ya vamos a ver qué ocurre en el fin de conexión. Ya vamos a tener oportunidad porque es también interesante. Vemos rapidito estos... Checksum, ¿qué será el checksum? ¿Para qué estará? Calcular la integridad. Bien, de la cabecera nada más, igual que IP, ¿no? De todos, creo. De todos. Acá, bien. Ok, IP se hizo el "sota" y dijo "no, yo te garantizo mi cabecera", pero bueno, IP justamente no garantiza contenido, pero papi, vos sos TCP, vos me estás garantizando que llegas sin error, entonces ese checksum protege todo el contenido, toda la data. ¿Sí? Entonces incluso protege la cabecera propia, arranca bien, viene la cabecera, termina en el último baile de datos, e incluso le agrega pedazos de la cabecera IP. También protege, es como muy generoso ese checksum del TCP. Como que arma una especie de paquete virtual, el mismo, toda la parte TCP, cabecera más payload de aplicación, y le pone también la IP, origen y destino, y sobre eso arma el checksum. Porque es muy histérico de asegurar no solo el contenido, sino que el origen y el destino sean los que se pretendían. ¿Eso es por la 5-dupla? Sí, más o menos, es una buena razón. La 5-dupla está presente y está chequeada y asegurada por TCP. Muy buena observación. Urgent pointer, estamos medio tarde para verlo. Sí, lo vemos, total, vamos a morder la clase que viene en cabecera. Pero un segundito, dejame. Windows, ¿es opcional la ventana? Es decir, ¿cuánto tengo yo de espacio de recepción disponible? Me pongo el gorrito del lado receptor, mido el tamaño de buffer de RX, y lo digo o no lo digo, ¿cierto? A veces sí, a veces no. Y si pones cero es que no tenés ventana, así que... No, pero si pongo cero es que no tengo ventana, que es muy distinto a no decir nada. Claro. Bien, si digo cero, es cero. No es whatever, no es none, es cero. Punto es, no es opcional tampoco. Fíjense, todos, en todas las interacciones, siempre, vieja siempre, cuando tengo yo TCP que reconstruir lo que sea, empujando secuencia de bytes, espacio de secuencia, o hackeando al otro, o ambas cosas juntas en uno solo, siempre digo, y de paso, por cierto, por el mismo precio, a ver cuando está nuestro buffer de recepción, está en 20k, la ventana es, Windows, escribo 20k y viaja a los 20k. Y en toda interacción, en toda, va el contenido de la ventana, porque eso le da mucha actualización al lado transmisor, de en qué estado de control de flujo está del otro lado. Cuán presionado está el buffer de recepción. Entonces directamente, no es opcional, va siempre. Y después hay algunos flags. En estos flags, como para que sepan, estos flags contienen el SYN, el ACK, y vamos a ver el FIN, que vendría a ser el primo del SYN, pero para terminar una conexión, y algún otro flag loco por ahí. Pero esto lo vamos a morder de vuelta. Lo importante que queríamos ver es cómo cerrar esta parte de TCP hoy con un intro de la cabecerra. ¿Alguna duda de esto? No, ninguna. Bien, ya tenemos la grabación. ¿Vas a hacer algo que quieras agregar a la grabación, Diego? ¿Lo que querías mostrar ahora? Déjalo así. ¿Bonus track? Dale. Así queda como bonus track de... Buenísimo. En realidad iba para distender. Dejo de presentar iPod, tomar mate. A ver. Tengo la garganta seca. Todo tuyo. Toda mi pantalla. Bueno, parece que voy a ir desplegando mis trucos. Pantalla, chicos. Compartir. Ahí está. A ver, ¿de cuándo es esto? Es un ratito. ¿Se ve ahí? Sí. Dale un cachito más. A ver. Vos me troleaste cuando estábamos en el fondo, ahora yo te troleo. Qué sudo, cómo le cambio el fondo. Este es mi Windows 10. Ocultar. Que viene con mi... Con mi compu. No, lo que les quería comentar, la verdad que hace rato que lo vengo siguiendo y me parece que Microsoft está encaminando bien, me parece. Concido. Ha hecho muchísimos aportes de Open y Container. Este es mi Windows 10. Lo primero que les quiero contar, y les voy a dejar después, si quieren la punta de este ovillo, tiren de este link para entenderlo. Se los voy a poner acá. Microsoft acaba de liberar, hace rato que viene trabajando en un sistema que se llama Windows Subsystem for Linux, que básicamente permite correr Linux adentro de Windows. Yo he seguido mis pasos. Lo que voy a abrir es, esto es un Ubuntu 20, pero es un Ubuntu de verdad este. Esto está corriendo un Ubuntu de verdad. Y diríamos que la última, esto es WSL2, es decir, es Windows Linux Subsystem 2. Si hacés, por ejemplo, un Ame-A, te muestra la versión kernel. No, te quiero mostrar esto, claro. La versión anterior era una transcodificación de comando. Esto es una máquina virtual con un kernel hecho por Microsoft para correr arriba de Hyper-V, que accede hasta la más baja capa, digamos. Eso es el firewall de este. La verdad que está muy bien ofuscado para el cliente final, pero esto es una máquina virtual entera. Yo estoy en otra máquina, no estoy en mi máquina acá. Esto es una máquina virtual entera. Yo pongo acá ipconfig. Este es mi Windows. El Windows tiene un IP, como ustedes la ven acá, 54. Y esto tiene una red que ha creado facilísticamente acá. Entonces, la primera, digamos, esto está hace rato. Es Windows Linux Subsystem. Esto es un Linux entero. Acá yo tengo mi BI. Tengo un Ubuntu. Apete get update. Instalo lo que quiero. Muy bien logrado. Esto funciona muy bien. Lo que está muy simpático y siempre ha sido un trastorno, y eso es un poco lo que les quiero mostrar y está ahí en el puntero, es hace menos de un mes Microsoft resolvió la manera de integrar aplicaciones gráficas. Todo el manejo de aplicaciones gráficas en Unix es una galleta. No es una galleta, es perfecto, pero entenderlo es difícil. Pero lo que yo les quiero mostrar es esto. Yo voy a abrir una Xterm. Primero mira la velocidad en la que abrió. Esto es una aplicación gráfica de mi Ubuntu. ¡Oh! Está suelta, boludo. ¡Qué bárbaro! ¿La ves? ¡Qué locura! Mirá. Claro, es un widget. Bueno, es un widget. Tiene un frame gráfico en el mismo... No, no, no, por eso. Y muy liviano, anda muy fuerte esto. ¡Qué bien! Le voy a mostrar... Justo iba a preguntar si se podía poner interfaz gráfica. Mirá esto. A ver si... Bueno, lo que acaba de lograr Microsoft es esto. Mirá, este es mi Open Office, pero está corriendo adentro de esa máquina virtual y está hallando... La verdad que es una galleta lo que han hecho. Es muy interesante. ¿Hacés Open File como te mapea tu File System? Está mi File System Linux. Mi File System Linux que está montado acá. Pero obviamente ellos han mapeado al /mntc. Ah, perfecto. /mntc está mi disco C de mi máquina Linux. ¿Y cómo es /mntc/usertiego? No, si quiero. Mi home es /home/ de Navarro porque es un UNIX. Pero si quiero ir a mi Windows, puedo entrar por ahí. Lo que quiero decirte es que esta es... New Text Document. ¿Cómo está hecho esto? Si lo ves, Juan, es un RDP contra una máquina. Ah, mirá. Y lo han resuelto todo por adentro los tipos. Tiene un nucleocito de RDP, entonces corriendo. Si vas a un PSAXX, verás ese RDP. Mirá, mirá. Esta es la solución. Está muy interesante esa nota que le acabo de pegar. No tiene desperdicio. Si les interesan los sistemas operativos y las cosas... Qué bien. Esto, para poder disfrutarlo, tienen que tocar su Windows. La verdad que no uso mucho el Windows. Me tomó un tiempo. Capaz que para ustedes es una pavada. Hay que tocar acá, poner el canal. Hay que suscribirse al Windows Insider. Windows Insider. Y es como que tenés que sintonizar el canal de desarrollo. Windows. Insider. Y te reinstala el operativo, en realidad. Insider. Acá está. Programa Windows Insider. Acá hay que agarrar y decir que querés el canal de desarrollo. Y ahí te aparece la actualización en el Windows Update. Y le pones... Necesitas la última versión de desarrollo, que es... Acá está la... Opción de avanzada. ¿Dónde es que se ve? Información de compilación. Es la 21... No sé cuánto. Farasa, sasa, fafa. Esto. No sé. Bueno, ahí explica el coso. Ahí está, la 21390. Y trae... Yo lo había hecho andar. Le había puesto un XServer y lo había hecho andar igual. Pero esto está muy bien resuelto. De hecho... Mirá. Mirá esto. Mate Session. Mirá qué galleta. Y es lo que hace jugar. Mirá cómo flotan. No sé si se va a alcanzar. A ver. Este es XFault, o me parece en el... ...le va a haber corrido como root. A ver. Sí, le ha corrido como root. Y ha quedado pegado. Mirá esto. ¿Lo ves? Sí. Claro. Sí, sí, sí. Te armó toda la sesión. Qué bueno. Transparentado. Es como un poco de... Es como un poco de... ¿Cómo se llama? Transparentado. Es como un frame transparente. Por eso. Pero esto es un RDP contra la máquina. ¿Entendés? Sí. Las ventanas están... Es como si le hubieran hecho un manejador de ventanas... ...que habla RDP contra... Claro, pero lo que es interesante es que no te marca todas las ventanas. Eso que las ventanas están libres flotando. Eso está súper bueno. Está muy bien. Lo de siempre. Tenés un escritorio y adentro, como lo tenemos en la Cloud, por ejemplo. Bueno, les recomiendo que lo prueben. Y les doy dos... Esto es lo último. Se llama WSLG. Es Open Source. Microsoft lo ha liberado Open Source esto. Está en GitHub el código. Está acá. Esto es Open Source. Lo que han hecho. Sí, están muy... Están muy, muy... ...sincronizados. Y les quiero mostrar dos cositas más. Para que lo tengan. Que está muy bien resuelto también. Yo tengo Docker, que ya lo vamos a ver, corriendo en mi máquina. Es decir que si yo hago acá... Docker... ...PS. Perdón. Ah, Docker para Windows, negro. Docker de Windows está corriendo. Sí, pero mirá esto. Este Docker de Windows está conectado por acá adentro con este Docker. Es el mismo Docker. Ah, le han exportado el socket de conexión y qué sé yo. Y en realidad... Está muy bien resuelto. Es decir que... Es más, si yo acá hago... Docker Run. Docker Images, para que ustedes lo vean. O haces un Docker Run - IT Alpine o algo así. Una cosilla de esas. Fíjate. Docker PS. Pronto. Está bien. Y este Docker... ...si ustedes lo miren... ...trae una cosa muy bonita, que es esta. ¿Tenés idea de quién costó el Docker D? Ahí en ese caso, sigue siendo el Docker de Windows. El Windows, es este. Y este Docker viene con un clastercito Kubernetes de regalos. Sí, bueno, esos son los Dockers nuevos en general, pero está bueno. Qué bueno, qué bueno. Así que ahí tenés KubeCTL, si quisieras, si lo apuntás bien. Y yo podría usar... Sí. Sí, es verdad. Si lo pudiera apuntar acá afuera. Y puedo... ...apuntar aquí. Y puedo... Bueno, han hecho una conexión... Si usar al... Creo que lo tengo. Visual Studio. Visual... No, no lo tengo acá. Visual Studio. No lo tengo. No, no lo tengo. Bueno, podés usar Visual Studio... ...y desarrollar en el Windows conectado a la máquina Linux. Bueno, este es un... Este es una segunda capa... Una tercera capa de Incepción, digamos. Están borrando los bordes, digamos, para que... Claro. La verdad que alguien no se sepa... Es decir... Esto es una máquina virtual entera y se puede convivir... Lo que hay atrás se llama WSL, acá. Y ustedes pueden tener varias distros. Yo tengo ahora puesto la Ubuntu 20, pero podría acá instalar otro Linux. Desde el Windows y tener varias distros Linux. Adentro de esto, corriendo como esto. Y a su vez, cada una de ellas, tener... Ambiente gráfico, digamos. Se les pega el teclado a veces, no es que está... Pero... Bueno, nada. Era mostrarles eso. Que ya dominamos Windows también. Sí, muy bueno. Ahora, también establece cuál es la inf... Cuál es el destino de la infra contenedizada. Dónde está lo que va a correr tu aplicación de producción. Ya está, ¿no? Sí. Sí, claro. No, pero muy bien, Che. Sí, muy bien. Muy bien. Hace más o menos dos años y medio, Microsoft hizo una contratación masiva de gente del mundo... Open Source, específicamente de gente de Docker, contenedización. Y acá se ven los frutos. Muy, muy, muy bueno. Así que, si alguno lo quiere probar y tiene... Bah. No le diría que alguien quiere probar. Esto es cultura general, muchachos. Pero ustedes deberían saber lo que... Es más, deberían hacer... Si tienen Windows, deberían hacer andar sus... Sus... Sus mininetes. Ahí, adentro. Ah, no, puta, no hice esa prueba. Puta, me quedé en paz. No, no tengo... Pensé que la demo era eso, prácticamente. No tengo... No, no, no, quería ver... No tengo... No tengo mi ceratina acá adentro. No, quería ver por ahí si me conectaba remoto, a ver si me desplayaba... No, pero yo te decía los mininetes directamente a autocontenido del mismo host, pero bueno... Ah, bueno, sí, acá sí lo hago. Sí, eso es obvio, pero estoy diciendo una viega. "Install mn" No, "mininet". "net" Y corres el editor, tiene que poner... Tenés razón. ...tu barra. Tenés termes y todo. Tenés razón. ¿Se entendió lo que vimos, muchachos? ¿Alguien entendió? ¿Qué está pasando? Sí, sí, se entendió. Sí, una locura me pareció. Muy bueno, muy bueno. Pará, entonces... Déjame ver, vos decís... Ni hablar que le... Te digo, ni hablar que le pase el trapo a esta porquería bonita que tengo acá frente a mí. El Docker para Mac apesta. Bueno, si me siguen en Twitter han visto que yo sistemáticamente estoy trasheando a Mac. Si hay algún goal que tengo en mi vida es que alguien pueda decirme gastarse más de 2.000 dólares en esta cosa bonita, cara y no usable para containers. ¿Y por qué usa Mac, profe? Por la compañía para la que laburo, una cuestión de policy. Porque le pueden instalar... Esta máquina está auditada por una cuestión de compliance. Nuestra compañía obviamente tiene clientes y para poder hacer compliance, como nosotros laburamos remoto, esta máquina en la que yo trabajo tiene que estar monitorizada por cuestión de seguridad. Y esa monitorización la tienen implementada... Han como que normalizado la plataforma de trabajo de los empleados en Mac. Estamos empujando un poquitito para ver si entra Linux ahí. Nuestro CTO, Diego, es un ex Microsoft y tiene el corazoncito ahí, así que estoy juntando básicamente jurisprudencia para mostrar lo pedorro que es el entorno de Docker en Mac. Para ver si nos darían la puertita de investigar... Si no, pedile, si es hombre Mac, es hombre Windows, pedile que te traiga una Sarf Ix. Una Sarf Ix, una que tiene procesadores MIPS. Tiene procesador... Los otros... Arch. Lo que pasa es que corre dos pavadas de Windows, no se le podía parar a Linux. Tranqui, estoy de poquito... Creo que voy a tener éxito en quizás... Ahí estamos, mirá papá. Bien. Ah, mirá que belleza. Belleza, belleza. De toque. Sí, obvio. Y ahí podías abrir una Kisterma allá adentro, ¿no? Sí. Bueno, cuando lo corras, lo mandás a correr. Ah. Run. Ah, no, lo pasé como root. Igual, esto anda muy fuerte, se ven livianitas las cosas. Bueno, mi máquina es un i7, pero... Bueno, no tienen excusa, muchachos, para estudiar. Miren, si quieren quedarse adentro de sus Windows... Está todo bien con el Windows. Muy buena noche. A ver, msudo.mn. Database connection file. Ah, está usando vSwitch. Servi. Bueno, a ver qué ponés. Son controladores borde de la cosa. No, pero puede ser por ahí que el networking tenga algunos... No, es que este Ubuntu es como un container, no tiene... Mirá. Sí, claro. Ah, mirá, PSA. Un init, un init, nada, no hay idea. Un init, mirá. Por acá habla con el socket. Ajá, ahí se lo lleva al host. Bueno. A darle una muradita, si quieren. Acá se los pegué en el Slack, el link a donde lo pueden ver. Y nada más, eso. No les robamos más tiempo. Muy bueno, Diego, gracias, loco. Muy bien. Bueno, mucho gusto. Paro la grabación. Un perk.Bien, entonces vamos a dar inicio a la clase del día de hoy sobre protocolo IP. Algunas de las temas de este protocolo estuvimos conversándolos en la clase anterior. Si tuviéramos que definir en qué capa se encuentra el protocolo IP, ¿alguno podría comentarme en qué capa considera que está el protocolo IP? Capa de red. Capa de red, dice acá. Hola, Juan, buenas tardes. ¿Qué tal, Co? Bien. Estamos busteando IP de lo que habíamos hablado. Estoy usando un par de diapos de las que tenemos en el pedacito de la primera sesión y después tenemos en otro pedazo, pero creo que sirve. Sí, sí, perfecto. Cambiamos el MIT. Me parece que vamos a tener otra pizarra. La pizarra va pegada al MIT. Sí, de hecho tiene el mismo ID. A ver si abro esta otra. Una nueva. Tengo que hacer otra nueva, entonces. ¿Qué pasó con el otro marchito? Seguía pidiendo permiso. La verdad que no tenía solución de fondo porque el permiso lo cambiaba estando adentro. Entonces, es como si yo tuviera que abrir la llave y decirle, bueno, ahora pueden entrar todos, pero no es cómodo para los chicos. Así que hicimos lo nuevo. Y eso es un dúo. Me parece que puede haber sido el tema de cambio de cuentas de Gmail a la universidad. Algo ahí no le gustó la otra vez, me parece. Pero creo que viene por ahí. Bueno, estábamos tratando de, o en realidad estaba preguntando si pudiéramos comentar o en qué capas se encuentra el protocolo IP. Cuando hablo de capas, ¿a quién me tendría que estar refiriendo, más o menos? Claro, ¿en qué idioma estás preguntándolo? ¿Estás preguntándolo en el idioma...? En capa... ¿Idioma voz? Sí. En el idioma coloquial. ¿Quién es Don Capas? ¿Quién definió las capas de los protocolos? El modelo OCI. El modelo OCI. Vamos a ver. Según el modelo OCI, tenemos varias capas, ¿no? Sí. ¿Cuántas? Siete. La ocho de los usuarios. Muy bien. Vamos a hacer una más acá arriba. Siete capas. Sí. Habíamos hablado, acá arriba está el usuario. Si pensáramos sobre el estándar TCP/IP, que es un poco lo que a nosotros nos reúne a estudiar acá, es una cosa importante para saber que, históricamente, el modelo OCI es posterior al protocolo IP. Es decir, escribieron el modelo OCI por los 80, ¿y alguien sabe más o menos desde qué época viene el protocolo IP? No. En Brasil, faltaba del año 50, del año 60, del año 30. Más o menos dónde lo ubicarían, digamos. Como el 85, puede ser. Y medio que les tiré una punta y les dije que el modelo OCI es del 80 y es posterior. Claro, bueno. En realidad es de los 70. De mediados, entre el 74, por ahí, nacen las primeras ideas sobre el stack TCP/IP, que viene del estudio de los problemas de las redes que transmiten paquetes. ¿Sí? Redes de conmutación de paquetes. Entonces, como este modelo es anterior, pero lo que quería es que más o menos nosotros miramos cuáles son más o menos las capas del protocolo del stack TCP/IP. Disculpenme mi pulso, pero he tratado de hacer, a propósito, que caiga más o menos la mitad de esta, ¿no? ¿Esta cómo se llamaba la primera de acá? No estaba presentando. Ah, estoy hablando, dibujando, me estoy matando dibujando acá en la pantalla. Sí, unos dibujos así espectaculares, prácticamente artísticos, para hacerle un NFT. Ahí estoy. Estaba escribiendo en el pizarrón, pero ahora estaba hablando solo. Esperá, esto es algo que... Denme un segundo, voy a matar esto porque... Un segundo, que cierro todos mis mensajeros, así ninguno... Ahí está. Disculpen. Vamos a ver. Ah, si yo hablaba, el pizarrón, bueno, el pizarrón si te conectas lo ves. Bueno, eso sí, lo que pasa es que no podemos ver tu cursor. Bueno, ahí estamos. Bueno, casi, se ve la cabecita, pero mejor sí. Ahí está. Decía, había tratado de dibujar este lado del stack TCP/IP para que, el objetivo es que lo ubiquemos y le pongamos hoy por lo menos nombres a todos los muchachos y lo relacionemos con el modelo. Ahí estaba la capa física, ¿no? La que sigue, ¿cómo se llama? De red. Capa física, capa de enlace. Enlace, muy bien. Después viene la red. La capa de red. La capa de transporte. ¿Qué viene? Sesión. Presentación. Aplicación. Bueno, muy bien. Habíamos dicho el otro día, estuvimos hablando que la capa física era todo lo que se podía tocar, básicamente niveles de tensión, conectores, cableados y esas cosas. Y la capa de enlace ya es una capa lógica, ¿no? Y digamos que si tuviéramos que cortar y decir "che, acá está el corte de la capa de red", acá sí hay casi un mapeo bastante claro. Otro amigo en cuestión está ubicado acá. Protocolo IQP es un protocolo de capa de... Dos. Dos de red. Bueno, este es tres, ¿no? La capa de red es tres. En realidad IPE tiene un montón de capas. Acá empezamos a ver un poco las cosas de las prácticas... Ay, gracias, Juan. Bueno, y digamos que acá está, existe la capa física en IPE. Alguno me puede ir contando algunas capas físicas de esta familia de protocolos acá. ¿Conoces alguna capa física de TCP/IP que estemos usando o no? Ethernet. Bien. ¿Qué otra? FTTH. Ajá, a ver. FTTH. ¿Son todas distintas esas? En cuanto a media o físico, sí. Ajá. ¿No es independiente, profe, el medio físico del protocolo? El protocolo... ¿Cuál? El protocolo IPE. Claro, efectivamente. Por eso estoy tratando... Estoy indagándole a ustedes para que digamos, bueno, a ver, ¿cómo es? Todo bien. De hecho, es una de las cosas que vamos a ver ahora. El protocolo IPE tiene esta misión. La misión de que, bueno, la verdad que no importa qué hay abajo. Pero nosotros sabemos que hay varias distintas abajo. Y a su vez acá hay una... Fíjense que acá está la capa física y la capa de enlace. Les pregunto a ustedes, ¿qué es la capa de enlace en la lógica del modelo OSI? ¿Qué dice el enlace? ¿Qué gobierna la capa de enlace normalmente? Las MACs. Sí, una forma de resumirlo es las MACs. Pero... Transferencia de datos. Ajá. Enlaces link, ¿no? Es decir, básicamente es, che, ¿cómo voy a acceder yo a este medio que tengo abajo, a este medio físico? Porque en realidad voy a estar viviendo sobre redes que son muy variadas. Por ejemplo, una red de las que son todos apellidas... Para nosotros es Ethernet. Ustedes dicen Ethernet. No sé a quiénes meten en Ethernet. ¿El Wi-Fi es Ethernet para ustedes? ¿O no es Ethernet? ¿Qué es Ethernet? No, el Wi-Fi no es Ethernet. ¿Por qué no? Pues otro protocolo. Bueno, no, sí es. Es decir, vamos... Por eso quería un chiquitino acá. Es decir, acá tenemos un tema que está la capa física, ¿no? Y acá está la capa de acceso al medio. Acá en realidad nosotros podemos tener muchas capas físicas, ¿sí? Vamos a una que dijeron recién. Diganme una rara distinta a todas las que... Hay una bien rara que usan todos los días cuando están afuera de su casa. Ah, 3G. El 3G, por ejemplo, ¿sí? Que estaría... El medio es una antena y está más o menos... Ustedes lo ven y dicen "chiste, esto no es Ethernet, digamos, no es ni Wi-Fi". Una cosa diferente. ¿O no? Sí, telefonía. Telefonía es para hablar por teléfono, pero cuando mandan datos, haganlo por contraposición. ¿El teléfono usa IP? Si ustedes navegan con 3G, vamos de arriba para abajo. ¿Navegan en 3G o no navegan? Sí. Esa navegación, ¿sí? Que está acá arriba, ¿no? Está en el protocolo de aplicación, ¿no? Está acá. HTTP. ¿Uso IP? Sí. Entonces, si ustedes navegan en 3G con HTTP, ¿qué tiene que tener por 3G el teléfono para jugar en una red de estas? Una IP. Tiene una IP. Es decir que acá hay una capa, vamos a decir, 3G, y acá hay un ligamento en el medio, que es toda la capa de acceso al medio, que es un poco la que hace el enlace, ¿sí? Que bueno, acá hay unas familias de varios protocolos, acá existe el protocolo que se llama ARP y otras cosas que permiten básicamente saber cómo el protocolo IP, que de acá para arriba todos los que juegan en una red IP, ¿qué necesitan para jugar? La IP. La IP nomás, ¿sí? Esta es una de las primeras misiones del protocolo IP, es la abstracción de la red. Yo juego en una red IP y soy un IP. No importa si abajo hay una tanza, hay un cobre, hay una fibra óptica, un cable telefónico, un cable eléctrico, yo tengo IP y estoy en la red IP. ¿Ok? Una de las primeras misiones que vamos a ver es IP se va a tener que relacionar, porque acá no hay una magia perfecta, en cómo hace para hacer uso del medio en el que hemos desplegado el protocolo IP. Y acá aparecen muchas familias. Lo que la buena noticia es que hace mucho tiempo, eso que nosotros resumimos como Ethernet, se ha vuelto una especie de capa estándar para todo esto y son todos los muchachos cuyos padres, ¿qué apellido tienen? En normas de la IEEE, o qué, bueno, no es apellido. Qué prefijo, qué numerito por ahí que tienen. Es bueno, es bueno. 802. 802, muy bien. Por los familiares 802.algo, ¿qué es lo que comparten los 802.algo? Algo que sí dijeron recién ustedes. Si yo les dijera, mira, todos los 802 son, qué seguro que todos tienen algo común, o una manera común de hacer algo. Alguien lo dijo recién, cuando yo le dije qué es la capa enlace y alguien dijo. Las Macs. Hacen eso de Macs. Claro, porque brillantemente la ingeniería acá. ¿Quiénes son 802? Miren, acá están. 802.11, el primer Wi-Fi. 802.16. 802.3. 802.4. Estos apellidos son los que cambian el medio en el que funcionan los 802. Uno de estos es Wi-Fi, el otro es Wi-Max, el otro es Ethernet, el otro es Token Ring. Y las tecnologías como las que ustedes dijeron de FTTH, que se llama GPON, son 802.1, que se está tratando de normalizar. ¿Por qué? Porque encontramos que esta capa 802 es básicamente la que se necesita codear acá, donde se relaciona básicamente la manera en que yo mapeo una dirección IP a un medio físico. Porque es muy distinto tratar de averiguar qué tiene un IP en un Wi-Fi a qué tiene un IP en un cable, en una red de Ethernet, en un switch, o en una red de fibra GPON, o en un LTE, que incluso tiene una compatibilidad parecida a esta. Y una cosa que siempre les tratamos de explicar nosotros, ¿quién hace este laburo en una ...? ¿Dónde corre este stack IP? En una licuadora, en una batidora, ¿en dónde corre? En una computadora. ¿El teléfono de una computadora? Sí, en cierto modo. Bien. Pero eso, en un dispositivo computacional, que puede ser un... ¿Nombre de dispositivo raro que tiene un IP? Televisor. El tele puede ser uno de estos. ¿Quién más? Impresora. Impresora es uno de estos. Una heladera moderna. Bien, bien, bien. ¿El lavarropa mío tiene Wi-Fi? Se maneja jamón por Wi-Fi. ¿El lavarropa tiene Wi-Fi? Un DVR. Un teléfono. ¿Un teléfono? Un DVR. ¿Un teléfono? Un teléfono. ¿Un reloj? Sí. ¿Ah? ¿Un reloj usa una...? Bueno, ahí está... ¿Alguno tiene algún reloj inteligente? Algunos son por Bluetooth. Sí, por Bluetooth. Ajá. ¿Y qué hace el Bluetooth? Es una rellena y unos que son 3G. En realidad, el reloj... Bueno, algunos usan como proxy de redes, pero no es el mismo que el reloj. ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj? El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿El reloj es el que se usa para... ¿Cuál es la clave de lo que es la capa de enlace con 802? ¿Qué características tienen los medios 802? ¿Que permite una red de más de dos computadoras? ¿Y qué conceptos se necesitan? ¿Qué mecanismos se necesitan para poder hacer que eso... ¿Qué son de bien? Si yo estoy en una reunión, en una sala... Con mucha gente y quiero hablar con otra persona que no necesariamente tengo al lado... ¿El ruteo? No, no, el ruteo. Yo no le estoy diciendo a otra persona "che, no le decís a lo otro, por favor" Que no, no, yo quiero hablar con él, estamos en una reunión todos dentro de una sala... Cualquiera que hable hace ruido a todos, entonces... ¿El algoritmo de control de acceso al medio? Ajá, ¿alguna idea de cómo es a modo de cierre? Ya, como bien dijo Diego, no volvemos sobre esto, pero es por ahí cultura general importante. ¿Cómo trabaja ese algoritmo? ¿Así rápidamente? ¿O cómo lo... Ya vieron ustedes? Y todas las placas están escuchando la red y evitan también colisiones de esa manera. Por escuchar no evitas colisiones, ¿no? La analogía con la sala, con toda la gente es sumamente representativa. Están todos escuchando y solo recibe el que yo le quiero enviar por la marca que tenga, ¿o no? Es detección de portadora, detección de colisiones y acceso al medio. Bueno, bien. ¿Detección de portadora cuál sería la analogía? O si quieren decirme técnicamente, díganmelo técnicamente, ¿qué significa detección de portadora? Que va a estar escuchando si el canal está ocupado o no. Correcto, entonces no tiene sentido meterle ruido e intentar inyectarle señal si el canal está ocupado. Va a estar escuchando el canal y va a darse cuenta que si la señal que está transportando es diferente de la que recibe, se produjo la colisión. No, eso es un segundo aspecto. Un aspecto es escucho y no interfiero, ¿no? La analogía con la sala es totalmente aplicable. Si alguien justo está hablando, hablo a los gritos para que escuchen todos, para que ocupe el medio. Hablo a los gritos y no me voy a poner a pisar porque sé que habla. ¿Cuál es el problema? Ahora yo ya escucho que está libre el medio. ¿Me dieron alguna tarjetita que dice "ahora te toca a vos"? Espera un cierto tiempo. Sí, muy cortito, pero ¿dónde está la espera? ¿Qué pasa? Ok, ahora hay silencio. Es mi turno. Intento. Y eso me da garantía que tomo el medio, que el medio es mío y que no va a tener interferencia. No. ¿Y cómo sé que hubo interferencia? Ahí un aumento de voltaje. Bueno, hay ruido. En la forma, claro. Yo pongo mi señal, empiezo a hablar y me escucho a la vez. Y si yo veo que hay interferencia, porque otro también está justo poniendo señal, los dos... Acá hay una teoría de juegos, pero los dos soltamos el medio y ahora esperamos exactamente el mismo tiempo para intentar hablar de vuelta. No, es un tiempo diferente. A cada uno se le va asignando un tiempo distinto. Si se produce otra colisión, van a tener que esperar el doble de tiempo. Ojo, cuando a cada uno se le va asignando suena que hubiera un dios del Eternet y no existe. No, cada uno se autoasigna un tiempo a lo todo. Ahí va. Un tiempo... Una ventana. No, no, no, qué ventana. Un tiempo random. Hubo colisión. Ups, los dos intentamos al mismo tiempo. Tiro los dados y me dice que me toca en 100 microsegundos y al otro le salió que le toca en 210 microsegundos. Bueno, genial. Gana el primero porque le tocó a 100 microsegundos y ya tomó el medio y el que le tocó un poquito más tarde sigue escuchando porque ya escuchó que el medio estaba ocupado. Y ahí se repite el algoritmo. Sí, sería el algoritmo de Backoff, ¿no? Claro. Sí, el algoritmo de Backoff. Ah, sí, sí. Bueno, sí. No estoy seguro que Eternet tenga Backoff. Buena pregunta, no lo sé. Sí, sí, tiene Backoff. ¿Tiene Backoff? No, no, no, CDMA, CDMA, CR. CDMA, CA. Sería el Collision Avoidance. Mirá vos, no sabía que tenía Backoff. El que no lo tenía era el Aloha. Pero bueno, es la lógica. La pregunta que quería, que le hacía, esa que está perfecto como lo han especificado, es ¿está claro qué tipo de medio es? ¿Por qué hay que revisar todo eso? Es un poco lo primero que pregunta Juanjo. Un poco un medio compartido. ¿Y cuál es la antítesis de un medio compartido? Que no podemos transmitir todo al mismo tiempo. No, no, está claro. Eso, digamos que con estos algoritmos, y más un montón de otras sofisticaciones, porque en el aire, por ejemplo, el Wi-Fi es más complicado para hacer todo eso, pero digamos que de alguna manera todos los que son, recuerden que Ethernet es algo que no existe, digamos, es un bus universal donde están todos ahí escuchando y hablando. ¿Cuál es la antítesis de eso? Es decir, si no hay redes así, ¿cómo puede ser una conexión? O no hay otra. De punto a punto. Por eso, ¿y qué hay en un punto a punto? Un enlace dedicado. Está bien, se puede hacer un enlace dedicado con un Ethernet, pero en un punto a punto, ¿qué creen ustedes? ¿Quiénes están en un punto a punto? ¿Cuántos hay? Solo dos personas. Ah, no, hay dos extremos, digamos. ¿Y si yo tengo una punto a punto, ¿tengo que esperar que el otro deje de hablar para hablar? Depende, puede ser HAL duplex. Bien, bueno, en un HAL duplex tenemos un solo canal, si yo hablo el otro tiene que callar y si él habla yo me tengo que callar, pero normalmente, ¿cómo es eso? Bueno, así es. Si no es HAL, ¿cómo es? Full duplex. Full, entonces yo quiero hablar y le hablo, y él me quiere hablar y me habla, entonces permanentemente hay... Y en un punto a punto, en el punto de IP, ¿cómo creen que se implementa? ¿Cómo, profe? En IP, el acceso al medio de una línea punto a punto. ¿Cómo creen que se implementa? ¿Es más complejo? ¿Es 802 o no es 802, digamos? ¿Tiene max? ¿Va a necesitar max? Ya con inundar el medio, digamos, con mandar el mensaje, le va a llegar al otro. No hace falta direccionarlo. Bueno, no... Pero entonces no debería haber IP, por ejemplo, si no tendría que direccionarlo. Una cosa es que haya mucho en el medio y otra cosa son las IP. En una línea punto a punto, ¿cuántas IP creen que hay? Dos. Sí, dos. Esta y esta, digamos. Si yo quiero hablar con este, los paquetes IP van a tener la IP de él. Nada más que cuando accede al medio no tengo que esperar nada. Hablo con él. Además, pueden haber paquetes que van a través de él que no son para él. Pero yo decido enviarlo a través de él. Ya vamos a hablar de routing, que es una de las cosas que más me interesa. No sé si eso responde al masajeo que estabas tratando de llevar adelante, Juan. Sí, sí, sí. Perfecto. Bien, entonces, para ubicarlo estructuralmente estamos hablando de este señor con el cual vamos a compartir dos o tres clases más. ¿Quiénes vienen acá arriba? A este nivel, ¿qué vienen? La capa de transporte. ¿Y cómo se llaman en nuestras familias? TCP. TCP. Perdón en el pulso. ¿Nada más que TCP hay? Y UDP. ¿Por qué hay dos? Según las necesidades. Bien. Digamos que de alguna forma el viaje de nuestra materia transcurre por estos intervalos de temas. Entonces, vamos a hablar de los transportes, pero digamos que, si le hiciéramos una pregunta al día de hoy, ¿qué olfatean que hace TCP y que hace UDP? Distinto uno del otro. Lo que hace TCP es verificar que estén todos los paquetes, o sea, que hayan llegado todos los paquetes. En cambio UDP no. UDP, digamos, no lo verifica. Por ejemplo, ahora que estamos haciendo esta videollamada, es a través de UDP. Porque no tendría sentido reinviar todos esos paquetes que se han perdido. Bien. Digamos que, si esto es otra capa es porque tiene emisión distinta, ¿no? Por eso tenemos separado el problema. De hecho, fíjense qué inteligente. De nuevo, estamos hablando de 40 años. Qué inteligente, y ya en realidad hemos hecho el viaje al revés este año, pero la verdad que los padres de la internet no hicieron esto así porque sí. La verdad de la cuestión es que eran desarrolladores de aplicaciones. Querían hacer aplicaciones, querían usar el mail entre una computadora que estaba en un lugar y en otra computadora que estaba en otro lugar. Entonces querían hacer una aplicación de acá arriba. Estaban pensando en una aplicación. Si yo les digo a ustedes que tienen que hacer esta aplicación y quieren mandar un mail de una computadora que está en Mendoza acá a una que está en Córdoba, y yo les digo, bueno, ¿qué tenemos que hacer? Tenemos que hacer un programa. Nos ponemos a codear la pantalla que permite escribir el destinatario. Olvídense de los arrobas y toda esa parte. O supongásele que creamos un mail que se puede escribir por el nombre y todo. Nada más que siempre hay que ponerle apellido a la provincia. Decir, mira, esto es para Diego de Mendoza. ¿Qué deberíamos resolver desde la aplicación para que el mail que yo escribo acá termine de Mendoza a Córdoba? Piensen en ese programa. No sé si se entiende la pregunta. ¿Aló? Si la pueden volver a hacer, mejor. Yo les digo, miren muchachos, tenemos una computadora que está acá y tenemos una punto a punto en Córdoba. Y tenemos acá otra punto a punto en San Juan y otra punto a punto a San Luis. Queremos hacer que se puedan mandar mails a personas de Córdoba, de San Luis o de San Juan. O que se pueda armar una videoconferencia, ¿no? Para ayornar un poquitito. Lo que les quiero tratar de hacer es, por un instante, piensen en la aplicación, en el programa que tienen que hacer. Ustedes dirán, bueno, mirá, tenemos que hacer un programa que tenga una pantalla que vos podés escribir. En un lado aquí va el mail y después el texto, el mensaje. Ahora, ese programa, vos decís, mirá, esto va a Diego en San Juan. ¿Qué tiene que hacer el programa? Saber quién es Diego. Pues si no, no se lo pueden enviar. Nos pusimos de acuerdo, dijimos que el protocolo dice que se pone así el nombre en la provincia. Entonces ya sabemos que "en" es la computadora que está en San Juan o la que está en Córdoba, o en San Luis o en Mendoza. Entonces si yo arriba pongo "Diego en San Juan" va a la computadora que está en San Juan. Ahora, yo le digo, ¿qué hace ese programa? Esa sería la forma de rutear el correo. ¿Cuántas computadoras hay? Cuatro. Una acá, una en San Juan, una en San Luis. Tiene que armarlo de alguna forma para mandárselo al transporte. Bien, entonces ya nos paramos. Tenemos que agarrar esto y decir, esto es un mail. Entonces vos decís, mirá, lo que escribió el flaco, aparte de lo que escribió, tiene a quién va, porque cuando llega a la computadora allá, no solamente está Diego, está Juanjo, está Pedro, está Luis. Así que la aplicación tiene distintas casillas. Yo no puedo perder a quién va el correo. Entonces tengo el correo, después tengo la cabecera del correo. Pero eso lo voy a tener que decidir enviar a la computadora de San Juan. Entonces vos decís, che, tengo que tener una manera de identificar a la de San Juan, que es distinta a la de San Rafael. Y porque aparte, cuando lo vaya a mandar, lo tengo que mandar por cable separado, ¿no? Tengo una punto a punto a San Juan, una a San Luis y otra a la que tengo acá en Mendoza. ¿Se entiende eso? Quiero que piensen en el problema de la aplicación y la conectividad. ¿Se entiende o no se entiende? Sí, sí, sí. Bien. Imagínense que lo resolvemos. Vos decís, ah no, mirá, como decía, en San Juan vos podés decir, che, mirá, el cable que va a San Juan, el cable que va a San Luis. Entonces cuando tomás del mail, si dice en San Juan, elegís que se vaya por el cable este. ¿Sí? Entonces como es una punto a punto, vos lo escribís del otro lado hasta el otro flaco y lo levantas. Imagínense o créanme por un instante que eso es así. Entonces ustedes tienen que hacer el programa que corre en este lado y el programa que está del otro lado, ocurriendo o no. Porque el otro programa que tienen que estar mirando, el que está, imagínense, en San Luis. Es un programa que ¿qué está mirando? A ver si hay algún correo. Está mirando por la punto a punto, a ver si aparecen bytes. ¿O no? Sí. Ah, está escuchando. Está mirando, sí, che, está mirando. Ah, acá vienen bytes. Empieza, rrrrr, salieron un montón de bytes y lo mira. Dice, ah, esto es, lo primero que dice es que es un mail. Ok, es un mail. ¿Sí? Y después dice, ah, este es para Juan. Ok, Juan. Y esto es lo que dice. Entonces voy a agarrar y lo voy a escribir en un disco. Y voy a poner en la carpeta Juan, esto que viene acá adentro. Imagínense que hacemos ese programa, ¿no? Me creen que es así porque hay que hacer un programa o no. Bueno, esto anda bien. Lo hacemos, hacemos el que escucha, hacemos el que manda, todo bien. Mañana Juanjo dice, che, anda muy jamón esto. El programa es un programa, ok. Lo hicieron en un lenguaje, no sé. Lo programaron en un lenguaje que le guste. ¿Lo hicieron en qué? Lenguaje que les guste, me van a decir PHP. Python, no sé. Con L. Lo hicieron en Python. Entonces hicieron un programa precioso. Mirá, el programa tiene la función que dice mandar correo. Que hace todo el laburo este de que agarra el correo, lo mira, mira por qué, mira por qué cable va. Porque hay que decidirlo adentro del programa o no. Sí. O sea. En la función mandar correo. Y después está la función que dice recibir correo que hace lo mismo. Mira por qué cable vino. Eh. Ok. Mañana Juanjo dice, che, anda jamón esto, mandemos archivo. Que no son los mismos que correo. ¿Qué hay que hacer? Modificar la aplicación de vuelta para que pueda mandar archivo. ¿Qué parte hay que modificar? La del envío de trámites. Pero si hicimos una función que era mandar correo. Claro. Y habría que hacer otra función nueva. La parte que dice que en vez de ser un correo que diga que es un archivo. Es decir que ahora hay que decir, no, pará, pará. Hay que hacer mandar correo y dejála, mandar correo. Hay que hacer mandar archivo ahora. Sí. ¿Y cómo vamos a hacer con el cable, que mire el cable? Y recibir archivo. Pero ¿cómo sabes si es archivo o correo? Cuando le llegue a que si es un archivo haga tal cosa. ¿En dónde llega? Por el medio. Mira el medio. Salen los bytes. Salen bytes. Salen bytes, salen bytes. Entonces tenés que mirar. Hay que mirar los primeros bytes. Y decir, ah, si es correo hay que llamar a recibir correo. Pero si es esa función la habíamos metido en recibir correo nosotros antes. Sí. ¿A dónde hay que ponerla ahora? Bueno, ahora hay que modificar todo. Hay que hacer algunas cosas iguales. ¿Ah? ¿Qué habría que hacer? Algunas cosas van a ser iguales, pero va a cambiar. Que en vez de recibir un mail, sepa que va a recibir un archivo. Ok. Si no, podría ser... ¿Podrían reutilizar esas? Claro. De última, hacer una general y que depende de si es un archivo o un mail, ahí haga dentro de eso lo que tenga que ser. Hacer una función que detecte el tipo de archivo. Bueno, eso ya es un problema de la aplicación. Pero tenemos un problema en los paquetes. Podés decir, mira, ¿esto es archivo o es mail? Depende de qué sea la función de la aplicación que voy a llamar. ¿Sí? No importa si el archivo es una foto o lo que sea. Puede ser un refinamiento de la función recibir archivo. Lo que les quiero decir es que si lo piensan como se lo estoy tratando de decir, que es como deberíamos pensar, ¿qué son esas funciones agrupadas en tareas que hacen cosas comunes? Y si miran este dibujo... Un capa. Por eso lo hicieron así los flacos. Estaban programando las aplicaciones. Dijeron, tenemos que hacer una web que sirva... Eran desarrolladores. Lean el libro de Internet Core Protocols, que es muy interesante. Ustedes van a ver que... Y esto es lo que quiero que piensen. Primero, el mundo lo manda a la capa 8. Es decir, lo mandan los requerimientos de la gente que quiere usar las cosas. Y después aparecen las aplicaciones para hacer lo que la gente quiere. Y las aplicaciones, la abstracción del software, produce los frameworks y produce las capas. Entonces los protocolos se dividieron en capas porque es evidente a nivel de software, fundamentalmente, que es común lo que hace cada capa, ¿para qué hacerlo adentro de cada aplicación? Porque es inmantenible. Y a su vez, el mismo esfoque de abstracción de complejidad que cuando desarrollamos. Siempre que desarrollamos, vieron que lo que nos pasa apenas es decir, "Uy, chisto, ya lo hice en una función, podría hacerme una funcioncita". No sé si piensan ustedes así, pero creo que más o menos todos estamos seteados de la misma manera. "Chisto, esto ya lo programé para la otra cosa, podría generalizarlo y hacerme una clase que haga esto, y esta otra clase hereda de esta, y en realidad reutilizo y no tengo que mantener dos clases". Porque, imagínense esta lógica de direccionamiento que yo acá la hice muy naif en nombres de provincia, en el fondo son las IP. Lo que básicamente permitió rutear hacia un lugar u otro era el nombre de la computadora, por decirlo de alguna manera. Eso no va a cambiar si hacemos bioconferencia o si hacemos envío de archivos, o si estamos moviendo cosas de un dispositivo a otro. Entonces, "Mirá, esto va a ser así". Lo que sí va a cambiar es que puede ser que hay flacos que están uno al lado del otro, entonces no hace falta irse por los cables, va a haber que rutear. Entonces cambiamos los problemas. Y es por eso que esto, hecho así, es previo a este modelo que está a la izquierda. De hecho, existió el protocolo IP y no existía aún TCP y UDP como lo conocemos. Se fueron abstrayendo en el tiempo. No sé si me explico. No se llamaron inicialmente TCP, así como lo conocemos. Se fue abstrayendo, me refiero al proceso de abstracción, así que "Mirá, esto es muy común, ya los problemas se empezaron a poner más picantes". Y bueno, no me cae bien que yo mande un mail y se caigan dos letras en la mitad. Necesito saber que llegó todo lo que escribí. Por eso, che, necesito un transporte. Y ya no es lo mismo que... Si yo tengo que hacer que la aplicación se encargue... O yo les pregunto, ¿ustedes creen que el navegador de ustedes se encarga de mirar que la imagen que mandó la nación llegó entera? No. ¿Quién se encarga de hacer que si un pedacito la imagen explotó? Porque estoy en un Wi-Fi con muy mala señal, alguien lo pida de nuevo. El capa de abajo. Por eso existen los transportes, digamos. Los transportes son los músculos, realmente, que hacen el transporte de la información. Y es un problema en sí mismo. Si no lo meto ahí, se lo tengo que encargar a todas las aplicaciones. Porque no hay poca... Es decir, esta videoconferencia, "ustedes son UDP". Bueno, en realidad, fíjense que acá es un claro ejemplo de que hay alguien que está o dispuesto a perder un poco de información, o si va a usar UDP, que es un transporte que dice, "bueno, mirá, yo muevo de acá para allá". Si viene y no viene, bueno, no es mi problema. Bueno, si eso no lo va a hacer el transporte, lo voy a tener que hacer yo en la aplicación. Si es que me interesa que no se pierda información de ningún tipo. Bueno, lo más importante que me gustaría que nos quede, y ahora ya nos vamos a meter bien con el protocolo, es, piensen como les dije recién, de acá en más en general, piensen cómo lo harían ustedes, o cómo lo hubieran hecho ustedes. Piensen como desarrolladores, porque todos son problemas de desarrollo en el fondo. Entonces, los fundadores del Internet y los pioneros, estaban construyendo aplicaciones. No estaban construyendo aplicaciones, estaban subsidiados por programas de la Agencia de Defensa de Estados Unidos para construir una red de computadora que manejaba cosas de defensa y que necesitaba cierta capacidad de rutear la información de un lado al otro, pero la información era en aplicaciones, arriba de eso. La razón por la que tenemos el protocolo mínimamente dividido es, nosotros muchas veces hablamos de que son en el fondo cuatro capas, aplicación, transporte, red y acceso al medio y físico. No hay más capas en TCP y IP. Acá tenemos algunos protocolos que vamos a ver después, que viajan arriba de IP, pero ayudan a IP, son raros, no es raro. Están en un plano de trabajo distinto. ¿Alguien conoce un protocolo que no sea transporte? Lo vimos el otro día que lo tuvimos que habilitar para poder ver si las máquinas llegaban o no. ¿Se acuerdan? ¿El ICMP? El protocolo de control, que también lo vamos a ver. ¿Es un transporte ICMP? ¿Se puede transportar mail por ICMP? ¿Para qué lo usamos, por ejemplo? ¿Para qué lo usamos el otro día? ¿Qué hicimos? Es de red. Y si yo lo pongo acá, es un protocolo de red. ¿Y en qué viaja? ¿En qué viajan los paquetes ICMP? IP, B4. En IP. Entonces, si viajan en IP, no están en el nivel de IP. Claro, tienen que ir más arriba. Pero no son transporte. ¿Se entiende eso? Es así, la verdad que es así. No lo podría dibujar. Acá está el transporte ICMP. Sí, es extraño porque en realidad son como dos hechos distintos. ICMP está, yo lo suelo decir así, semánticamente al lado de IP, o en la misma capa, porque es un protocolo helper de IP, es de ayuda de IP. IP se quiere, usa como mano derecha ICMP para corregir algunos comportamientos, dado que, dado el axioma que tiene IP, de ser súper simple. Entonces, hay algunos comportamientos de red, necesita alguien que le diga al oído, che, no, mira, la verdad que esto no está andando muy bien, y IP se adapte a eso. Es como un helper de IP. Entonces, está como integrado semánticamente en la misma capa, es capa 3. Pero está sintácticamente arriba de IP. ¿Qué digo con sintácticamente? Se escribe igual que si escribiera un protocolo de transporte, sin ser un protocolo de transporte. Es decir, es carga de IP, es payload de IP, pero semánticamente es parte integral de IP. Eso es lo extraño que tiene ICMP. Bueno, la idea era hacerle esta primera avant-première de nuestros protocolos, y este masaqueo, si le tuviera que resumir, es, hay muchas cosas que a nosotros nos gusta ver en nuestros protocolos, desde el punto de vista de la ingeniería, es aprendan de los desafíos de ingeniería, y cómo estos patrones de diseño que aplicaron para diseñar estas cosas, son aplicables a muchos problemas que van a ver después. Entonces, si ustedes se encuentran con algo nuevo, van a ver que hay muchísimas decisiones de diseño de ingeniería, que son renaturales, con el diario del lunes. Pero 40 años atrás, no era tan obvio decidir un montón de cosas que son criterios de ingeniería decididos como haberlos hecho. Como este, decir "che, mirá, vamos a separar, que la red se vea igual, porque no sabemos ni en qué medios van a funcionar, a los medios de transmisión, que hagan lo que quieran". A mí con que esto lleve cosas de IP, de acá, y de hecho, de acá para nosotros, en esta materia, nosotros vemos cosas que llevan datagramas IP, que es como les vamos a llamar, de un lado a otro. Cómo hacen para abajo, es tema que han visto en un montón de otras materias ustedes. En redes de área local, en comunicaciones de datos, exhaustivamente analizado, o han visto, el suficiente detalle de cómo se hacen en esas cosas. Para nosotros, y de hecho, un poco el desafío nuestro va a ser, lograr que ustedes comprendan en esta materia, cómo funciona la Internet completa. Nos vamos a proponer entender cómo funciona la Internet completa. Y cómo hace para que funcione un paquete que va de acá a China, pero bueno, vamos a hablar de IP, no vamos a ver "che, ah, no, se metió por un cable submarino, salió por una antena satelital, bajó en un barco, rebotó en un satélite", bueno, no vamos a ver eso. El objetivo de esta materia es, ustedes tienen que entender cómo funciona la Internet real completa en IPv4 y en 6. Esa ha sido un poco nuestra misión. Bien. Si querés te doy un poco, bueno, para resumir, antes, y ya le voy a dar la palabra acá a mi colega, que lo hace mejor, es súper importante que ustedes entiendan, sobre todo a mí me parece esta parte que está acá, que habla de los servicios. El protocolo IP, si lo pensamos como capas, que es un poco lo que estábamos hablando recién, tiene estas misiones. Primero, una cosa que es súper, bueno, ya dijimos, es algo que está moviendo datagramas y es algo que no está orientado a conexión, ya vamos a hablar un poquito más. El protocolo IP me ofrece una entrega que se llama "Best effort", es decir, va a ser el mejor esfuerzo por llevarme un datagrama de origen a destino. ¿Qué le cuesta asegurarmelo? ¿Por qué mejor esfuerzo? Bueno, pero y luego... ¿Podría haberse esforzado un poquito más? ¿Hacer la cosa bien? ¿Qué piensan que es "Best effort"? ¿A qué les late, digamos? ¿A capas de transporte? Bueno, no, pero ya estamos hablando de la red. ¿Capa en capa de red? La capa de red... ¿Qué es lo mejor esfuerzo que es? Es hacer todo lo posible, lo que esté a su alcance, pero no te asegura, porque capaz que en otras capas hay un problema y no llega. Ya no depende de él. Hacer todo el esfuerzo posible, pero si no llega no te asegura nada. Pobrezón, ¿no? ¿Qué le hubiera costado hacer el esfuerzo y garantizar la entrega? ¿Por qué me lo dejan ahí a un pasito, diciendo "¡Y casi te la entrego!"? "Y bueno, casi, sí, bueno, qué sé yo". Tratamos. Garantizar la entrega... Hay que hacer un montón de cosas más. Ok, ¿y qué es así a grandes rasgos? Un montón de cosas más. Y la persona a la que le estés mandando tiene que contestarte si recibió o no. Bien. Y yo, como enviador, fundamentalmente, ¿qué hago con ese datagrama? Hasta que me confirmen la f*cking entrega. Y deberías tirar. ¿Puedo tirar la basura? No. Ok. Quiere decir que yo, como intermediario, piensen en... No hemos hablado de routers todavía, pero todos conocemos que existen estos dispositivos de red en el medio, ¿no? Yo sé que si accedo a un servidor de Netflix no lo tengo acá atrás del router del AP de mi casa, sino que hay varios dispositivos de intermediarios routers que leen solo esa capa, la capa 3, la capa de red. Si le pidiéramos a todos y cada uno de ellos, podría ser distinto, pero pensémoslo así que es más interesante, a todos y cada uno de ellos que aseguren la entrega, ¿qué deberían hacer ellos cuando dicen "ah, bueno, se lo paso al próximo en la cadena, pero tengo que asegurar la entrega, por lo tanto, este datagrama, ¿qué tengo que hacer?" Lo tiene que guardar. Al vacionarlo, ok. ¿Y qué tal si yo tengo un RAID típico, a ver, sin ser un router de locos, 10.000 datagramas por segundo, un router de... ni siquiera estamos hablando de core. Un router de un ISP normal puede estar en ese orden. Y se va a saturar. Digámoslo del otro día, ¿cómo lo tendría que dimensionar? ¿Cuánta memoria necesitaría si quiero almacenar, pone, por decir números, dos segundos de tráfico? Esto, nota al pie. Nos gusta mucho con Diego, parece off topic, pero nos gusta mucho con Diego apelar a dimensiones, apelar a... ¿cómo es la palabra? A aproximaciones de números como para tener una idea, ¿no? Yo dije 10.000 paquetes por segundo. ¿Cuánto mide más o menos un paquete? Redondémoslo. Un mega, 100 bytes. No recuerdo el límite. No, no, pero no el límite. ¿Cuánto mide normalmente? ¿Cuánto calculan que es un paquete IP? Hace falta justo, pero el orden de magnitud. Es 100, es 1000, es un mega en bytes, ¿no? Creo 24. ¿24 qué? No cabe cera, ¿cuánto carga? Si mostrás, incluso te lo podemos tirar más abajo, una trama de internet. No, bueno, pará, pará, pará, pero si saben, eso, claro, una trama de internet. ¿Cuánto entra? Ahí está. Eso es un número que han visto un montón de veces. Sí, es que no lo recuerdo, no lo quiero decir mal. ¿Qué eran, qué, 500 bytes fue eso? Un poquito más. ¿500? Ah, mil, mil. Redondimos mil, sí, un número redondito, un kilobyte. Yo les dije, es un dato, en realidad, un router yo diría de medio para abajo, 10.000 paquetes por segundo. Si quiero almacenar un segundo, ¿cuánto necesito de memoria? 10.000 por el kilobyte de-- ¿Eso cuánto me da? 10.000. 10.000 kilobytes. No, pero eso es 10.000 por cuánto? Por mil, o sea, por un kilobyte, 10.000 kilobytes. Por mil, por eso. Y 10 megas. 10 megas. Y 10 mega, mega, ¿qué? Bytes. Megabytes. Por cada placa más o menos estamos redondeando. Pero si quiero varios segundos, voy a tener que estar en orden, ponerle de los 100 megabytes, que por ahí no puede sonar, quizás no puede sonar mucho hoy, pero estamos hablando de memoria que tiene que ser súper rápida de acceso, en la cual yo la pueda pedir, administrar rapidísimo. Y esto distribuir en los dispositivos de toda la red. Nuevamente, hoy 2021, 100 megabytes suenan de taquito. Pero, bueno, haciendo un poco de rollback, la clave es el problema de memorizar. Justamente lo importante que trae IP, podemos poner-- No, quería ponerte-- Te iba a mostrar la memoria, pero-- No, dale, perdón. ¿Qué tema-- No. Ah, bueno, dale, si querés. No, iba a mostrarte la memoria del router, pero ya está. Dale. No. Ah, OK. A ver si podía entrar el router de mi casa. No me acuerdo la clave. [RISA] A ver si tengo-- [HABLANDO INGLÉS] Ya me voy a ir a otro net. Ah, sí, ya está. [HABLANDO INGLÉS] Acá hay uno. Un router. Un router OpenRT. Regordo. Vos sos un tipo rico en memoria, 64 megabytes. No, no, pero como para que hagas la lógica, él está hablando de un segundo de información. ¿Sí? 10 mega, ¿OK? Y acá viene el problema. ¿Qué pasa cuando las cosas no andan bien? ¿Qué va a pasar cuando esto no ande bien? Estamos yendo al razonamiento de qué malo que es IP que no me da entrega garantizada. Estamos yendo al razonamiento de dame entrega garantizada. ¿Y qué significaría en su ingeniería que me pida entrega garantizada? Y después, como bien lo llevaba Juanjo, ¿quién es? ¿Qué routers tienen que hacer eso? ¿Solo el mío? Todos los que están en el caminito. Todos los que están en el caminito. Imagínense los gigabyte por segundo que se mueven. Un segundo, además, que tenga que almacenar toda la red en un determinado spot que se ponga colorado como un tomate porque se te ha caído el enlace que sigue. ¿Y qué va a pasar cuando ese enlace se recupera? Todo esto lo tenía memorizado, lo que estaba en la punta. Hay link de vuelta. Como un huevo de la tendria. Saturo de vuelta y capaz que tengo que, como hay saturación, hay colisión, tengo que almacenar de vuelta. Y hay link de vuelta. Entonces, ¿a qué vamos con esto? Lo de Vs4 tiene una razón fundamental que es la misión de cada intermediario que levante y sigue el paquete, esto que vamos a ver, que llamamos routers de red, es intento tirárselo al próximo destino, que ese próximo destino puede ser un par mío o puede ser el host final. Intento y si no puedo, sorry, lo tiro y me olvido. Hago el mejor intento, trato de ubicar, trato, hago, obviamente, hago el tener el problema del acceso al medio para poder meter que eso se materialice en una trama y que siga su camino. No voy a tirarlo porque sí, pero si no pude, lo tiro. Porque asumo que algún, si esto es importante, algún otro capaz de transporte, se hará cargo de reenviarlo. Mi misión era hacer el mejor esfuerzo por tratar de pasar todos estos saltitos. Capa 3, capa 2, 3, 2, viaja en link, 3, sube. Lo vamos routeando, lo vamos encaminando hacia destino, se lo dejo a destino. Acá hago un mejor esfuerzo. Pero si algo estaba cortadito por acá, yo no lo almaceno. Listo. Se cortó, bueno, lo sumo, reporto. Y CMP. Al sumo le digo al origen, mirá, tengo problemas en este próximo salto. Vos estás queriendo llegar allá y yo te digo que tengo problemas acá. Hacé lo que vos quieras. Pero yo no me voy a poner a almacenar todos estos datagramas, sencillamente porque justamente por diseño es el mejor esfuerzo. La fundamental razón es lo que dice en el item 3 ahí, que es un núcleo simple y stateless. Nota al pie, eso es algo que nosotros vamos a insistir mucho también, el concepto de stateless y stateful. Alguien me lo puede decir rápidamente, puede ser muy simple o muy complejo de acuerdo al ángulo con que lo veamos a stateless o stateful. Si alguien me lo puede resumir simplemente, que es algo stateless y algo stateful. En general. No, no necesariamente protocolos. Bueno, cuando es stateless, lo que se hace es que ninguna de las 2 partes-- Bueno, en realidad sí. El router, en este caso, no tendría conocimiento del estado, no almacenaría información sobre las personas, digamos, las computadoras que se conecten a él. Y en este caso, por ejemplo, las computadoras deberían recordar el estado. No sé si lo compliqué mucho. Está bien, vas bien encaminado. Va a haber un caminar. Pero stateless es, está ocurriendo algún evento y terminó ese evento, yo me olvido o me acuerdo de que eso terminó. Es necesario para que todo esto ande, que yo memorice el estado y decir, ah, yo vi pasar de acá hasta allá, por lo tanto, tengo que recordar eso porque la próxima que pase o yo complico mi misión, hice esto y listo. Listo, no sé qué pasó. Bien, la próxima lo hago y me olvido. No, no. todo para nosotros es muy importante la ingeniería stateless versus la ingeniería stateful, es decir, que ustedes usen la cabeza todos los problemas pueden parecir que requieren cosas de stateful, pero en informática y en computación sobre todo cuando ponemos la palabra stateful es como burocracia y esa burocracia requiere edificio, requiere infraestructura, es decir, cuando usted dice bueno nosotros vamos a revisar, vamos a analizar todos los paquetes, si vos vas a analizar me estás diciendo que hay que guardarlo, si hay que guardarlo hay que ponerle memoria, si hay que hacerlo rápido hay que ponerle más cpu y entonces ustedes se van a encontrar y también es un poco la misión nuestra con enfoque ingeniería que las cosas que escalan obviamente va a haber problemas que requieran y si mira esto por ejemplo, che mira yo quiero guardar las fotos para poder verla dentro de unos años y bueno eso es stateful, es decir, hay que ponerle disco, hay que ponerle y si guardas más fotos hay que poner más disco y es la tarea que hay que hacer, entonces hay problemas que requieren de soluciones basadas en estado, pero hay muchos problemas que si yo uso bien la cabeza son stateless y escalan hasta el infinito como este, este problema de nuevo piensen nosotros estamos diciendo 10 megas en el 2021, eso se escribió en el 75, las computadoras tenían k de memoria, no tenían megas de memoria, bueno nosotros somos bastante más grandes que ustedes, vimos muchas computadoras con k de memoria, no con megas, entonces la decisión inteligente de esta gente fue vamos a construir una tecnología de red que sabemos y esto es lo brillante, que la infraestructura que esté al medio no va a cambiar, no va a ser fácil cambiarla todo el tiempo, no es fácil cambiar todos los routers de borde y los enlaces internacionales submarinos de la internet y de hecho esa tecnología, ustedes lo van a ver en sus casas, no va a evolucionar a la velocidad que van a evolucionar los dispositivos que están en las puntas, una cosa sencilla, cuántas veces cambiaron el teléfono de ustedes en los últimos cinco años, un promedio díganme, una, una, seguro, tienen el mismo celular que hace cinco años, todos tienen el mismo celular, o sea en cinco años lo cambió una vez, claro, por eso si que lo han cambiado dos veces, tienen dos celulares cada cinco años, yo creo que un poquito más, cuántas veces cambiaron el router de su casa, infinitamente, porque se me caía siempre, y yo también, bueno tenían un router malo digamos, y si, me cambié de empresa y me dieron uno nuevo, bueno bueno, por ahí no es la mejor, vamos a otro escenario, cuántos dispositivos sumaron ustedes a la red y cuántos en proporción a los que cambiaron el router, ustedes pensaron que, ah no, voy a poner dos teles más, voy a poner el ipad, voy a poner las compu, y cambiaron el router o no lo cambiaron? No, a lo que va es que perduró más el tiempo. No, lo que les quiero decir es que la infraestructura de la red es mucho más estática que los bordes de la red, que es lo que los tipos pensaron, quién tiene el stack completo de TCP y IP, dónde está la capa 8, atrás de dónde? De la pantalla de la aplicación, de los dispositivos. Sí, ok, es decir que la capa 8 usa el dispositivo más inteligente, de lo que acabamos de ver, es decir, una red tiene un router con 128 megas y el celular tiene gigas de ram, o no? Si yo tengo gigas de ram y tengo 6 cores, me sobra para implementar en ese aparato toda la corrección de errores, la compresión de errores, la compresión de protocolo de transmisión, porque tengo el cómputo en ese aparato. Entonces, la ingeniería de esto fue, nosotros vamos a hacer una red lo más asética o lo más minimalista posible, con las funciones de, che, datagrama chup para allá, datagrama para allá, chau. De hecho, cada vez que alguien propone cosas que sobrecarga la red, van a ver que no tiene prácticamente aceptación. El protocolo IPv6 es más liviano de trabajo que el IPv4 en el core de la red. Y nos va a permitir conectar en potencias, no sé cómo se los podría dibujar, pero imagínense que la tierra, un grano de arena de la tierra es un IPv6 para darle a cada dispositivo entero, hoy va a tener, le podríamos poner IP a cada grano de arena de la tierra, para tener una granularidad de la cantidad de dirección IP. Y eso se haría con la misma ingeniería de red que hubiera usado IPv4, que de casualidad no podría tener todos los granos un IP. Entonces, acá, de nuevo, hay una decisión de ingeniería, y hay muchos protocolos que fallaron acá, por ejemplo, cuando hablábamos la semana pasada, había familias de protocolo que pretendían, y otra cosa que fue brillante, la suposición de, de nuevo, ¿cuántas veces creen que hay un error que se pierde en una fibra óptica, un paquete? ¿Ustedes han visto alguna vez el orden de problemas que tiene eso? Es pequeño, pero no me acuerdo el número. Parecen brujos, son ingenieros ustedes. ¿Alguien tiene un orden de la tasa de error de una fibra óptica, más o menos, en qué orden está? ¿Día la -21 era? ¿Cuánto? Día la -21. Sí, parece que es demasiado, pero... Día la -9 seguro, es decir, es un 0,000000001. Es decir, ¿para qué me voy a ponerse un protocolo que tiene una tasa de que, día la -9 veces, aparece un problema? ¿Para qué voy a estar chequeando todos los paquetes si en realidad la tasa de ocurrencia es esa de baja? No sé si se entiende. Sí, sí, sí. Entonces, acá hay una decisión de nuevo, de ingeniería es, y también es parte de como muchas veces, y queremos que piensen, si ustedes están construyendo infraestructura de algo, traten de imaginar siempre cosas que sean stateless y donde los dispositivos que más pueden estar rotando en ese ecosistema de ingeniería sean los que caren con el mayor carga de desarrollo, o de cómputo, o de almacenamiento. Y escapenle a todo lo que requiera almacenamiento, porque no es caro en ingeniería. Una de las propiedades que tiene ser stateless es que es replicable, reemplazable, porque puedo matar al otro que estaba a cargo, o reemplazarlo, o ser un clon del otro que estaba a cargo, porque como no tenemos que almacenar nada, en realidad cualquiera de los dos podemos hacer la misma tarea, cualquiera de los dos, de los 10, de los 100, de los 1000, porque no hay algo en particular que él sabe que yo tenga que saber cuando venga de vuelta otro paquete, cuando vuelta otra conexión, cuando vuelta otro problema, "uh, no, pero eso lo había, el número 2 lo sabía, yo soy el número 5, uh, acá qué quilombo se hago", pero si todos somos stateless, en realidad, y tenemos implementado nada más que el algoritmo si se quiere, pero no la memoria que hace ser stateful, todos podemos colaborar simultáneamente para resolver un problema. De hecho podría tener una raya de routers que alternativamente, que tengan si quieren, tómenlo con pinza, ¿no? Más o menos la misma configuración, y en realidad los paquetes pueden fluir por uno o por otro, porque no es que "ah, no, todo aquel paquete que pasó, los que vienen atrás, que pasaron por router 1, tienen que volver a pasar por router 1, sino acá se armó el grande pelote". Entonces, eso es importante, ser stateless me da replicabilidad, porque justamente puedo destruir replicabilidad, reemplazabilidad, sin tener que "uh, se quemó, sonamos". ¿Qué tenía almacenado? No, lo puedo reemplazar instantáneamente. En el caso de la red, otra de las consecuencias que tiene, si esto fuera stateful y almacenara, es latencia. ¿Por qué? Porque si hay almacén, hay lista de cosas por salir, y si estaba cargada la red y no la podía transmitir, tiene que retransmitir, tiene que pasar todos estos paquetes antes de que vengan los que están llegando ahora. Y eso es latencia en el medio, entonces. Son varios los aspectos que hacen que vS4 fuera la mejor idea, porque nuevamente, y cerramos la idea de vS4 aplicado de IP, es, yo como router, mi problema es este datagrama. La unidad de problema es este datagrama. Y específicamente pongo la lupa en dirección destino. Mi misión como router en la red es observar la dirección destino y empujar este datagrama para que llegue a destino. Fin de mis servicios. Viene el otro datagrama y de vuelta. Mi unidad de problema es nada más que el datagrama. No es la secuencia, no es "uh, ya te vi pasar, ya tengo que" no, no, no. Levanto un datagrama, miro la dirección IP destino, hago que salga por la placa correcta hacia el destino correcto, y vuelvo a levantar otro, ¿sí? Y esa es mi misión. Y sea chica y es esa nada más. Eso es súper, súper importante. Bueno, nos extendimos, pero, de nuevo, si los torturamos es porque nos parece valioso el estudio del protocolo por los problemas de ingeniería. Está claro que, bueno, entonces, primer servicio es que yo voy a hacer lo mejor posible para encaminar lo que vos me diste al destino. La otra misión, que no es poca, es la del direccionamiento lógico, que es lo que yo les decía, la abstracción de la capa física de red. IP es el responsable de crear un mecanismo, que es el que vamos a tratar de, del que vamos a hacer algunos ejercicios ahora, que me permita a mí identificar quién es cada uno de los miembros de una red, e incluso con ese mismo mecanismo poder saber quiénes no son miembros, por lo tanto, originar una decisión de ruteo, como es la que acabamos de decir recién. Entonces, la misión es la abstracción de la capa de física a través de una provisión de un mecanismo de direccionamiento lógico. Es como que el direccionamiento justamente físico, lo que llamamos comúnmente MACS, están desacoplados de una decisión lógica, humana, humana automatizada, pero en infinitud humana, de decir, bueno, todos los que van a, todos los nodos IP, que van a estar en esta red IP, van a ser 192, 168, 1, algo. Eso alguien lo decidió y alguien va a hacer que eso ocurra, pero no va a estar atado a que, ah, no, mirá, la MAC esta que tiene este prefijo no puede andar acá, porque solamente para que se vea, no, no, no. Está desacoplado el direccionamiento físico, el direccionamiento lógico, que es lo que estamos diciendo acá. Me ha parecido un beneito. Bueno, hacemos rapidito esta diapositiva y vamos a un recreo. Completamos el diapositiva, ya hemos hablado bastante, en el momento hop by hop un poco lo mencionamos recién, que es, también es otro aspecto interesante. Cuando un datagrama se construye, ¿quién construye un datagrama? Un router, ¿no? El primer datagrama que inicia todo el problema, lo construye un router. [AUDIO EN BLANCO] [AUDIO EN BLANCO] ¿Vamos? Sí. Sí, creería que sí. ¿Los routers inician conexiones? No, no está el computador, no está aquí. OK. Entonces, nosotros que tenemos que transferir todo este archivo, por ejemplo, una imagen ISO de 600 gigas, para poder transferirla, yo voy a empezar a generar datagramas y lo voy a meter en la red para transferirlo a otro lado. Entonces, yo creo ese primer datagrama. Encaminamiento hop by hop significa que ese primer datagrama se crea. En realidad, vamos a ver qué tiene, la dirección de origen, que es la mía, la dirección destino a donde llega, y pobrecito, sale así de desnudo al mundo. Se lo tiro al próximo router y es un problema del router que viene, ¿cómo lo vas a ir pasando? No es que yo, como construidor de ese primer datagrama, tengo que rascarme la cabeza y encontrar y cargarlo con todo el mapita de por dónde tiene que ir. Sale y yo le digo, pum. Básicamente, sacármelo de encima. Yo como host, vos que sos mi primer router, es tu problema ahora, macho. Y el primer router, ¿qué hará? Dirá, ah, bueno, va a tal destino, imaginá que tiene varios enlaces de ese router, varias placas con varias conexiones a distintos routers, verá cuál es el mejor para salir y dice, ah, bueno, problema del router que viene, pum, se lo tira al router que viene. ¿Listo? Pero la clave es que cuando arrancó ese datagrama, no sabía qué camino, nunca va a saber qué camino sigue. De hecho, cada router tampoco va a saber el camino completo que va a seguir al destino. En principio. Básicamente, el problema de cada router es a quién le tiro la pelota para que siga, para que acerque ese datagrama a destino final. Por eso es encaminamiento hop by hop. Es como si yo saliera sin GPS, sin mapa, de un lugar, me voy de acá a... Me voy de acá a Buenos Aires, por ejemplo, y salgo, más o menos, le apunto, yo sé que está hacia el este, bueno, vamos hacia el este, y en cada bifurcación voy preguntando, che, para ir a Buenos Aires, ¿tengo que ir por acá o por acá? Anda por allá. Y listo, y voy hasta la próxima bifurcación y vuelvo a preguntar, che, ¿y cómo hago para llegar? Anda por esta otra. Ah, y va. Y entonces, la clave es esa, la clave es que la decisión de bifurcación, de por dónde voy, se va haciendo en cada una de esas bifurcaciones. No es que el paquete lleva cargado adentro la hoja de ruta. Eso es súper importante. El reenvío es justamente esto, es decir, la misión de estos intermediarios, que le llamamos router, es tomar un datagrama, analizar esto que estamos diciendo, leer la dirección de destino, y ahí reenvía su próximo par, router, o si es justo el último router antes del host destino, ya al host destino. Entonces, esta cuestión de leerlo y reenviarlo. Habíamos hablado, vamos a hablar mucho más en detalle, más adelante, que existe este protocolo que está pegado a IP, que se llama ICMP, y que sirve para estos casos. ICMP, en general, en general, lo habla la red. Como sabemos que la red es stateless, y no es que, esto no es así, lo que voy a decir ahora, yo que soy un host, que quiero un host, una máquina, mi laptop, un teléfono, que quiero abrir una conexión con mi navegador, una conexión web hacia aquel servidor destino, que lo he identificado con el nombre, lo que fuera. Yo lo abro, habíamos dicho que el paquete, en principio, en principio no sabe el camino, va a ir, y puede ser que en el medio del camino se encuentre con algún problema. Ese problema puede ser sencillamente que no tiene el vínculo, se ha caído, entre comillas, el internet, no que sea que haya caído el internet, pero se ha caído el vínculo que me permite llegar a ese destino. Ese intermediario, ese router que le ocurre que está en el medio de todos estos saltitos, tiene una manera de decirle al origen, a quien originó, a quien construyó el datagrama origen, decirle a la capa IP, a la capa de red, che, estoy teniendo problemas para llegar a ese destino. Este datagrama que vos construiste para llegar a ese destino, en realidad no está pudiendo llegar por esta razón. Y esa manera de informarlo, cómo se transporta ese helper de informaciones, es ICMP. Por eso es Control Message Protocol. Es un protocolo de control de la red. Lo que es loco es que viaja sobre IP mismo. Parece una cuestión medio de huevo y gallina, pero es así. Y es fundamentalmente hablado por la red. ¿Por qué? Porque cuando este host que está generando ese primer datagrama, no es que le pide a la red, che, me armás una conexión hasta el destino aquel. No, no es así. Sencillamente le tira el datagrama a la red, y allá va, pobrecito, el datagrama solito. Por eso, ICMP cumple esa misión de tener alguna manera de reportar, asíncronamente, si se quiere, problemas en la red. Esa es la misión principal. Hay otros usos, como el ping, que probamos el otro día, y demás. Pero ese es el uso principal. Permitirle a la red reportar de regreso algo, ya sea entre routers de la red, o reportar de regreso a quien consume la red, a quien usa la red, para mejorar el comportamiento de uso de esa red. Respecto a la escalabilidad, ¿qué querrá decir el diccionamiento jerárquico? ¿Qué le suena que puede ser el diccionamiento jerárquico? +54, 12 es 1, o 011, 012 es 1, o 011. ¿A qué le suena? ¿Por qué eso es jerárquico? Puede ser porque hay subredes dentro de otras redes. ¿Es una consecuencia? Es una consecuencia, sí, ciertamente una consecuencia. Pero si tomamos una, te doy una dirección IP, 200.1.2.3, y te dijera cuál tiene más peso, cuál expresa un conjunto de direcciones más grandes o más pequeños. Está muy relacionado con la máscara que habíamos hablado. Sí, hay redes que son más grandes que otras. 200.1.2.3, para vos, ¿cuál de los, el 3 o el 200 es más relevante o expresa un conjunto más grande de nodos de direcciones IP? ¿Cuál es el más grande? ¿Cuál es el más grande? ¿Cuál es el conjunto más grande de nodos de direcciones IP? El primero, el 200. El que está a la izquierda. Y 200.1 respecto de 200. Describe un conjunto de redes, pero más pequeño. Un conjunto, no de redes de máquinas, no sé si son redes, capaz que una sola red, medio difícil, un barril, un conjunto de nodos de direcciones. Y 200.1.2, cada vez más chiquito. Más estrecho. Y 200.1.2.3, exactamente una. A eso se refiere la jerarquía. La dirección IP tiene una construcción jerárquica y que es muy análoga a una dirección de teléfono. Telefono +54, ¿qué significa +54? Que es argentino. Ajá, ok. ¿Y 0261? Que es Mendoza. ¿350.1? Ciudad. No, 350.1 es Córdoba. Córdoba. +54, entonces ahí hay como una manera de... ¿Y para qué sirve esa jerarquía? Que está expresando... Para facilitar la búsqueda. Bien. ¿Y a su vez qué está expresando ahí, por ejemplo en los teléfonos? La pertenencia. ¿Dónde está ubicado? Claro, fíjense que... Piénsen en el destino de un +54, 351 y el destino de un +54, 12 y 1. ¿Dónde se encuentra el destino? Claro, de alguna manera en ese caso el direccionamiento está usándose para encaminar el destino final de la llamada. Claro, en el caso del celular, por ejemplo, si nosotros llamáramos a un 12 y 1, sabe que no tiene que salir desde la red de Mendoza, que se lo va a encontrar... El vecino. Si es 12 y 1 es como si fuera vecino. De hecho si no pongo nada y pongo 15 algo, va a salir por acá cerca. Es decir que eso es un esquema jerárquico, pero esa jerarquía está usada de alguna manera después, ya vamos a ver, sobre todo en el direccionamiento IP público, para encaminar a ciertos grupos de destino. Así que está usada en el ruteo, es súper importante eso. Profe, ¿es como para encaminar un paquete de redes más grande hacia más chicas, de izquierda a derecha, en la IP? Sí, de alguna manera sí, la verdad que no... El esquema de direccionamiento permite jerarquía y después de esa jerarquía podemos usarla para múltiple uso. Es así. Como bien le decía Juanjo, si yo te voy agregando bytes a la IP, te la voy circuncribiendo a menos destinos, de alguna manera. Pero sirve si entendemos que hay una analogía que es muy buena, la de los teléfonos con la de las direcciones IP, hay una analogía geográfica, ¿no? En IP no es completamente así, nosotros podemos asegurar que cierta IP es Mendoza, o podría estar en Mendoza y tener una IP que tiene nada que ver... ¿Todas las IP de Mendoza tienen algo en común? Por decirlo de alguna manera. ¿Todas las direcciones IP públicas de Mendoza a Argentina tienen algo en común? Tengo entendido que a Argentina se le dio un rango de direcciones IP y esas son... Claro, que haya alguna asignación inicial es más o menos así, pero la verdad que yo no podría asegurar geográficamente dónde se encuentra específicamente una IP por ver la IP. Ya vamos a estudiar cómo está claro, que de alguna manera está registrado a dónde tienen que ir terminando, y ahí es donde aparece la jerarquía. Pero no nos vamos a enroscar más ahora, pero es como para que vayan masajeando en la cabeza. ¿Querés que hagamos un break aquí y volvemos 7.30, les parece? O un poquito más. 7.30 está bárbaro, así no se nos va a estar tan largo tampoco. ¿Les parece muchachos? Vamos a cortar acá la grabación a la mitad, así no se nos va a estar tan largo. [AUDIO EN BLANCO]Bueno, retomando un poco lo que vimos en la clase anterior, la clase anterior estuvimos conversando sobre el algoritmo de ruteo de IP. Si refiriéramos a cómo nos tenemos que enfocar con el ruteo, o alguien me puede explicar, el ruteo está resuelto de punta a punta, digamos. Si cada vez que un host va a mandar un paquete, hace todo el camino hasta el destino y dice, bueno, tenés que ir por acá, por acá, por acá. Y si rutean origen, sería. O a base de otra forma. ¿Vamos? Nosotros, salto a salto. Claro. ¿Salto a salto qué vendría siendo? En cada router se fija a dónde ir con respecto al IP destino. Bien, ya empezamos a unir varias cosas. Primero, el ruteo es decisión de salto a salto. Cuando hablamos de salto a salto, estamos hablando en los sistemas intermediarios que son los routers. Después, otra cosa súper importante. El ruteo es una decisión del destino del paquete, no del origen del paquete. El algoritmo de ruteo IP no rutea por el origen. Eso es una cosa importante que ustedes sepan. Y después, está basado en información de cada salto. Entonces, ¿cómo se toma esa decisión? ¿En base a qué? Es decir, ¿a qué? Al algoritmo y a la tabla de ruteo. Bien, tabla de ruteo, dijimos. Esa información local que le permite al router decidir cuál va a ser el próximo salto que va a tomar es básicamente-- Está puesto acá en la pantalla, digamos. Mirar qué del paquete. ¿Cómo, profe? Perdón, ¿podría repetir? Bueno, yo soy el router 1 en este dibujo. Soy el router 1. Y me llega un paquete destinado a la 1.10. ¿Qué hago? Paso con respecto a la tabla de ruteo hacia donde se dirige. ¿A cuál? A ver, ¿dónde la miro? Miro en R1 en la tabla. Acá está la tabla de ruteo. ¿Y qué hago? Voy viendo por la máscara hacia dónde me dirijo. Bien. Si 10.1 cae en 201, no. No. Pasa a la siguiente. 10.1 cae en-- ¿10.1? ¿Qué dije? Perdón, 1.10 quería decir yo, en realidad. Perdón. 1.10. A la máquina 1.10. 1.10. ¿Cae en 10.10.10.1? No. En la cuarta recién. Bien. ¿Cae en 100-- 0, ¿no? Cae acá. ¿Y qué entonces qué hace? Sí, machea contra esto. ¿Qué es lo que hace? Voy por el Ethernet 0, por el 200.20. OK. Es decir, va a agarrar ese paquete. ¿Y qué va a hacer cuando vaya por el 220? ¿Qué es lo que va a hacer? Va a ir por este cable, ¿no? Entonces, ¿qué es lo que le tiene al paquete IP? ¿Qué le va a cambiar? Lo va a dejar caer en este cable. ¿Y qué es lo que tiene que averiguar para que el paquete se mueva de acá hasta acá? La MAC del siguiente salto. Muy bien. La capa de enlace va a averiguar cómo contacta al próximo salto. Y las cabeceras de enlaces cambian. ¿El paquete IP se cambia en algún momento en todo el viaje? No, no. No, no se cambia. No cambia el paquete IP. Bien. Acá hemos desentramado completamente el problema del ruteo. Créanme que-- Es decir, este algoritmo de ruteo es equivalente a-- Es el mismo para todos los routers que tiene la internet. Si yo le digo, estos son-- Lo hice a propósito, ¿no? Con estos números. Si esto fuera internet, ¿sí? ¿Qué cambiaría de todo esto? El tamaño. Evidentemente. Está bien, el tamaño. Pero, ¿y qué más? Evidentemente, las IP. ¿Y las IP para este problema qué son? ¿Son códigos? ¿Son reglas de negocios? ¿Son datos? ¿Son configuración? Son parámetros. Son datos, digamos. Y le da lo mismo a este algoritmo si estos son IP-- Del rango IP públicas o privadas. Es más, les digo más. Si esto fuera IPv6, van a ver que es lo mismo. Es decir, la lógica es la misma. Acá, el principio de que el ruteo está basado, salto a salto, y esa decisión se basa con información local, la información local está almacenada. Y si yo les preguntara desde el punto de vista de estos routers, ¿corren un sistema operativo? Sí. Son computadoras, digamos. Si yo le dijera, bueno, vamos a armar un router, ¿qué le ponemos? Si yo le dijera, vamos a armar este router, a simple vista, ¿qué es lo que tendría que tener? Procesador. Placa de red. ¿Cuántas? ¿Cuántas placas de red? [VOCES INTERPUESTAS] 3. 3. Es decir, un puerto físico por cada uno. No hablemos que haya vidas ni nada. Es decir, agarro una computadora y le pongo 3 placas de red. ¿Qué le instalo? Los drivers. Y algún software que administre esas placas. Los drivers. Espera, a la máquina, ¿qué le instalo primero? Memoria RAM. Bueno, está bien. [VOCES INTERPUESTAS] El sistema operativo. Ah, por eso. ¿Qué le instalo? El sistema operativo. ¿Cuál? Por eso. ¿Qué le instalo? Linux. Linux. Ajá. Y si no fueron Linux, ¿qué le pongo a poner? Sí, Windows. ¿Verdad? No sé. ¿Y qué tendría que mirar si le quisiera poner Windows? Que sea compatible con el protocolo IP. ¿Y ustedes qué piensan? Que es. Que sí. Por eso, pero, ¿qué más necesito? ¿Cuál es la gran diferencia que hay entre los nodos que están en las puntas, esos, con los nodos que están en el medio? Porque tienen implementado todo el stack IP, pero ¿cuál es la gran diferencia respecto de su rol en el stack? A ver, sin duda que los Windows tienen IP implementado, si no, no podríamos usar TCP IP, un browser. Que son las maquinitas que típicamente usamos para las puntas ahí, ¿no? Lo que serían las puntas. En las hojas de ese, si lo consideramos es un árbol, tenemos las ramas y las hojas. Las hojas, bueno, en el caso de internet de eso es como si fuera un gran bosque adentro, ¿no? Pero en las hojas ponemos Windows. Si quisiéramos un Windows para hacer de router, ¿qué deberíamos buscar en las especificaciones, en la web? A ver si tiene capacidad de qué. De tener múltiples IP. Bueno, eso ya lo sabemos porque puede tener un IP por placa, así que eso ya lo soporta. Ya lo vimos en los algoritmos que hemos ido creando. Desde este que hicimos, este andaba con múltiples IP y andaba. Eso es también. Pero, ¿qué habilidad tiene que tener? Que solo tienen los routers. Bueno. Redireccionar paquetes, ¿puede ser? Claro, piensen que un router, lo hablamos el otro día, hace algo como esto, hace un reenvío de paquete. Viene un paquete por acá y dice, ah, este lo tengo que-- lo levanta. Eso lo hace alguien. ¿Quién hace el laburo de contrastar contra la tabla de routeo? El software que corre acá adentro. Entonces, tiene que tener la capacidad de decir, ah, este paquete que no es para mí. Porque no tiene ninguna IP que es mía. Entonces, tengo que mirar si tengo habilitada la capacidad de tomar decisión de reencaminarlo a otro lado. Y eso es precisamente la función de ser un router. Si no, si esto fuera un host. Imagínense que esto es un host con tres placas. Y nosotros no le hemos dicho, ah, vos podés levantar paquete de un lado y mandarlo para el otro. ¿Qué pasaría si esto no fuera un router? Se pierden los paquetes. Claro. Todo lo que no sea para él lo va a descartar. Claro. Esta máquina juega con esta, juega con esta y juega con esta. Pero, es más, juega-- Lo de ella se lo manda a otro. Le puede tener puerta de enlace por acá. Pero olvídense de contactar, si vienen por acá, contactar a alguien que esté acá. Porque esta máquina va a decir, ¿esto es paquete no para mí? Cayó acá por esta placa, lo tiro. De hecho, un router tiene que levantar paquetes que vienen-- ¿Qué tienen de loco los paquetes de un router? Si él los mirara. ¿Qué tienen que es de él y qué tienen que no es de él? Perdón, si levantado desde los cables, desde las tramas. La MAC es de su plana. Claro. Claro, viene una trama que es para la MAC de él. Y dice, ah, esto es mío. Lo levanta. Cuando lo mira, ¿qué ve? La IP. La IP no es para él. Claro. La IP no es de él. Entonces, la diferencia fundamental entre un router y un host es que si un paquete viene y no está destinado a una IP que él tiene asignada a una de las interfaces, evalúa si tiene activada la función de routear. Esa tarea de routear, por ejemplo, en los sistemas operativos de Microsoft, solo la tienen los servers. Los sabores servers. No la tienen los sabores de escritorio. Es decir, un Windows 10 no routea. Debería chequear si el 10 no, pero hasta la versión anterior no routean por sí solos, digamos, con funciones del sistema operativo. Le puedo poner un paquete que lo transforme en un router, un software adicional. Pero no son routers. Sería también una bastante pésima elección poner un Windows para routear, ¿no? Pero-- ¿Por qué, muchacho? Porque es muy pesado. Necesitaría mucha memoria. ¿Define pesado? Está bien. Dijiste necesitaría mucha memoria. ¿Hasta qué capa habíamos visto que un router tiene que tener su fortaleza o su foco? Capa en el stack. O sí. Recuerdan cuando teníamos el dibujo de los nodos y en el medio estaban todos los routers, los nodos altos, los routers en el medio más bajito. ¿Hasta qué capa necesito técnicamente que un router soporte? CAPTEN CAPTEN: ¿Capa 3? JUAN MANUEL LUCERO: Bien. Y eso es capa de red. Entonces, necesito que el sistema operativo y todo esté tuneado para eso. Un Windows, que es un sistema operativo para usuarios finales, tiene una capa 7 gorda, ¿sí? Para aplicaciones, todo, memoria, cargar un entorno gráfico. ¿Necesito que un router tenga entorno gráfico? CAPTEN CAPTEN: Mínimo para la configuración. JUAN MANUEL LUCERO: Gráfico. CAPTEN CAPTEN: Sí, gráfico no necesita, pero es un extra. JUAN MANUEL LUCERO: Bien, OK. No hace falta que sea gráfico. ¿Puedo tener un browser personalmente en torno gráfico? Es un server web que gráficamente a mí se me dispare con un browser, pero no necesito levantar ningún router en la tierra en el cual yo le pueda conectar un HDMI y me levanto una consola. Gráfica con cosas todas bonitas y qué sé yo. A lo sumo, un web server que le pego con un browser, por eso no es un entorno gráfico. Aquí vamos con esto. Es un sistema operativo para usuario final que tiene una capa final de display de interfaz con el usuario y está optimizado para eso. Y yo necesito justamente un dispositivo que esté optimizado para tener gordo y muy bien hecha las capas de abajo, no las capas de arriba. Entonces, básicamente, es un desperdicio total de guita. Va a performar mal. Buscar un sistema operativo que esté orientado a tener, muy orientado a tener eso y que requiera una interfaz gráfica. Un router no lo requiere en absoluto. Eso nomás. PABLO SANGUINETTI: Bueno, bien. No, estaba chusmeando, perdón, estaba mirando nuestro script. Sí, estaba dado vuelta. La versión 2020. Bueno, vamos a tratar entonces de, con estos conceptos que hemos aprendido, nos vamos a ponerlos en juego y en dinámico. Quisiera que nos enfoquemos entonces en el sitio de la cátedra. Vamos a trabajar en, primero, todos tienen acceso a la cloud, ¿no? Todos los que están acá tienen acceso a su entorno como lo hemos dejado armado. Venes viewer. Chequeen que pueden llegar de manera-- Yo pagué mi 0 tier. Que pueden llegar a la cloud. Vamos a trabajar en el caso práctico 2, pero antes de trabajar con los dedos, quisiera que veamos el enunciado, lo trabajemos entre todo el problema y lo resolvamos en papel primero. Cada uno resuelve en papel. Para ello voy a compartir acá mi pantalla ahora. Pestaña 2. OK. Bien. Acá lo que dice el caso 2, tenemos que-- Este es el caso apuntado a que aprendamos a hacer routing. Y la idea es que resolvamos primero la lógica de este problema y después la implementemos con las herramientas de mininet que vimos la clase pasada. Lo leemos inicialmente y lo desarrollamos y después comenzamos a ver cómo sería. Dice, tenemos una organización de alcance nacional que ha contratado enlaces para sus 6 sucursales con la idea de armar una red one nacional. En el armado de esta red one, se ha dispuesto a utilizar para el direccionamiento IP la red 192.168.100/24 dividida en sus redes con máscaras/29. Cada una de las sucursales utilizará para su direccionamiento IP interno una red/24 completa del tipo 10.0. N, que sería el número sucursal, 0/24. De este modo, cada sucursal poseerá un enlace one, el que le toque el número de red/29, y una red interna 10.0.0/24. La dirección IP del enlace one del router de la sucursal será la primer dirección usable de la red/29. Su contraparte en la casa matriz será la última dirección utilizable de la red/29. La dirección IP privada del router de la sucursal será la primera dirección utilizable de la red 10.0.N.0/24. La correspondencia de direcciones entre enlaces y redes estará dada por la siguiente regla. La primera red/29 tendrá la primera red/24, la segunda red y así sucesivamente. Su misión es desarrollar primero todo el direccionamiento de las redes conjuntamente con un esquema de la misma e implementar con Mininet el router de casa matriz, dos sucursales y un puesto de trabajo en cada sucursal. ¿Se entendió? Vamos al pizarrón a ver si entendemos más o menos el dibujo. Ah, no, no se ve mi pizarrón. Voy a compartir la pantalla completa. Ahí estoy. Bueno, me está diciendo que hay una empresa que tiene sucursales, una red tiene sucursales, al menos seis, y luego tiene una red WAN que vincula esas sucursales. ¿Qué entienden por eso? ¿Cómo mala la numeración? Quisiera que me ayuden a dibujar cómo se imaginan que es esta red. ¿Aló? Tenemos las seis sucursales. ¿Qué hay en cada sucursal? A ver. Va a tener su router. Cada sucursal. No sé. Va a salir ahí. Este es una sucursal. Tiene un router y tiene una red, por decir acá abajo. ¿Está bien? ¿Está bien? Sí. ¿Cómo es otra sucursal? Igual. Tiene su router y su propia red interna. Esto no copia. A ver. Espera. Bueno. ¿Cuántas sucursales dice que hay? 6. 6. Vamos a poner más allá. 1, 2, 3, 4, 5, 6. OK. Cada una tiene su red. ¿Está bien? Este huevito es su red. ¿Está bien? Estas serían las redes LAN de cada sucursal. ¿Está bien? Ahora, me dice que esta es una organización nacional que está vinculando a todas sus sucursales. ¿Qué habría que hacer acá? ¿Cómo se vincula? ¿Le tiro un cable de acá a acá? ¿Otro cable de acá a acá? No sé, conectan a la internet. Claro, sale a la internet. No, no dice que hay internet acá. Ah, bueno. O una central con un router más general. El enunciado, por eso, quiero que me digan lo que dice el enunciado, porque si se pueden inventar, yo también soy brujo. ¿Qué dice el enunciado? Dice, una organización de alcance nacional ha contratado enlaces para sus 6 sucursales con la idea de armar una red WAN nacional. ¿Qué significa acá contratado enlaces? ¿Qué tiene el cable? O sea, ¿están unidas físicamente? Bueno, si tuviera un cable, tendría que tener un cable de acá. Imagínense que todos son provincias, habría que tirar cables fibras propias. Ha contratado a alguna empresa que hace enlaces y le ha dicho, mira, haceme un enlace de Mendoza en la calle San Martín y Piatonal con San Juan en la calle, no sé, San Martín y Piatonal. Es decir que ese enlace, que para mí es un cable, en realidad me lo está dando una empresa que provee comunicaciones. Pues, si yo me tengo que poner a tirar un enlace yo propio a todo el país, ¿esta red cuánto vale? No, me llevan. ¿Y la puede hacer cualquier empresa? No, prácticamente nadie. Utilizamos infraestructura que ya existe, digamos. Claro, bueno, parece. Entonces, respondan con criterio, no me digan pavadas. Aparte han cruzado comunicación y datos, digamos. Estos son enlaces. Si yo tuviera que decir cómo están hechos los enlaces, ¿qué tendría que dibujar acá? Es decir, si yo voy a hacer un-- si hiciera un enlace de acá a acá, me voy a conectar de acá a acá nomás. Y habría que conectarlas todas al de arriba. Por eso, voy a poner un router central que tiene un enlace a cada sucursal. Es decir que, por ejemplo, el router central puede ser el equipo que yo tengo o no lo tengo o lo tengo en la empresa de comunicaciones o lo tengo al oficia de router central. Por lo tanto, acá hay una red que es. ¿Cuál es la red WAN, entonces, de esta empresa? ¿Qué es una red WAN? Es decir, che, esta empresa está armando una red WAN. ¿Qué es WAN? Red WAN sería-- WAN es WAN de Arianetwork. Sí, sí, yo también sé que es WAN de Arianetwork. Pero, ¿cuál sería en este caso? Que están las 6 sucursales conectadas entre sí. Eso. Claro, cuando una empresa dice, che, mirá, esta es la red-- ¿Alguien conoce algún ejemplo de red WAN? El de la penitenciaría de Mendoza. Que hicimos un práctico para comunicación. La penitenciaría de Mendoza. A ver. A ver, cuénteme. Tuvimos que diseñar una red WAN para la penitenciaría de Mendoza y conectaba todas las penitenciarías que habían con los juzgados y bueno, y todo eso de todo Mendoza. Y habían algunas en Rafael, otras en Tunoyán, otras en Uspaldatas, estaban en diferentes localidades. Bien. ¿Y por qué tiene sentido eso o no tiene sentido? ¿Quién tiene sentido de tener una red así, por ejemplo? Y por la seguridad. Sí, ponele. Por la cantidad de información que tienen que comunicarse entre ellas, digamos. Enviarse entre los juzgados. Bueno, puede ser la cantidad de información, puede ser una buena razón. Ahora, si yo-- Por eso, la pregunta es, ¿quién estaría a la altura de requerir una cosa así y que te tengan cercano acá? El gobierno. El gobierno. Tendría que hacer una cosa así el gobierno. ¿Qué piensan ustedes? El gobierno tiraría los cables. No, no. ¿Podría ser la Universidad de Mendoza para comunicarse con San Rafael? Nosotros tenemos enlaces, sí, sí. Hace mil años que tenemos enlaces con San Rafael. Pero tenemos un solo enlace, digamos, Mendoza-San Rafael. No, yo me refería a que el gobierno podría ser un ejemplo también de una red buena. ¿Para qué? Para comunicar, no sé, por ejemplo, los departamentos o, no sé, se supone. ¿Para qué? Sí, pero por eso, ¿para qué? ¿Para jugar al Fortnite en red? No, para tener algún-- como que estar centralizado a toda la información que se maneja. Por ejemplo, no sé, con las licencias de conducir o esas cosas. Bien. Entonces, ¿ahí qué aparecieron? ¿Para qué tiene sentido la red? Sí. En el caso de lo que hicimos nosotros, profe de la penitenciaría, había un nodo central en la Abulón-Sulmer. Y, bueno, se conectaba a la distinta sede o penitenciaría que había desde San Rafael, Tunoyano, Payata, todas se centraban ahí en el nodo central ese. ¿Para qué? Usando la analogía que dijo de la licencia de conducir, podría ser de que yo siendo de Mendoza, puedo transitar acá con mi licencia. Y si me voy a Buenos Aires, ellos pueden acceder a esos datos que están acá y permitirme transitar en Buenos Aires. Podría ser para-- Sí, bueno, pero yo estaba solo por eso. Yo quiero que hablemos de algo que ustedes tienen cerca, porque iban más o menos encaminados. Usted decía, bueno, él dice, para conectar las penitenciarías que hay en Mendoza. Yo digo, está bien, ¿a qué las va a conectar? Por ejemplo, ¿para qué las tendrías conectadas? ¿Para mandar un mail? Para poder acceder a la información de una base de datos compartida. Por privacidad, si no, también puede ser. En el caso de la penitenciaría, por ejemplo, como es una misma red one, no hace falta que pase por el internet. Por ahí ganan seguridad. Bueno, por eso estoy tratando de tirarle la piola para ver, porque ustedes hablan de red, hablan de la internet, pero decir, ¿para qué? Por ejemplo, una buena razón podría ser esa que dice, che, mirá, no queremos estar poniendo las filmaciones de las celdas de alguien en, no sé, o-- Y, bueno, queremos tener la capacidad de monitorear la filmación de cada lado. Les cuento que la provincia de Mendoza tiene como 5 redes gigantescas. Por ejemplo, la red de cámara de video es una red en sí misma. La provincia tiene, debe tener 1,000 cámaras por lo menos. La policía tiene 5 o 6 centros operativos para monitorear las cámaras que fluyen los stream de cámara de video durante todo el tiempo. Esa red es la red de, llámale, de seguridad. Los centros operativos de la policía, los 911, también están conectados en red. El gobierno tiene una red propia celular que se llama Tetra, que a su vez mueve datos, que vincula a toda la provincia. Después tiene otra red WAN que es la red WAN de gobierno, que tiene muchísima transaccionabilidad entre sí porque tiene vinculación y en realidad está en los inicios de lo que debería ser. Ninguno de ustedes en realidad veo que tiene un vuelo mental suficiente para ver, pero por ejemplo, y si yo estoy en un hospital y quiero ver una tomografía que le hicieron a un tipo en el hospital de San Rafael y está acá, ¿por dónde la vamos a ver? Por internet la vamos a ver. Si estoy en el registro civil de San Rafael y quiero ver la partida de nacimiento de alguien que está acá en Mendoza, ¿por dónde la voy a ver? Por internet también. ¿Usted piensa que todos esos sistemas van derecho al internet, no van al internet? Para usted la internet es una red omnipresente, pero a su vez la internet no es una red WAN común. ¿Cómo se llama si yo quiero usar la internet? Como si fuera mi capa de enlace, pero darle seguridad de un lado al otro. VPN. Una VPN. Una VPN. Una VPN. Les puede parecer natural a ustedes que, por ejemplo, esos enlaces que se ven ahí podrían ser o yo los contrato con un proveedor que me da un enlace WAN o podría ser una VPN por internet. Pero nunca va a ser si yo estoy armando una red que vincule organismos-- perdón, que vincule tráfico de una misma organización, no lo voy a hacer por la internet abierta. ¿Eso lo tienen claro ustedes? ¿O no lo tienen claro? Sí. Y, por ejemplo, los datos profe de la penitenciaría no pueden ir a la internet abierta. Tenían que ir por una VPN conectada a la central. Por ejemplo, los datos que estaban en la penitenciaría San Rafael. Por eso, pero los datos fueron por la internet, nada más que fueron segurizados o fueron por un enlace dedicado. Es muy distinto. Es decir, es muy distinto cuando ustedes piensan en la internet como medio de transporte, como medio de enlace, a cuando piensan en un enlace contratados. Aparte de un abismo en precio, es una cosa que esto es totalmente diferente. Al margen de como sea, podría ser la internet, pero la penitenciaría, primero, que tendría que exponer equipos a la internet para hacer estas comunicaciones de manera más o menos segura. No voy a indagar más. Se lo dejo para que reflexionen quiénes podrían ser necesarios. Igualmente, acá hay muchísima confusión a veces, porque, bueno, estamos en un mundo, por un lado, súper claudístico, basado en infraestructura de cloud. Pero aparecen cosas como esta, como los gobiernos, como los estados soberanos, como las provincias, donde si bien a nosotros somos muy pro las prácticas y las disciplinas que ofrece el paradigma cloud, no significa que todo requiera de una cloud pública, digamos. Es decir, que el gobierno de la provincia instale su sistema en Amazon, por ejemplo. ¿Ustedes cómo verían que estén sus datos, los datos, por ejemplo, de los sistemas de, qué sé yo, de rentas en Amazon? ¿Entienden lo que sería Amazon? Sí. Sí. En la cloud. Claro, pero ¿dónde está guardado eso? Si lo guardo en Amazon. En una empresa privada. Por ejemplo, ¿dónde están guardados sus datos de la cloud de la OM? En el servidor de la OM. ¿Dónde? Si ustedes los vieron, pues. ¿Cómo? ¿Dónde, pregunto yo? ¿Dónde está? ¿Lo pueden ir y tocar o pueden ir a buscarlo, digamos? Sí, en el primer piso. Claro, por eso es una cloud, pero una cloud privada. Claro. No es una cloud pública. Que las prácticas son las mismas, pero la zona de soberanía, por decirlo de alguna manera, es distinta. Bueno. Me fui el carro a los caños. Volvamos a la one. ¿Qué es una cloud privada? Una cloud privada es una cloud privada, es una cloud privada que está en el medio de un sistema de control de la cloud. Y la clou privada es una clou privada que está en el medio de un sistema de control de la clou. Y la clou privada es una clou privada que está en el medio de un sistema de control de la clou. Y la clou privada es una clou privada que está en el medio de un sistema de control de la clou. Y la clou privada es una clou privada que está en el medio de un sistema de control de la clou. ¿Qué es una clou privada? Una clou privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. ¿Qué es una cloud privada? Una cloud privada que está en el medio de un sistema de control de la clou. [AUDIO EN BLANCO] Bueno. [AUDIO EN BLANCO] (Pausa) (Pausa) (Pausa) (Pausa) ¿Lo miraste a ver si reboteó algo más Juan? Yo estaba chequeando, se ve bien, estaba viendo algunos pods por ahí medio sueltos que quería estar seguro, porque realmente cuando pasa esto a veces no se pueden crear nuevas instancias, justamente en ese estado. So far so good, pero lo mismo no me entiende, estar bien seguro de que fuera así, de hecho voy a crearme una instancia ahora para estar totalmente seguro. El Ceph, el más quejoso. El Ceph levanta fantástico, es el pegamento del puto penstock en realidad, es el cinder que usas, perdón el de las imágenes, el glans, es el que tengo que dar alguna manija a veces cuando levanta de vuelta. Lo voy a chequear, quería ver directamente de launcher una nueva y ver qué suerte o no suerte tengo. Bueno, estamos para ir entonces a ver los cálculos de los números, así avanzamos. Entonces, alguien que me pueda facilitar cuáles son las coordenadas de la red siguiente, cuál sería la dirección IP del router de la sucursal. Esta es la segunda red/29, cuál sería la IP del router de la sucursal. 100.2 Si yo le pongo 100.2 acá, este IP a quién pertenece? A la red que tiene con la central. No, ahí va a 100.9 Pará, quiero que me digas por qué 100.2, por qué pensás que es 100.2? Esta IP que yo te estoy dando acá, dónde cae? En la 192.168.100.0 Es decir que este IP es de esta red? Claro Y entonces, este router al final es vecino de este router, está en la misma red, y no es así, porque este cable no está conectado ahí. Y de hecho, esto no cae en la segunda red IP/29. Sí, sí. Cuál es la segunda red IP/29? Cuál es la dirección de red de la segunda red/29? 100.8 Bien, cuál es la primera IP usable de la red 108? La 9 Ah, la .9 Muy bien, es decir que acá es 9. Cuál es la última IP usable de la segunda red/29? La 14 Claro, la 14, porque esa sería Broca's. Sí, por Broca's. 14, muy bien. Cuál es la IP del router? De acuerdo a las direcciones que pusiste acá? 10.0.2.1 /24 Muy bien. Cuál es entonces, esto está bien, cuál es el direccionamiento de la tercera red? Cuál es la tercera red IP/29? La /17.6 Y la primera IP usable? La 17. Muchachos, hagan los ejercicios, todos los problemas que tomamos en los finales son así. Nunca van a recibir de nuestras manos un problema que tenga cocinada la dirección IP. Siempre se la vamos a hacer calcular. Así que, si ustedes calculan mal la IP y no leen bien un enunciado, van a hacer todo el problema mal. Entonces, es muy importante, como les dijimos al principio, que hagan bien los cálculos de dirección IP. Cuál es la última IP usable de este bloque /29, que sería la IP del lado WAN de este lado? La 22. 22, muy bien. Es la IP 22. Y la LAN de la sucursal 3? 3.3 La 3.1. Cuál es la cuarta red /29? La 24. Cuál es su primera IP usable? La 25. Puso ahí. Gracias. Cuál es la IP WAN? La 30. ¿Se ve algún patrón en estas IPs? ¿Ustedes ven algún patrón? Sí, las WAN siempre caen en par. Por eso, ¿qué tienen todas las IPs, tanto esta como esta, de patrón cuando cambian de sucursal? ¿Cuántas veces cambian de sucursal? Saltan 8. Claro, saltan de 8. Puso un red /29. ¿Se entiende? Bueno, me cansé de copiar números. Si no les molesta, voy a dejar. Creo que se entiende, ¿no? Sí. Ok. Bueno, lo que necesitamos es... Esto está así. Lo que queremos es que ahora esto lo implementemos en Mininet. Y, en realidad, lo vamos a implementar y vamos a rutearlo en Mininet. Por lo tanto, tenemos ya el esquemático, el escenario... Deberíamos resolver este mismo escenario utilizando, si es que podemos, Mininet. ¿Me explico? Quiero que resolvamos esta red. Recuerden, no a los efectos de... Como esto es un API, y lo que vimos el otro día, da lo mismo que ustedes... Bueno, tratemos de resolverlo. Les doy, si quieren... No sé si hacemos un corte y hacemos un break. Y a la vuelta, en eso incluir el timo para no estar todo frente pantalla. No sé qué te parece. Estás muteado. Sí, me parece bien que hagamos un break. Dale. [RISA]Sí, perfecto. Bueno, buenas tardes. Entonces, vamos a retomar para cerrar el tema de IPv6, que estuvieron viendo con el ingeniero Cerlante en la clase anterior. IPv6 sería dos versiones después que hay de la que tenemos ahora. En el medio hubo IPv5. ¿No? No. ¿No o sí? Hay IPv5. ¿Alguno usa IPv5 ahora? ¿Alguno me puede comentar qué diferencias puede haber entre IPv4 e IPv6? Hola. Hola. Y la diferencia fundamental, por ejemplo, es la cantidad de IPs que se pueden armar. Bien. Repasemos rápidamente algunos conceptos. ¿Por qué llegamos a IPv6? ¿Por qué llegamos a IPv6? Porque la cantidad de IPv4 se estaba agotando. Sí. Con necesidades. Bien. Pero todavía quedan IPv4. No tenemos problemas. No. Si mal no recuerdo ya estaban completamente agotadas y si querías pedir una… ¿Cuáles ya agotaron? Las públicas. Las públicas. ¿A dónde las pedíamos? ¿A quién le pedíamos estas IPs? ¿A quién le tenemos que decir "che, dame IP públicas"? Nosotros acá que estamos en nuestro país, ¿a quién vamos a pedirle…? A un organismo que no recuerda el nombre. Claro, por eso estoy tratando de… Pareciera que hace un año que no nos vemos, entonces los veo medio dormidos. El NIC. Ah, entonces entro acá, pongo NIC-AR y le digo que quiero IP pública. ¿Es NIC-AR? Acá le digo… "Quiero una IP pública". ¿Vas sí? ¿A NIC-AR le tengo que pedir un IP? No, era el de Latinoamérica, pero no me acuerdo también el nombre. ¿A quién? ¿Quién es el organismo que estamos buscando? Uno de esos… LACNIC. Muy bien. Tenemos que ir acá, a LACNIC. Que LACNIC es nuestro RIR. ¿Se acuerdan que habíamos visto que la Internet en su génesis, cuando tuvo que dividir el espacio de direcciones, se distribuyó en los RIRs, los registros regionales de Internet, que son los que gobiernan la asignación de bloques de direcciones IP, y en realidad, ¿qué es lo que hay que tener realmente para jugar en la Internet? Y decir, bueno, al que yo le puedo para asociar bloques de IP y con lo que pueda hablar con otros en la Internet y que ellos sepan de mis prefijos. ¿Qué me va a dar, qué me va a pedir acá que gestione don LACNIC? Un sistema autónomo, ¿se acuerdan? Entonces, el sistema autónomo sería la manera en la cual yo puedo decirle a la Internet que tengo la capacidad de gestionar bloques de direcciones IP, ya sean IP4 o IP6. De hecho, bueno, acá LACNIC me está diciendo que esta es mi IP pública y si me buscara por acá, podría ver que... A ver, vamos a hacer un truquillo. Les voy a enseñar un truco. Un truco. Esos que sabemos los veteranos de... Me voy a conectar a mi cloud. Me acuerdo el IP de mi instancia. Esta, por ejemplo. En realidad no me voy a conectar, voy a hacer "ssh ubuntu apk" y le voy a decir que haga esto. Y acá le voy a pedir a un Firefox que arranque. Aquí se lo cerré. Un Firefox que arranque. El Firefox lo ven, ¿no? Sí. Sí. A ver si me sale. Bueno. No. No me... No me... No me... No me... No me... (Pausa) (Pausa) (Pausa) (Pausa) (Pausa) (Pausa) Bueno, no eligió hacerlo. Bueno, nada. Pensé que iba a elegir contra la Acne, claro, ha hecho uso del DNS, mi máquina, eso. Yo hice acá una cosita, un truco, fíjense, hice así. Hice, esto es, anótenlo entre paréntesis. Si yo tengo login en una cuenta en la que tengo, como es esta mi máquina de la Cloud, no sé si alguien me está escribiendo. (Pausa) Ah, está. Gracias. A ver si le cae bien, HTTP. No creo que sea su, (Pausa) su, ¿cómo se llama? (Pausa) Bueno, a ver. (Pausa) Ah, shit. No, con muta al 4. Bueno, no, lo que les mostré recién es yo hice un SSH a mi máquina, esta es mi máquina en la Cloud, ¿no? Hice un SSH y acá lo que le dije es, che, mirá, haceme de proxy acá yo le di un puerto, ¿sí? En realidad, el protocolo SSH no es solo, es un protocolo muy potente, no solo sirve para que yo me logue en una máquina remota, sino que yo le puedo pedir que tome y haga un proxy de ese puerto desde mi máquina y lo haga salir como si saliera desde la máquina en la que yo tengo este login. Entonces, lo que hice recién fue correr este comando. Y después, ustedes vienen acá al navegador, se los cuento porque les puede servir, por ejemplo, muchas veces ustedes trabajan en algún lugar y necesitan navegar un sitio como si estuvieran en Estados Unidos. Entonces, se contratan una instancia un ratito en algún lado, le hacen un SSH y navegan como si estuvieran en Estados Unidos. Entonces, fíjense que yo estoy navegando como si estuviera con la IP pública de la Cloud, ¿está bien? Lo que tengo que hacer después es avisarle a mi navegador y decirle que use un proxy. Entonces, me vengo acá al proxy y en realidad lo que hace es usar un protocolo que se llama SOCKS. Fíjense que yo a este navegador le he dicho que usa proxy, el proxy está, el proxy se determina cuando yo hago este SSH a esta máquina que no se ve nada. Si yo hago acá netstat -npla y busco, van a ver que tengo, dice escuchar es decir que está bindiado, está escuchando en la IP local en el puerto 30.000 que yo le di. Y dice SSH. En realidad lo que hace es, mi navegador se conecta a este puerto y en realidad usa un protocolo que se llama SOCKS. SOCKS es un protocolo que sirve para mandar cualquier protocolo adentro y hacerlo aparecer del otro lado como si yo estuviera en el lugar donde está el otro terminador SOCKS. Entonces ese truco me permite a mí yo quería ver si esto elegía navegar en 6 pero en realidad el navegador esto debe estar optando primero por la IP en 4. Si, ahí dice Profelman que si pone en brackets la IP de 6 lo hace, lo bindea la IP de 6. Claro, pero la puse en la era de aquí. En el -d. Ah, ¿en dónde? En el SSH -d. Cuando corrió el comando ponerle el -d Es que yo no tengo la IP 6 acá. No tengo IP 6 acá, de ninguna manera. No, pero no importa. Fíjense, igual que es un tema de DNS, aparentemente, o de no sé qué es lo que está haciendo. Fíjense que yo después puse testear test IP de 6. Por alguna razón el sitio del Lightning no me atiende. O puede ser que el sitio del Lightning no esté en 6. No es loco pensarlo. Fíjense que yo navego acá, tengo IP de 6. La misma que dice que tiene mi máquina, ¿no? De hecho a ver, vamos a hacer una prueba. Me está haciendo dudar esto. IP de rojo. Disculpenme que me enganché con esto. A ver, ¿qué es esto? youtube.com [AUDIO_EN_BLANCO]Tengo que despejar mi escritorio. Un momento, así lo puedo... ¿Qué tenemos? ¿Qué tenemos? Jamboard, Barbara. Buenísimo, acá esto, genial. Barbara, excelente. Entonces, ahora, es bonito que me acomode el escritorio acá. Sí, la idea de la clase de hoy, vamos a terminar de completar algunos protocolos que asisten al protocolo IP, como son el protocolo ICMP, que es muy importante, vamos a hablar de ARP, y también vamos a ver el protocolo DHCP. Y si pudiéramos, después del break, la idea es terminar de completar la pintura en nuestras cabezas de cómo rutea la Internet real, con las cosas que hemos aprendido en nuestra Internet, que hemos probado en nuestros MiniNets. Así que ese es un poco el menú de la clase del día de hoy. A ver, screen, screen, screen. ¿Cuál es? Quiere ser esta. Bueno, díganme ahí cómo se ve, seguramente tengo que aumentar los fónticos. Bueno, vamos a ir tratando de switchar entre eso. Presentamos a ICMP, entre nosotros. Vamos, arrancamos entonces. ¿Alguien me recuerda el ICMP en qué capa está? El ICMP lo hemos introducido en algunas de nuestras discusiones. ¿Capa 3? Capa 3, sí. Decimos, a mí me gusta decir justo lo que está ahí en medio de la presentación, que es raro, porque es un protocolo que se llama InBand. Es como que se usa el mismo que lo transporta, que vendría a ser IP, para señalizarle el problema a quien lo transporta. Es InBand, no es que estamos usando otro canal, otro identificado protocolo, sino el mismo protocolo que yo quiero ayudar es el que me transporta a mí. Es el caso ICMP. Por eso es raro. Alguna gente lo ubica mal en transporte, porque no es un protocolo de transporte. Un protocolo de transporte siempre tiene pegado aplicación arriba. Está dedicado a transportar payloads de aplicación y ICMP no está para eso. ICMP es un protocolo que está al lado de IP. Es decir, está semánticamente, tal como bien me respondieron recién, está, es capa 3. Sin embargo, se escribe muy parecido a un protocolo de transporte. Es decir, si nosotros capturamos un paquete IP que cargue ICMP, si uno lo viera estrictamente desde la sintaxis, es decir, como lo escribimos, se vería muy parecido a un paquete UDP o TCP, sin embargo, no tiene nada que ver. Fundamentalmente, la presencia de ICMP es... La razón de su presencia es que, recordemos que IP es "stateless", es "connectionless". IP en sí no es orientado a conexión, porque yo no le pido a la red IP "dame una conexión". Yo, ¿cómo consumo la red IP? Yo, como consumidor de red IP. Si, como consumidor de red IP, yo me presento a la red IP y le tiro un problema. ¿Qué son esos problemas a la red IP que yo le tiro? Son, datagramas. Yo, para consumir el servicio de la red IP, yo nodo. Imagínense, yo soy un nodo. Tengo toda una red IP y tengo que llegar a otro nodo. ¿Qué es lo que le tiro como problema a la red IP? Le tiro conexiones, le tiro datagramas. Y ya sabemos, problema, un router empieza y termina con cada datagrama. Entonces, yo, como consumidor de la red IP, lo que le tiro son datagramas. No le pido conexión, le digo "che, red IP, hacés llegar esto a destino". Suerte, ya sabemos, ves este "for", no orientado a la conexión. Entonces, la razón de la presencia de ICMP es justamente para que la red me pueda, tenga alguna manera de decirme la red a mí, como consumidor de esa red IP, como nodo que consuma esa red IP, "che, estamos teniendo problemas con esto". "Che, no, no, esto que estás tra--, este datagrama que enviaste acá no tuvo suerte, no le fue bien. Fijate qué haces". Entonces, de alguna manera, si lo vemos a la red como un servicio, es lo que nos feedbackea de que hay algo que yo tengo que corregir como consumidor de esa red IP, como nodo, como endpoint, como host que consuma los servicios de la red IP. ¿Queda claro eso desde el punto de vista semántico, o sea, desde el punto de vista arquitectural, que es súper importante, porque de ahí vamos para el resto. ¿Sí? - Bien. - Sí, Pablo. Pablo, lo último es súper importante, que forma parte del hecho de que la red IP no hace ni más ni menos que hacer el mejor esfuerzo para hacer que un datagrama llegue a destino, pero no corrige nada. Y ICMP no está ahí para decir "ah, mirá, se te flipó este bit". Bueno, ya que estoy, te lo arreglo y te lo reencambio. No, no, no, no. Acá se tiró y lo reporto. No es el rol de IP más ICMP, que tendría que ser en definitiva la capa 3 de IP, IP más ICMP. No es el rol corregir nada. El rol es reportar para quien consume eso, el nodo que consume los servicios de la red IP, haga algo y sea él el que eventualmente corrija. Vamos a ver que en algunos casos puede hacer algunas correcciones. Por ejemplo, de la MTU, que hablamos en la clase pasada. Recuerdan que el nodo que observaba que había una depresión de MTU en el camino y que se le reportaba "che, no, no, a 1.500 no pasa". En realidad tenés que bajarlo porque yo el link que observo es de 1.400 y el nodo que está enviando, entonces puede ajustar. Y hay algunos casos que no. Entonces, eso es lo que vamos a explorar un poquito cuál es el scope, cuál es el ámbito de lo que hace ICMP en base a este reporte de errores que envía. Bien. Buenísimo. Entonces, ICMP, vale aclarar que no tiene, a diferencia de los protocolos de transporte de todo el stack TCP/IP, no tiene puertos porque justamente los puertos están de alguna manera, para los protocolos de transporte de todo este stack, están dedicados a asociarse con aplicaciones. Ya sea esa aplicación lado cliente, un browser, esa aplicación un lado server muy simplificado, un HTTP server en 80, un HTTPS server en 443. Sí, pero están ahí los puertos justamente para pegarse a cómo se usa desde una aplicación. Como ICMP no es un protocolo de transporte al servicio de aplicaciones, es un protocolo de soporte, de ayuda de IP, no tiene puertos, no necesita tener puertos, tiene un enfoque distinto de cómo cataloga, si se quiere, los distintos tipos de workloads que soporta o tipos de mensajes. Como ustedes bien pueden imaginarse, la red IP puede presentarse con muchas situaciones distintas y esto es lo que trata ICMP de cubrir. Vamos a ver estas situaciones distintas. Nuevamente, recuerden, a nosotros no nos interesa que se acuerden de memoria los números ni nada, pero sí que entendamos cuáles son las situaciones que presentan problemas en la red y cómo ICMP ayuda, cuál es la misión de protocolo ahí. Entonces, el mensaje ICMP ni siquiera es una cabecera porque es muy simple, lo pueden encontrar en internet, que es payload IP, entonces va a tener primero que es un campo que es el tipo de mensaje, después va a tener algo, algún adicional respecto del código de mensajes. Tipo y código. Los tipos son estos números, estos es un manozco de números, fíjense, 0 es un tipo, 3 es un tipo, 14 es uno de los tipos de mensajes y el código lo lleva detrás. Entonces, vamos a verlo. Raro que los muchachos, fíjense, el primer tipo que encontramos si lo vamos enumerando así secuencialmente desde 0 es Echo Reply. Echo Reply, ¿qué vendría a ser? ¿Qué se les ocurre? Fíjense que es el... Ahí dice, ping. Ping, ok. Y fíjense que es otro tipo, el Echo Request. Quiere decir que cuando yo hago un ping, el ping que bien conocemos, en realidad estoy mandando mensaje ICMP de tipo 8, cuando yo lo genero, y espero que me venga un ICMP de tipo 0. Es solo... a ver si... vamos a probar, no estoy seguro cómo lo va a mostrar. El sistema operativo y su manejo de ventanas, lo aborrezco. No sé, ya, chao. Paro de presentar un poco. Oh, my fucking gosh. Si alguien, nuevamente, si tienen alguien que les viene a decir que MacOS es un sistema operativo amigable al usuario, por favor, pónganme en contacto con esa persona. Ayer con un amigo, toda esa discusión. La puta madre, perdón, estamos grabando. No es amigable. Será amigable para, no sé, para mi viejo, ponele, para mis viejos, pero... Tiene unos comportamientos extrañísimos. El manejador de ventanas apesta, el sistema operativo no puede correr Docker razonablemente bien. Qué cosa, qué horrible. Y ahora, por ejemplo, cambié las ventanas para poner en foco el Shell, vieron que había separado en dos. Y esta que estaba presentando, no sé dónde dios la fue. No sé. Lo aborrezco realmente. Una cosa que no soporto. Bien. Es amigable si no lo usás. No, obviamente, todo es amigable de acuerdo a la audiencia, pero lo que yo discuto, y tengo muchos puntos para discutir, es que sea amigable para desarrolladores, que parece ser un caso de uso bastante típico para esta porquería del sistema operativo, pero bueno, nada. Ahí vamos. Bien. Para hacerlo un poquito más entretenido esto, vamos a... Vamos a hacer... Alguien que me pingue, por favor. Ya les... Ahí pueden ver la IP. ¿Cuál es mi IP? Ahí pueden ver. Esto es a propósito. Yo lo veo muy chiquito. ¿Ah, muy chiquito? Dale, muy chiquito. Vamos. Un momentico. Vamos. ¿Dónde ahí? Ahí, un toquecito más. Ahí. Bueno, buenísimo. ¿Cuál es mi IP? Esto es a propósito. Lo tiramos así porque esto... Nosotros ya tenemos que empezar a sintonizarnos la cabeza con poder decodificar lo que estamos viendo ahí en la pantalla. Fíjense cómo leo eso. Ah, mira, hay una ruta por default a través de... Ya sabemos, a través del router. Y para usar esa ruta por default, me presento con esta source IP. Por lo tanto, esa es la IP con la cual yo estoy en la red. De hecho, si ustedes tratan de parciar esto, fíjense que acá dice source, source, source. Están todos pegadas a la misma interfase. Entonces, evidentemente, yo tengo una única IP en esta interfase. Que es Ethernet algo, por eso empieza con "e". Que es esta. Así que, me pinge a vos, Diego, para que no se... Vamos a hacer lo siguiente. sudo tcpdump -interfaces/ncms/cmp A ver qué se ve. Vamos a agregar un "-n" para que no haga resolución de nombres. Hacés un ping, Diego. ¿Estás ahí, Diego? Parece que no. ¿Alguien que me haga un ping? El primer ping que se ve en la pantalla, alcanza. [PAUSA] Eso, gracias. Fíjense, ahí pueden ver, a lo corto, gracias a 0.193 que me ha hecho un ping. Acá pueden ver "icmp corequest", "icmp echo reply". Fíjense que en este caso, el mismo... ¿Cuál es el rol que ocupa tcpdump? Es lo mismo que han visto con WildShark el año pasado, que lo veían ustedes gráficamente. Lo que pasa es que es importante conocer la herramienta tcpdump porque, como hemos hablado muchas veces, no siempre, ustedes van a estar con una terminal gráfica contra lo que están tratando de bogear. Que a veces puede ser un router remoto que ni siquiera tiene una terminal gráfica, pero un router Cisco tiene un comando similar, o al menos, sí, tcpdump, muy parecido. Entonces es importante que uno se ponga a tono con estas herramientas que son de texto, si quiero, o de línea de comando. Entonces ahí se ve bien clarito, ¿no? "icmp corequest", "icmp echo reply". ¿Qué ven ahí? ¿Qué va cambiando de un paquete a otro, de un mensaje a otro? [PAUSA] La secuencia. La secuencia. ¿Y para qué se le ocurre que servirá esa secuencia? Y yo creo que es a un request con la primera secuencia, la primera respuesta, el segundo request. Fíjense que justamente si ustedes hacen... [RISA] Hemos habilitado IPv6 en la cloud, así que vamos a tener que sobrecargar los comandos con i4. Escuchame, -4 creo que era. [PAUSA] Bien. Justamente, fíjense cómo se los muestra cuando ustedes lo usan. Acá yo estaba debogeándolo, ¿no? Estaba TCP dampiándolo. Dampiando los paquetes y vemos que van y vienen. Acá está el número de secuencia, acá está la aplicación, cómo los usa. Lo que hace obviamente es para poder correlacionarse. Yo le mando un ping. Recordemos que acá no hay ni siquiera secuencialidad garantizada en la red. Entonces bien puede ser que el segundo ping venga antes, que la reply venga antes que el primero. Entonces, como en este caso estamos usando ICMP no para error reporting, sino para debugging, para diagnóstico. Entonces por eso es necesario sobrecargarlo con información que a mí me sirva justamente para encontrar eso. Y hemos visto algunos casos, hemos encontrado casos de data loss, especialmente si pingueamos a la luna. [PAUSA] Pingueamos a... Bueno, capaz que no lo tienen ni siquiera... Ah, sí, sí está. [PAUSA] Bueno, fíjense el tiempo. Está tardando. Ah, perdí un paquetito. Ah, perdí un paquetito. [PAUSA] No, bueno, no importa. 0% paqueto 2. Bueno, pero en definitiva, ¿qué queremos ver con esto? Queremos ver la secuencia... ¿Cuántos routers está más o menos en este destino? Digamos el pong. ¿Cuántos routers pasó? 1, 10, 100. [PAUSA] Ojo que no hice un traceroute, no voy a hacer un traceroute ni un mtr. [PAUSA] Y el time to leave era... Ahí no sé qué es 46. ¿Cuál era el default? Default era 64. Bueno, eso menos 46. Perfecto, perfecto. Es decir, unos 18, 20ish. ¿Sí? Más o menos. Eso, ojo, que este tl es del pong. Es decir, justamente del echo reply. [PAUSA] A ver si puedo esto mejorarle un poquitito. Voy a hacer una cosa para no presentar completo y no tener que insultar a este sistema operativo nuevamente. Voy a hacerlo así. Bien. Es decir, el echo reply este, que es un paquete fresco, la relación que tiene con el anterior se cocen entre los dos en base a tener source IP y destination IP cambiada y tener el mismo número de secuencia y tener el mismo tipo de protocolo. Es decir, 10 IP con el tipo este, nada más que 0 a 8. Pero este es un paquete de tipo 0 porque es un echo reply y que por default, asumimos que quien me hizo el pong le puso la misma cantidad de nafta que dicen los default de las RFCO, de 64. Por lo tanto, ha gastado 18 hops para llegar hasta acá. Bien, buenísimo. Bien, ping, ICMP es un caso particular de códigos, tipos de mensaje para diagnóstico. Bien, vamos al próximo que es uno de los más interesantes para explorar. Destination Unreachable. Destination Unreachable es justamente la red feedbackeándome diciendo, bueno, no puedo llegar a este destino. Más allá de esos cinco casos, lo que tienen súper interesante es que son casos, es el mismo tipo de error reportado, pero son casos profundamente distintos los escenarios en los cuales ocurre eso. Y ustedes, ustedes, para que apunto bien con el dedo así los inculpo, ustedes me van a decir qué diferencia hay entre esos casos. Vamos a empezar, ¿qué sería un destination network unreachable? Si yo estoy haciendo un, ojo, no un ping, estoy haciendo una conexión TCP, he hecho HTTP, etc. y estoy tratando de ir a un host destino con TCP y de pronto alguien me empieza a tirar destination unreachable network unreachable. Que no puede alcanzarlo. Ok, pero... La red no está adaptada a la rutea. ¿Qué significaría que, ajá, que es la network unreachable si lo comparamos, por ejemplo, con el que sigue? Por cierto, eso está en excepto el DF=1, que es un caso particular, que ya lo hablamos un poquito en la clase pasada. Net host protoport están como ordenados en cuanto al ámbito, ¿no? Mientras más grande todos los destinos que describe no reachable, hasta más chiquititos. Entonces, ¿qué sería network si lo comparáramos con host unreachable? Y network, por ejemplo, que se yo, quiero ir a la red 10.0.1.0, por ejemplo, no sé, /24, que quiero ir a esa red y no puedo, no puedo llegar porque no conozco el camino. Bien. Y el host sería sé llegar a esa red, pero no puedo llegar al equipo en específico. Bien, buenísimo. Muy buena aproximación. Efectivamente, es decir, tener presente que vos dijiste, pusiste un ejemplo, /24, que yo no tengo ese destino. Yo como router estoy en el medio de la cadena y me están pidiendo entregar este datagrama a un destino del cual yo no tengo ruta. Me está faltando una ruta entera. Yo no sé, quizás no sé si sea un /24, un /16, pero el tema es que yo no sé cómo busco en la tabla de ruteo y no tengo entrada en la tabla de ruteo. Es decir, bien hemos visto la tabla de ruteo, no tengo un default route, o bien podría ser que tengo una entrada en la tabla de ruteo específica a ese destino y tengo el link caído. Es decir, mi Ethernet link, por ejemplo, para llegar a ese destino está caído. Yo tengo entrada, me dice que la /24 está atrás de este link, pero está caído ahora. Entonces, no. O bien puede ser que directamente yo soy un router grandote, de esos que no tienen ruta por default, y sencillamente si se la busque, me retorno nada. Es decir, que yo como quien responde eso, y acá está interesante ver quiénes van respondiendo ese código. Es un router en el medio que sencillamente no puede hacer que ese datagrama siga su viaje. Porque no tiene una ruta, o la ruta está en una interfaz caída, como para que siga su viaje. ¿Qué diferencia tendría entonces con el próximo? Enfoquémonos ahora en Host Destination and Reach Out. Vos lo describiste bastante bien. ¿Cómo se presentaría ese escenario de que "Tengo ruta, pero no está el host, ¿qué pasó acá?" ¿Qué se les ocurre? Que no hay... No, no, dale, dale vos. Que no hay un host al cual se le haya asignado ese IP. Pero ¿cómo puedo estar tan seguro de eso? ¿Cómo puedo decir tajantemente... Yo, escenario es, acá el router, ¿no? El que dice "Che, no, esto es Host Destination and Reach Out en realidad, no es Network Destination and Reach Out, es Host". Pero ¿por qué puedo decirlo tan tajantemente? Decir "No, no es que sea la network, no es que no tenga ruta, es que el host no está". ¿Cuál es mi relación con ese host final como para poder decir tan taxativamente "No, el host no está"? Porque a la red sí se puede llegar, por ejemplo, llegamos al router y el router busca al host al que le pertenece, digamos, ese atarama, no lo encuentra, entonces responde... Pero tenés cuidado con lo que acabás de decir. El router no busca al host, que tenga una ruta específica del host. Busca un match en la tabla de ruteo. Si tiene un match en la tabla de ruteo y el link está arriba, seguro ya no es network, ¿no? Es decir, que encontró ruta, bien. Pero sin embargo, es capaz de decir "No, mirá, es el host el que no está". Entonces, la pregunta es ¿cuál es mi relación, yo como router, que respondo "host destination enriched" o "al origen", ¿cuál es mi relación con el host final? ¿Por qué puedo decir tan certeramente "No, no está el host"? Porque le mandamos el paquete y no responde. Y en qué momento... Bien, bien, bien. Pero en qué momento, de pronto, ¿cómo puede ser que un router ahora se ponga en súper académico y decir "Ah, no, le mando un paquete, no respondió". Cuando hemos dicho siempre que los routers, en realidad su problema es enviar el paquete y olvidarse. ¿Por qué ahora, en este caso, me dices "host", ¿qué le está pasando a ese router que no pudo así como desenvolverse el problema de reenviar ese paquete al próximo saltito y olvidarse? Y listo, y vamos con la próxima. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete, porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Por qué no me mandas el paquete? Porque no me mandas el paquete. ¿Qué tiene que ocurrir si es mi vecino el destino final? Porque no me mandas el paquete. ¿Cómo hago yo para entregarlo? Porque no me mandas el paquete. ¿Si es vecino mío? Por la red, por ejemplo, internet. Ok. ¿Y qué? ¿Lo "pfff" al casteo? ¿Así? No, si yo ya sé quién tiene señal de IP con una MAC. Bueno, si lo sé. Y si no lo sé, aún. Pero yo sé que es mi vecino. Y por ser mi vecino, cambia mi problema. ¿Sí? No tengo que pasarle el datagrama a otro router porque este ya es destino final. Es mi vecino, entonces voy a tener que preguntar. Eso lo vamos a ver ahora un ratito. Con un protocolo que se llama ARP voy a tener que resolver el mapeo de IP a MAC. Porque ahora sí, ya al ser mi vecino, yo tengo que encontrar esa MAC para poder hacerle el únicas y enviarle ese paquete al host destino final. ¿Sí? Es un esfuerzo distinto a enviárselo, es decir, el esfuerzo de resolución es más o menos el mismo enviárselo a otro router porque voy a tener que resolver la MAC. Pero el problema es distinto porque generalmente, yo como router final de toda la cadena, en el cual tengo potencialmente varios hosts en esta red final, yo voy a tener que resolver si este paquete, por ejemplo, está regresando, está siendo enviado a este host 1, host 2, host 3, host 4. Yo como router final de esa cadena voy a tener que tener ese mapeo de la IP a la MAC de cada uno de estos. Y si no lo tengo, voy a tener que construirlo. Voy a tener que ver cómo lo resuelvo. Y ese proceso de resolución puede tomar varios milisegundos. Con el protocolo de ARP. Entonces, ¿y cuál es el escenario entonces en el cual yo como router puedo decir, ah, no, host destination not reached. No respondió al ARP. Claro, o hubo algún tipo de timeout. Efectivamente, nadie respondió. Cuando yo grité, che, ¿quién tiene esta IP? Che, vecindad, ¿quién tiene esta IP? Y yo ya sé que es mi vecino. Clic, clic, clic, clic, clic, clic, timeout. Entonces, yo como router final, que yo sé positivamente que es mi vecino, respondo al origen no host destination reached. Se entiende, ¿no? Es muy distinto a buscar en la tabla de routeo y no encontrar un match y devolver network destination reached. Encontrar un match y ver que la interfase que me sale a ese prefijo está caída. Muy distinto al escenario. Siguen siendo los routers los que lo responden, pero es muy distinto. Vemos protocol destination reached. Este es un poco más difícil de tragar porque, ¿a qué se refiere con protocolo? Como protocolo de capa de transporte. Esto sería, por ejemplo, el caso, poco usual, porque la tecnología hoy en día nos ha puesto en otra situación, pero imaginemos que tenemos un, no sé, un censorcito súper básico de mínimo, mínimo costo, con muy poca memoria, súper optimizado, que es capaz que yo le puedo tirar un paquetito UDP y que me responda los valores de medición, no sé, de caudal de agua, de temperatura, no importa lo que fuera, en un paquetito UDP. Pero para ahorrar costos, no le he puesto una RASPI, una Raspberry Pi, ¿no? Sino que, como tengo que poner muchísimo, solamente tiene implementado el stack, tiene implementado lo súper básico. La capa de enlace, cualquiera sea con la que llega, puede ser radio o algún tipo de, no sé, Ethernet o Wi-Fi. La capa IP, UDP y una súper mini aplicación, que es esta que hace esto que yo les estoy comentando, que yo le puedo preguntar y me devuelve así un paquetito muy simple con las mediciones que tiene en el momento. ¿Qué va a pasar cuando yo intente hacerle un SCH a ese censor? SCH, SCH corre sobre TCP, ¿sí? Protocolo de transporte, que ya lo veremos, heavyweight, con timers, con corrección, con reenvío, con un montón de reglas. Cuando UDP es prácticamente, le agrega puertos a IP, UDP. Literalmente es así. UDP, lo vamos a ver, capa de transporte, es ponerle un par de puertitos a IP y sale con frita. No tiene retransmisión, no tiene timing, no tiene secuenciado, no tiene nada. A la capa IP ponerle una cascarita para que pueda usarse para transporte. Súper simple de implementar, pero súper simple. Entonces, yo voy a intentar, voy a decir, "ah, mira, este censor está caído". A ver, SCH, censor, @, la IP del censor y ¡pam! Protocol Destination Enrichment. ¿Quién me está respondiendo y quién me está respondiendo? Ya medio que me spoileé la respuesta, pero me gustaría que ustedes me lo digan. El host responde que ese protocolo no lo tiene soportado. Exactamente. Fíjense, acá está interesante porque es otra entidad de toda esta cadena quien responde. Antes habíamos visto los dos casos anteriores en el que respondía el router. En un caso el router sin ruta o caída y el último router vecino que dice "no encontré el destino que me pediste". Y acá el protocol Destination Enrichment, en realidad lo responde el host final y dice "yo no sé ese protocolo". "Mi no saber TCP", te dice el censorcito que solo implementa UDP. ¿Sí? Entonces, ¿qué chances de corrección tiene el origen? Ninguna. Lo mismo que en el otro caso. Acá el origen a lo sumo, en los otros dos casos, lo que puede hacer es bajar el ritmo de retransmisión. Es decir, host origen con network y con host Destination Enrichable puede decir, "ah, bueno, puede ser momentáneo este problema". En vez de retransmitir con tanta furia, yo le bajo el ritmo de transmisión cruzando los dedos que alguna vez se levante, se da la red o el host. En este caso, protocol Destination Enrichable te tiene que dar, puf, chau, no, listo. Muy poco, no voy a esperar hasta que alguien instale el TCP en ese host destino. Me dice que ese host destino no tiene protocolo, ya está, game over. No puedo hacerle ese SH a ese censorcito. Se entiende, ¿no? Fíjense cómo es de distinto. Lo que es raro, si quiere interesante, es que están todos dentro del tipo 3, como dice ahí. Están todos dentro del marco de no, yo red o conjunto protocolos no pude hacer llegar este datagrama destino. Vamos al próximo. ¿Qué será port Destination Enrichable? ¿Quién lo responderá? ¿Qué les parece? También el host. También el host, sí, sí. También el host y cuál es el, casi trivial, pero cuál es, qué es lo que observa el host. O qué es lo que intentaste hacer vos y por qué el host te dice port Destination Enrichable. ¿Y quise entrar para algún puerto que no está habilitado? No usemos la palabra habilitado, que no tiene ninguna aplicación asociada, que no está escuchado, que no está bindeado, no es una palabra en español, bindeado, pero no está tomado por alguna aplicación o servido por alguna aplicación. Habilitar o no habilitar, eso ya es otra historia, ¿no? Pero digamos, no hay nadie atendiendo en ese puerto. Entonces el host destino me dice, ¡pum!, no, ese puerto no hay nadie atendiendo, sorry. Y generalmente la actitud de quien intentó consumir ese puerto, intentó conectarse a ese puerto, es decir, game over, chau, no hay. Vamos a ver, vamos a ver sobre esto cuando hagamos TCP, porque TCP tiene su propio modo de hacer esto, así que eso se aplica solo para UDP y algunos otros protocolos, no para TCP. Pero no vamos a meter en eso, lo vemos luego. Y ahora me callo y alguien me explica el último porque ya lo vimos en la clase pasada. ¡Ah, qué bueno! Me voy a tomar unos mates. Y ese es el que hablamos de do fragmenting, que era uno, cero, para los routers saber si podían fragmentar los datagramas y que habíamos dicho que eso no tenía que poderse fragmentar. Bien, Df=1, recordemos lo escribe, es imperativo, y lo escribe quien inicia ese datagrama. Un host origen, contra un destino, dice, red, no me fragmentes esto. Tiene un campito específico, lo vimos en la clase pasada, es un campito que está acá en los flags, donde lo prendo en uno y yo le ordeno a la red que no me fragmente. Tenés la orden de no fragmentar. Si tuviera que fragmentar, por eso es "should fragment", directamente ese router lo descarta. Lo descarta y el mensaje que me viene es, el destino no se puede alcanzar porque debería fragmentar. Vamos a ver si lo podemos replicar a esto. -62000, no se me sale. -2, vamos a ver si estoy seguro que me va a alcanzar. ¡Ah, miren esa belleza! ¿Qué comando hice? ¿Se ve? Estoy compartiendo la pantalla completa, ¿cierto? -Sí, sí, se ve. -Perfecto. Ahí básicamente, ¿qué fue lo que hice? Hice un "mamping", ya saben, para ver las opciones, busqué ahí el Df, que es lo que estamos viendo ahora, "on fragment", y ahí busqué la opción, a ver cuál es la que es -m la opción, y "mdo prohibit fragmentation", "given local one". Vamos, esta es la local. Fíjense que esto me está dando algo interesante. ¿Dónde está esa "mtu"? Que esto no es una propiedad de ICMP, sino más bien de cómo Ping me está mostrando eso. "Ping local error message too long mtu" -En el propio host. -En el propio host, sí. De hecho, si ustedes lo ven acá, si ven acá las interfaces, van a ver, eso fue un IPA, acá te dice clarito "mtu 1458". Eso es porque al estar estas interfaces dentro de un mundo cloudístico, tenemos que encapsular, estamos usando VLANs para materializar las redes virtuales dentro de esta cloud, y no tenemos soporte más allá de 1500 en la tecnología que conecta los nodos que soportan la cloud. Si tuviéramos, podríamos hacer "jumbo frames" de 19000 y poder cargar 1500, es mtu 1500 en nuestras máquinas virtuales. No es el caso, por eso hemos tenido que disminuirla para poder meter ahí las cabeceras de encapsulamiento de VLAN, que es lo que estamos usando para materializar las redes virtuales que usamos en la cloud. Por eso es que tuvimos que "comernos" un pedazo del mtu para poder poner esas cabeceras del VLAN. Por eso es que, ahí me está diciendo clarito, vamos a ver si nos funciona la otra opción, si hacemos "mamping" y buscamos "df", acá me dice, ese yo usé la opción "do". Vamos a probar "want", a ver si logramos que este salga, pero yo es posible que... No, porque con 2000 no va a salir. Ahora vamos a intentar 1458. Creo que no va a pasar, tenés suerte porque esto es tamaño de pelo. ¿Qué pasó acá? "Truncated" ¿Qué significa eso? "Truncated", está diciendo que ha venido truncado, que esto ha podido hacerlo llegar, pero se ha truncado. ¿Por qué? Porque algo interesante que no está relacionado con ICMP, sino con cómo está implementado el ping y el pong, es que si ustedes... A ver... "Profe, ¿y por qué el TTL está en el top?" A ver... Ah, qué buena pregunta. Eso, qué bien, buena observación. Capaz que... Sí, capaz que Google no está respetando la de 64, es una recomendación. Una fuerte recomendación, pero no es una obligación. Capaz que habría que ver a cuánto estamos. En IPv4 de Google estamos a 12 hops. Así que 114 más 12 está usando, más o menos. Capaz está usando 128 o algo por el estilo, está duplicándolo. Pero uno tiene la posibilidad de cambiar ese default y se ve que así están corriendo las puntas de Google, las puntas que me está respondiendo el ping. Ah, no, aquí iba con esto. El ping es muy interesante porque... A ver si me permite ver... "Show payload" "Payload" "Content" ¿Alguien, por favor, que me haga un ping? Recuerden el IP, esta es la 10.200.1.3.2.2.5. Pero háganme el ping. Voy a TCPAMPAR y voy a TCPAMPAR un poco más violento. Voy a TCPAMPAR lo completo. Ya lo corro. Pero háganme un ping de tipo... "ping -pattern deadbiff" A ver si funciona esto. Ahí está. Este ping, lo que pasa es que alguien que me haga un "ping -p deadbiff" a mi IP que es 10.200.1.3.2.2.5. Necesito que alguien, por favor, me haga eso. Yo voy a TCPAMPAR acá esto. ¿Mando? Sí, sí, sí, ahí vamos. Ahí yo te hice. Eso quería mostrar. ¿Qué está ocurriendo ahí? Fíjense la cantidad de biff muerto que está viniendo ahí adentro. ¿Sí? La 270 me está haciendo ping, la 225. Y deadbiff, deadbiff, deadbiff, deadbiff, deadbiff. ¿Qué ocurre? Cuando ustedes pusieron el comando "ping -p" ustedes han decidido un patrón específico que quieren enviar porque lo que hace el Pong es replicarme el mismo patrón. Y eso me sirve a mí para detectar si hay "byte flipping" o si hay "byte flipping" en el patrón. Si hay "byte flipping", es decir, si hay bytes en la red que se estén cambiando y el comando "ping" espera que el Pong le replique, al esperar que el Pong replique exactamente lo mismo, se observa algún cambio, dice, acá en la red, acá hay algo que ha cambiado. Yo pedí que me reflejara este mismo contenido y no me lo hicieron. Fíjense, hágame un ping, por fa, ahora distinto. Hágame un ping menos, como era el tamaño, siempre me olvido. Menos "s", va. Un ping menos "s" 200, por ejemplo. Y sin el deadbiff. Voy a poner "tcpdump" con hexadecimal. Fíjense lo que está haciendo el ping. Fíjense que acá me mandó el diccionario, el diccionario me mandó letritas una tras otra. Lo que hace el ping es cargar su contenido justamente con esta secuencia, va mandando todos los bytes uno tras otro. Esto es obviamente el hexadecimal 14, 15 y 16. Me manda todo en secuencia con la idea de explorar todos los caracteres y que el Pong, fíjense que el echo request, que es el que vino acá, ustedes enviándome un ping a mí, el que me llega a mí, viene con esta secuencia de caracteres y yo como Pong, que hago el echo reply, estoy obligado a responder la misma secuencia de caracteres. Eso nuevamente es como para ver si la red está pasando bien el contenido de los autógrafos. Bueno, te lo quería mostrar. Esto nos debíamos un poco, pero era como para tratar de, lo que hicimos acá, lo que sí nos anduvo era este emdo, como para ver qué ocurría si yo intentaba enviar un ping más largo y hubiera que fragmentarlo. Vamos a la próxima. Otros tipos de acá, interesante para recalcar, echo request ya lo vimos, source quench. Se usaban los primeros, muy inicios tiempos de la Internet y servía para que la red me respondiera, "Che, hay congestión". Si yo estoy tratando, de vuelta, estoy tratando de usar la red contra un destino y alguien, algún router por ahí me dice "source quench, source quench, hay congestión, hay congestión". Y se ha dejado de usar por alguna razón. ¿A ustedes qué se les ocurre? ¿Cuál puede ser esa razón? ¿Cómo podrían abusar de source quench para molestar a sus vecinos? No vecinos de red, me refiero a los que comparten el link del proveedor de ustedes en su barrio, y ustedes saben de la existencia de su source quench y saben que se hace la casa a source quench, ¿cómo lo podrían abusar? Y tirando todo el tiempo un source quench, constantemente. ¿A quiénes? ¿Podría ser a un broadcast? No. ¿Puede ser? ¿No? No. Sería a todos aquellos que yo tendría que averiguar o estimar cuáles son las IP de las máquinas que hay alrededor mío, cuáles son las IP que usan, quizás no para el caso de una vecina del barrio, pero bien puede ser por una red compartida y vos sabés que acá no sé, todos, qué sé yo, usan un particular sistema o usan un sitio en particular porque están todo el día en Instagram por decir algo y yo tengo el set de IPs de Instagram, entonces dibujo ICMP diciéndole, "Mirá, cuando ustedes van a este IP destino de Instagram, la red te está tirando source quench y con eso arbitrariamente hacer que esas máquinas empiecen a bajar el ritmo porque dicen, "Uh, la red está congestionada para cuando yo voy a este IP destino". Esa es la razón por la cual se ha dejado usar básicamente en razón de seguridad. Como en realidad no confiamos en lo que dice la red per se y source quench era un mecanismo así como muy, muy, muy frágil, hoy prácticamente no se usa, pero estuvo ahí en su momento para tratar de hacer que la red me feedbacke de situación de congestión. Vamos a ver que en realidad TCP tiene otros mecanismos para detectar congestión que sí los usa. Redirect es el tipo 5, que es uno de los más interesantes para ver porque hay un juego de... de trío acá, si se quiere al menos. Bueno, a ver cómo empezamos con esto. Vamos a dibujar. Imagínense que esto es una red local, ¿no? Y acá tenemos un par de routers. Vamos a poner el dibujillo del router. Así que estos son dos routers. Y acá yo tengo una... Esto está súper simplificado, típicamente no es así, ya lo sabemos. Acá yo tengo una máquina. ¿Cómo puedo dibujar una máquina con esto? ¿Sí? Acá tengo mi... Bueno, este aquí es más horizontal y un monitor, ¿no? Este es mi máquina. Y resulta que esta máquina tiene... un router que me lleva a internet. Y tiene otro router, como bien estamos viendo aquí. Bien, estamos viendo ahí que hay dos routers que me llevan a la sucursal de San Rafael. Vamos a poner algunos numeritos acá. 132, 138, 01/24, está la red. Y la red donde estoy. Acá a esta le vamos a poner la 10. 10/24. Y le vamos a poner que este es el .254. Internet. Y a este que me lleva a la otra le vamos a poner .253. Siguiendo un poquitito esta convención, que no hay ninguna, es sencillamente esto que a nosotros nos gusta, en particular con Diego, de poner los dispositivos de ruteo en las últimas IP de una red. Bien, ok. La pregunta es, yo estoy acá, estoy parado acá en este... Recordemos, ¿no? La ruta siempre es donde estoy parado, donde quiero llegar y quién me lleva. Esta máquina, al igual que todo el resto de las máquinas, se autoconfigura. ¿Qué deberían tener como router? Por default, imaginando que es un sistema como... Típicamente es un sistema operativo simple, como incluso puede ser de un Android, o de algunos Windows, especialmente Windows más viejos, en el cual yo tengo que decidir ponerle uno solo como router por default, lo que normalmente conocemos la jerga como gateway. Si esto no es una máquina muy, si se quiere, sofisticada, entonces no me queda otra que ponerle uno de los dos. ¿Cuál le pongo? ¿El .253 o el .254? ¿Y por qué? ¿Por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. ¿Y por qué no? Porque si no, no me queda otra que ponerle uno solo. Se fija que la 10 está yendo por la .253, entonces lo manda esa router. Correcto. Sí, sí, lo manda esa router, lo manda la .253. Muy bien. .253 hace su laburo, donde su laburo es reenviarlo acá. Y ¿qué pasará con él? Como esto es una comunicación bidireccional, este datagrama va a seguir de la .2 a la .11 y la .2 a la .11 sigue este camino y se va hacia allá. ¿Qué pasará con el datagrama de respuesta de esto? Si esto es una conexión TCP, es un incremento, regresa, va y viene, como siempre en comunicación direccional. ¿Qué pasará cuando la .11? Yo lo voy a poner otro color porque son los datagramas de regreso. Me falta hacer acá el último caminito. Obviamente acá también hay un router al aterrizar ahí. Lo voy a dibujar para que quede completo. Obviamente acá la sucursal tiene su router. Y obviamente su router acá entonces es vecino. Este datagrama en este sentido sigue así. El router siendo vecino lo entregará a la .11. ¿Qué pasará entonces con la respuesta? Cuando se me tiene que responder en protocolo de transporte, un paquete, si quiere, complementario a esto, que tiene al revés origen y destino. Cuéntenme qué camino sigue. Y va cuando llega a la .253, la manda directo al host. ¿Por qué no va por el otro? Claro, el router ya sabe que es vecino. Es vecino, sí. Fíjense, ¿qué tal se ve este escenario? ¿Se ve bonito? Y no es el mejor, pero... No jodas, a ver, ¿duplicamos el tráfico en la red nada más? ¿O no duplicamos el tráfico en la red? En un sentido. Sí, porque en vez de hacer del .2 ir directo al .253, que sería uno solo, manda dos. Exactamente, es decir, que ocupamos el medio este, medio compartido, como sabemos, medio de internet. Lo ocupamos dos veces. Acá si hay alguien que se puede enojar, como sería mi caso si yo fuera el router .254, estaría muy enojado de que me busquen de queso. Yo soy router, loco, no soy secretario para poder llegar a nuestro vecino, ¿sí? ¿Se entiende, no? Porque me está usando a mí, no me está usando como router. Yo tengo claramente al menos dos interfaces, una de la red local y otra que nos lleva a internet. Y me está usando para levantar un datagrama y volverlo a tirar por el mismo enlace. Levanto el datagrama hacia el destino .11 remoto y lo tengo que bajar por el mismo enlace. ¿Por qué no hablás directamente con el .253, loco? ¿Qué podría hacer yo como .254 muy enojado y decirle a la .2 qué le debería decir? Che, tenés un router por allá. ¿Un router qué tiene? Está bien, tenés un router, pero ¿qué destino? Menos altos, claro, menos altos. Ok, está bien, es el router del destino, pero no le puedo decir al .254, a la .253, le digo, che, tenés un router en la .253 y la .2 va a decir, ¿un router de qué? ¿De qué me estás hablando? ¿Qué info le tengo que dar? Si yo quiero como .254 hacer bien la corrección de .2, si yo como .254 le quiero mostrar el dedito, como en las muestras políticas, cuando ustedes son como... Vaya por la .253, pero ¿qué cosa vaya por la .253? A la red 10. Ah, bueno, now we're talking. Quiere decir que para corregir este comportamiento catatónico, y tengan presente que si acá no hubiera una corrección, o un reporte para que éste corrija, esto sigue para siempre, ¿no? Si acá alguien no levanta el dedito, esto sigue para siempre, y si tengo muchas máquinas que necesitan enviar esto para el destino de la izquierda, nuestra red remota de la izquierda, van a ser el doble tráfico que se envía para todas esas. Entonces, ¿qué ocurre? Acá efectivamente vamos a tener entonces, esto es un ICMP, justamente es el ICMP que estamos ahora enfocados, que es el Redirect, un ICMP Redirect enviado por .254 a .2. Entonces... ICMP Redirect. Y dígame qué debería decir para que tenga sentido eso. Para que no me moleste más ese .2 para ninguna otra máquina de aquella red remota. ¿Qué debería decir ese Redirect? La red de destino y la IP del otro router, digamos. Es básicamente lo que tiene que decir una entrada en la tabla de ruteo, si se quiere. Tiene que decir, mirá, para llegar a ese destino tenés que ir vía... Un segundito. Qué feo que este dedito es por ahí. Ahí vamos. Vía quién? Ya lo sabemos esto. 0.2.53. Acá se da algo interesante y acá completamos la idea de quiénes son las entidades que escriben... No se puede acelerar la cinta, me va a decir un Redirect acá. Eso. Ahí está. Quiénes son las entidades que escriben entradas en la tabla de ruteo. Habíamos visto el humano, de hecho ustedes estuvieron ahí cuando estuvieron haciendo la práctica con Mininet. Ustedes escribieron la tabla de ruteo. El humano, una aplicación, protocolo de ruteo, que vendría a ser, si quieren, alguien que entiende todo el mapa del lugar donde estás y baja las entradas de ruteo para no hacer que el humano tenga que escribir todo. Y ICE, ICMP también. Eso es lo interesante. Fíjense como que de abajo ICMP provoca de pronto que este nodo de pronto tenga esta nueva entrada de ruteo. ¿A quién se le escribió? Se le escribió vía ICMP el que detectó que este Redirect estaba... Estaba... Digamos que esta máquina estaba mal usando este router. Entonces se le dijo, no, no, no, vos cuando quieras ir a la 10.0/24 anda a través de este. Y efectivamente si ustedes observan acá, de una manera especial, van a ver que se ha escrito una nueva entrada en la tabla de ruteo para corregir este error. Anto seguido es obvio lo que va a pasar. Si esto se ha escrito como una entrada de ruteo, ICMP nos hizo el favor de corregir esta entrada y obviamente esto ahora va a ocurrir así. ¿Cómo podrían abusar de esto para molestar a alguien que está en la red? ¿Cómo se ataca esto? Con eso no podría hacer de que todos los paquetes que se envíen primero pasen por mí y después, o sea, por un tema si yo quiero robar información o algo, no podría cambiarle... Dale, dale, veamos ese escenario. Es decir, vos sos un chico malo. Vamos a poner acá con rojo, espero que pueda, no sé si puedo dibujarlo con rojo. Es decir, vos estás acá. Y a vos te interesa hacer hijacking de alguna manera, de algo, de lo que puedas, de la punto 2. Vamos a simplificarlo. Cuando va al destino la 10/24. ¿Cómo podrías dibujar vos? ¿Qué deberías hacer vos para hacer que cuando la punto 2 va hacia ese destino 10/04/24 pase por papi? Por el rojo que está ahí. ¿Qué debería hacer? Debería enviarle un redirect diciéndole que cuando vayas a la 10.0 vía y le pongo mi PIN. Perfecto, buenísimo. ¿Y ese redirect de dónde viene? ¿Cuál es el origen de ese redirect? El host atacante. El punto 4. Y yo como punto 2 voy a decir "ay, quién sos vos punto 4, vos no sos ninguno de mis routers, me estás molestando al cuete". No te creo. ¿Y cómo hago para que punto 4 sea un poquitín más inteligente? ¿Cómo debería dibujar ese redirect? Y miento en el IP de origen. Ah, bueno, tengo que impersonar al router. Impersono al router, que ahí va a depender especialmente de switch ahí, porque hay algunos switch que pueden hacer policing de este tipo de cosas. Tienen un poquitito más, además de ser switches, pero bueno, más caritos, que me permitan hacer este tipo de cosas. Porque ahí yo voy a dibujar un datagrama, una mentira, básicamente construyo un ICMP de punto 4, pero no le pongo como origen yo punto 4. Porque yo punto 4 soy nadie para punto 2. Le pongo "sí, sí, sí, yo soy la 2.54" y cuando vos vayas a la 10.00/24, tenés que ir a través del router que está en la punto 4. ¿Y qué debería hacer la punto 4 entonces? ¿Qué debería hacer para qué? Cuando empiece, porque este, imaginemos que tiene éxito mi ataque, ¿qué debería hacer con las tracitas estas en celeste acá? Con los datagramas que envía la punto 2 a la punto 10. ¿Tragárselos todos y no enviarlos? No, para guardarlos. No, no, debería mandarlos. Si quiero hacer un buen hijacking, obviamente tengo que hacer, así con el halo de inocencia, levantarlo, convertirme en el router ese, y levantarlo, observarlo, guardarlo, hacer la maldad que quiera hacer, y después obviamente hacerle seguir su camino de tal manera que punto 2 no se entere de que estoy en el medio de eso. Y eso sería efectivamente, sería posiblemente un ataque exitoso, a menos que alguien en el medio me haga algún policing de que si lo quiero hacer bien, bien, bien, además de escribir ese paquete, yo soy la punto 4, la roja, ¿no? Además de decir, che, esto viene de la 2.54, pero no solo debería hacerle IP, además, ¿qué debería ponerle como origen 2.54 para hacerlo creíble? La MAC de 2.54. Para hacerlo más parecido, tengo que impersonarlo en todas las capas, ¿no? En capa 3 sería ponerle IP origen y en capa 2 sería ponerle MAC origen del router, que yo la puedo saber. Pero ahí es donde me las puedo ver con un switch que diga, ¿cómo que está viniendo una MAC origen acá? Si yo sé que vos no estás acá, sabemos que el switch memoriza las MACs. Entonces ahí puedo, dependiendo de cuán elaborado sea el switch, cuánto este tipo de protecciones tenga para hacer anti-spoofing, se llama eso, el switch mismo puede rechazar que vos dibujes una MAC que no te corresponde. Porque ha aprendido del intercambio bidireccional que vos no sos esa MAC. Y de pronto me estás enchufando una MAC que yo he aprendido positivamente que está en este otro puerto. Entonces el switch mismo te puede llegar a rebotar a esa trama y tirarlo al piso. Y ahí está la diferencia entre switch que compro en un blister en Electrónica Mendoza, versus un switch que compro, no sé, en una casa de distribución o en un mercado libre que me sale 10 veces más. ¿Y qué pasa si ese switch arranca y encuentra que tiene la misma MAC en dos puertos? Dependería de la tecnología del switch, pero capaz que se deagradea flooding. Generalmente más que flooding, en los dos va a ir flipando entre uno y otro. Si es lo más básico, ahí sí funcionaría el ataque, digamos, porque no tiene memorizada la MAC. Y si lográs sobrescribir al router con más tráfico, es posible que lo fullees, es decir, que lo tontees al switch para que crea que vos sos esa MAC. De hecho, acá hay una gran comunidad de amigos en Ethernet. Somos una comunidad de amigos, y acá estoy poniendo un enemigo. Ethernet, en general, igual que IP sin mecanismos de autenticación o de securización como IPsec, es una gran comunidad de amigos. Así que sí, totalmente. De hecho, cualquier sistema operativo te permite hoy, con las placas que tenemos hoy, cambiar la MAC que estás usando, se llama cloneo de MAC. Generalmente, vos directamente podrías plantearte acá, en vez de ponerte con todas estas cosas de ICMP que aprendí en teleinformática, le planto la MAC del router así, violento, porque la placa me lo permite, y empiezo a tirar mucho más tráfico a la red, me comporto como un router para, por decirle, ganarle a ese router. Puede que tenga éxito o no, va a ser mi problema después, como llego al router, si tengo la misma MAC del router y creo, quiero que estos datagramas tengan éxito, porque voy a tener que escribir, ¿cómo voy a llegar al router? Yo le piso la MAC al router, yo. Si quiero impersonar el router 254, después ya no me puedo comunicar con él, porque le estoy robando su MAC. No tengo manera de mandar un unicast de mi misma MAC a mi misma MAC, pero no es mi MAC, es la MAC que está allá, en aquel puerto. No es posible. Entonces, bueno, no es foco, no es una materia de seguridad esta, pero sí es interesante que veamos las consecuencias que tienen algunas decisiones. Este es un protocolo simple, una corrección simple, y que por ser simple y efectiva, pero deja un montón de espacio para potenciales ataques de este tipo. Y se los menciono porque es un ataque que ustedes pueden llegar a sufrir cuando estén implementando algo como esto. Y de paso nos permite entender un poco más el rol y cómo funciona. Vamos al próximo. Esto está... acá hay un problema de... Bien, el 11 ya lo conocemos. ¿Cómo me traducen al coloquial el 11 para ttl=0? ¿Qué caso es ese? De vuelta a la red, corrigiéndome, me manda un 11, time exceeded in transit. ¿Qué? Dale Javi, vos. Es el que se echa del paquete, digamos, porque ya está como perdido. No es como perdido, es algo muy específico. Ha quedado como en un loop que está saltando entre varios routes. Puede ser, o sencillamente podría ser un loop. Yo no sé qué ha pasado. Lo que sé es que se le terminó el ttl. Esto que nosotros le llamamos la nafta, es 64 por default. Ya sea por un loop, que puede ser, o porque sencillamente quien escribió el ttl en origen, de hecho lo hacemos explícitamente cuando hacemos un comando trace route, como hemos hablado mucho, el mtr, le vamos poniendo distintos ttl, 1, 2, 3, 4, para descubrir la red, y ahí no hay ningún loop, es sencillamente una cuestión de diagnóstico. Y efectivamente el router que lo tira, porque dice "se le terminó el ttl", se le acabó la nafta, este datagrama, envía un 11 de regreso. ¿Sí? Time exceeded in transit. Time, time, ¿sí? De vuelta, esto está mal. No hay tiempo acá, es hops, cantidad de hops en este caso. Lo que es interesante del otro, que el otro sí, es time. Fíjense, el tipo 11 en realidad contempla dos casos distintos. Un caso es el que hemos hablado muchas veces, que se le acaba la nafta, el router lo descarta y envía un mensaje al origen. Y el segundo también lo hemos hablado. ¿De qué se trata el segundo? Está ahí. Se quedó mucho tiempo esperando y... ¿Esperando qué? El... fin de la... no. Uy, se me olvidó. Un fragmento, se quedó mucho tiempo esperando un fragmento. Exactamente todo lo que estuvimos discutiendo el caso del pasado. Se rompió en pedazos un datagrama, llegaron, viajan los fragmentitos y el destino no pudo comprender todos los fragmentos para reconstruir el datagrama. Hizo timeout, entonces el host destino le dice al origen, "Mirá, acá no pude reensamblar los fragmentos de este datagrama". ¿Sí? Bien. Seguimos. Parámetro problem es... Loco, no sabés escribir el protocolo. Parámetro problem es cuando le pones algo inválido. ¿Sí? Ahí también, por una cuestión de seguridad, puede ser que lo responda o no. Es una decisión un poco del host destino. Dependerá. Dependerá, pero puede ser cuando yo estoy escribiendo la cabecera de un protocolo, por ejemplo, le he puesto justamente un campo, sería "field invalid", sería el parámetro problem, entonces el destino puede llegar a responder "Mirá, me has enviado un datagrama que tiene este problema de parámetros. Aprendé a escribir el protocolo". Si eso es lo que me está diciendo. No es muy usado realmente. TimestampRequest y TimestampReply están en el mismo ámbito, más o menos, del Echorequest y Echoreply. Y, en realidad, se puede usar para medir timing, aunque ya con la sobrecarga de data que tiene Echorequest y Echoreply ya se puede hacer timing. Básicamente, el 13 en el 14, el 13 lo que le pone es estampa de tiempo donde estoy yo, y le pide al destino que cuando le responda le copie la estampa de tiempo para hacer una medición mucho más precisa de a qué distancia de tiempo estamos nosotros dos. Yo con mi destino. Poco usado. Se puede usar también, pero en realidad, como se usa ICMP, Echorequest y Reply suele ser suficiente. Así que uno tenga alguna herramienta que lo termine usando esto. No sé si ping puede flipar. El comando ping, la implementación puede flipar a eso. IP, no, pero es de capo IP, no es ICMP eso, no. Seguimos. Bueno, básicamente y con esto completamos ICMP. Antes de cerrarlo, entonces queda bien claro el rol que cumple ICMP. ICMP ahí como un protocolo de, ya sea de diagnóstico o de reporte de error que le permite a la red expresar condiciones anómalas para quienes usan la red podrán corregir esas condiciones. Vamos a ARP. ARP es... Lo hemos hablado indirectamente muchas veces y básicamente responde a esta pregunta, ¿no? La pregunta es, ¿quién tiene, quién de aquí? Y alguien me va a decir a qué me refiero con de aquí. ¿Quién de aquí tiene este IP? Y alguien levanta la mano, me hace un reply y me dice, "Che, yo estoy en tal MAC". ¿Qué sería ese de aquí? ¿Quién de aquí? ¿A quién me estoy refiriendo con el de aquí? De esta vecindad. ¿Quién de...? No, de cualquier lado del internet, ¿no? Porque obviamente el problema de MAC de capa 2 es solamente mi vecindad. Entonces, yo le pregunto a mi vecindad, ¿quién de aquí tiene esta IP? Y veamos cómo... Yo voy a... Para poder ver cuáles son las máquinas de mi vecindad que he aprendido, puedo usar el comando ipnate neighbor. IPN. ¿Sí? Y eso básicamente le estoy preguntando a mi kernel de mi máquina, ¿cuál es...? ¿Quiénes de mi vecindad he aprendido? A ver, ¿quiénes me pinguearon? Me pinguearon... ¿No me pinguean, por favor? Ahora, porque quiero mostrarles lo que pasa. Oh, demasiado. ¿Vos me tiran algún IP? Pero no me hagan ping, porfis. ¿Me dicen algún IP de los vecinos acá míos? ¿De los que están guardados? No, IP de ustedes. Tírenme un IP. 10.201.3.83 3.83, gracias. Yo voy a dejar corriendo en background. TCP Dump, con lo cual acá las alias se van a mezclar un poco, pero bueno, como parte también de lo que tenemos. Voy a hacer un solo ping. Ahora, 10.201.3.53, ¿me dijiste? 83. Fíjense que lo que pasó ahí. Ahí se mezcló un poco, ¿no? Estas son las... Este es el ping mismo. Voy a cortar. Se ha mezclado el ping, que es este, con el TCP Dump, que está acá. Pero fíjense qué ocurrió. El TCP Dump yo había dejado corriendo en background, con este simbolito, este ampersand. Un TCP Dump le había dicho, "Dumpeame de la interfaz de internet todo lo que sea ARP, por lo cual lo estamos viendo ahora. Y acá está justamente lo que escribió ARP. Básicamente yo tuve el problema de decir, "Bueno, mi máquina, mi kernel, que implementa IP, y obviamente hemos hablado de todas las capas de protocolo de estacto de cipa IP, las capas de transporte para abajo. Cuando voy a mi vecino 383, tengo que resolverlo, tengo que ver dónde está. Entonces yo mandé un request. ¿Quién tiene la 383? Dijo quién. Yo, esta es mi IP. Y acá alguien me hizo este reply. Díganme, estos paquetes, ¿son los dos de broadcast? ¿Son los dos de unicast? Respecto de ethernet. >> Uno es broadcast y el otro es unicast. >> ¿Cómo, cuál es cuál? >> El que uso para preguntar quién lo tiene, ese es broadcast. >> Ajá. Eso es obvio, ¿no? Porque obviamente al no saber quién lo tiene, estoy preguntando a quién, así que lo broadcasteo a toda mi vecindad. Ahí lo vamos a confirmar como broadcast, aumentando un poquitito el TCP AMP. Y el otro, quien responde, ya no hace falta que él responda a toda la vecindad, porque ya aprendió todo de mí. Yo pregunté, "Che, ¿quién tiene la 383?" Y la 383, que la recibió en broadcast, lo levantó, ya sabe quién preguntó, por lo tanto responde con unicast. No hace falta que responda con broadcast. Y recordemos, broadcast también es otro de los caca nene, no usar a menos que haga falta, y en este caso hace falta en el primero, pero no en la respuesta. Yo voy a sobrecargar un poco. Voy a limpiar de vuelta, ese es un flush de mi tabla de vecindades. Fíjense que el único que me quedó reachable es el router por el cual yo estoy entrando, así que tiene que haberlo resuelto. Yo hago un flush, pero ha seguido, ya reachable por el intercambio de paquetes que yo tengo contra este host, no le queda otro. Voy a hacer el mismo ping, el mismo TCP AMP antes, pero le voy a agregar un parámetro que es -e. -e es para que muestre las cabeceras, el encapsulado de capa 2. Vamos a hacer el mismo ping. Fíjense qué ha pasado ahora. Fíjense que ahora, si buscamos acá donde dice ARP, que es esto de acá, se ve bien clarito que acá una Mac, que es la mía, tiró un broadcast a todos. Oh, come on, eso fue por selección. Tiró un broadcast preguntando quién tiene esa, preguntó yo. Y acá hay un únicas de respuesta, esto que está acá, donde justamente ese únicas viene hacia mí, desde el destino que lo tiene y dice, la 383 está en esta Mac. Entonces, ¿qué es lo que hace este host, mi máquina? Lo que hace es efectivamente guardarlo en la tabla. Acá está él porque como no lo he vuelto a usar, está ahí abajo para confirmar. Él quiere decir que lo escribí, vamos, que lo escribí, pero que no he tenido mayor, baja interacción como para confirmar que sea cierto. Sí, cuénteme, pregunta. Ahí responde que, o sea, is@ y la Mac. Sí. Pero vemos en la cabecera que responde una Mac. Eso es porque puede responder otra Mac diciendo quién tiene. Es una cuestión de, bueno, ARP tiene en realidad otros usos que respondería mejor a tu pregunta, que no los vamos a ver porque ya se han dejado de usar. Pero en realidad es una cuestión más de encapsulamiento. Podría ser el caso, pero es más para decir que quien desencapsule esto, la interpretación del protocolo ARP, no tenga que fijarse en las cabeceras de enlace por el cual llegaron. Ah, está bien. No tenga que decir, che, capa de más abajo, ¿de quién vino? Sino que sea autocontenido. Digamos, la capa del protocolo ARP va a leer, por decir una manera bruta, va a leer de acá para adelante lo que acabo de editar acá. Entonces, va a decir, listo, ya me lo contiene. No tengo que ir a preguntarle abajo, che, ¿y quién mandó esto? Es más rápido. Por una cuestión de encapsulamiento de protocolos, de layerización, si se quiere. Una pregunta. Esto básicamente es un cache, un caché, ¿no? Sí, ¿no? Es como una especie de base de datos, pero caché, caché siempre tiene involucrado tiempo. Porque acá hay tiempos involucrados. O hagámoslo al revés, yo le digo. Esto es un caché. Como todo caché tiene fundamentalmente dos dimensiones. Tamaño y tiempo. Y quiero que exploremos ambas. Tiempo. ¿Cuánto almaceno esto para siempre? No, yo creo que, por ejemplo, el router lo puedo configurar para que después de qué cantidad de tiempo se vuelva a dar IPs. No, pero eso es otra cosa. Eso no tiene nada que ver con lo que estamos viendo ahora. Entregar IPs a otro protocolo de HCP que lo veremos. Acá imaginemos que no hay, imaginemos por ejemplo, si lo queremos simplificar, que todas las IPs están prefijadas. Están escritas duras en la configuración de cada máquina. No hay un pool de IPs que se entrega. Porque es otro el problema. La pregunta es, ¿cuánto lo memorizo acá? Un microsegundo, diez milisegundos, un segundo, diez días para siempre. ¿Eso no está en el protocolo? No sé, yo quiero que ustedes me digan qué valor puede ser razonable. Muy cortito, mediano, infinito. Unos 30 segundos. ¿Por qué no lo hacemos infinito? No tiene sentido 30 segundos, porque si no cada vez... O sea, si yo al ratito quiero volver a mandarle un paquete a él mismo, lo tengo que volver a preguntar. Bueno, es una razón para que no sea tan pequeño. ¿Cuál sería una razón para que sea una estupidez que sea medio segundo o diez milisegundos? Porque decían, ah no, que dure lo necesario para enviar este paquete. Pero ¿qué va a pasar con el segundo paquete? Voy a tener que hacer todo el esfuerzo. Que es bastante esfuerzo, fíjense que hay dos paquetes, dos tramas que ocupan espacio en la red para resolver esto. No sé si ocupa espacio, bueno, hagámoslo infinito entonces. Ya está. Hasta que no se rebotee la máquina. Claro, sí, puede ser. El tema es que... ¿Qué pasaría en ese caso? Y se podría llenar la memoria. Ponele, bien. Pero es otra dimensión. Yo estoy hablando ahora, discutiendo dimensión-tiempo, no dimensión-tamaño. Ya discutiremos dimensión-tamaño. Dimensión-tiempo. Infinito. No sé... No sé si tiene mucho sentido el tiempo o cuando yo quiera enviar algo a esa IP y ya no tenga esa MAC... Pero entonces, volvemos al problema. Si no tengo esa MAC, quiere decir que lo memorizo cero. Cada vez que envío un datagrama, tengo que hacer el esfuerzo de ARP. No, digo que cuando yo quiero enviar algo a esa IP y no obtengo respuesta o veo que no está, ahí recién volver a preguntar y borrar esa entrada. Yo soy IP y le pido... IP le pide ayuda a ARP para esto, ¿no? Pero vos estás pidiéndole demasiada memoria a IP. IP no memoriza. Bufferea un poco hasta que resuelve y listo, ¿no? Pero IP no tiene tanta inteligencia como lo estás pidiendo vos. Decís "si veo que no me respondieron entonces, no sé qué". ¿Cómo sé yo? A ver, escenario es el siguiente. Este es el siguiente escenario. Lo almaceno para siempre. Con lo cual yo, lo que estamos leyendo acá, este host se quedó para siempre con la idea de que esta IP, la 383, está atrás de esa MAC. ¿Sí? Y cada vez que quiera ir contra la 383, le planta esa MAC y lo envía. IP no sabe si llegó o no llegó. No tiene un feedback. ¿Qué feedback puede tener? ¿Si es protocolo de red? No tiene un hack IP. Entonces no puedo implementar lo que vos estás sugiriendo porque yo no sé si fue, vino. Porque mi misión fue, lamentablemente, como ese es vecino, tuve que resolverlo, lo resolví, lo guardé para siempre, planté la MAC, se lo tiré al switch, fin de mi problema. Ya está. Entonces vamos de vuelta al infinito. ¿Qué problema puede tener el infinito? O no tiene ningún problema. El tamaño de la memoria. No, estamos discutiendo tamaño ahora. Imaginemos una red de 10 vecinos. Ya discutiremos el tamaño. ¿Que cambie qué? ¿Cambie la MAC? Cambie la MAC no es problema porque lo resuelvo de vuelta. Si vos, tu máquina, redeployás esa instancia y me decís "Prof, ahora tengo la .92, listo, la resuelvo, ya está, y la almaceno para siempre". ¿Cuál es el problema acá? Que cambie la MAC. Cambie la MAC manteniendo la misma IP. ¿Por qué? Porque yo me la he memorizado para siempre esa relación. La he escrito con piedra, o hasta que reboté la máquina, no sé. Entonces, al memorizarla para siempre, ya no la resuelvo más. Entonces, si vos, y bien puede ser, y ahora sí se les enero que alguien mencionaba de que hay IPs que van y que vienen. Si estas son IPs que se entregan y que expiran, como generalmente es una red, bien puede ser que venga otra máquina, como cuando ustedes iban a la facultad con sus notebooks, se les prestaba una IP a traer un protocolo que luego veremos, de HCP, por un determinado tiempo, 6 horas, 12 horas, después de la cual, en realidad, ya no tienen más permisos para usar ese IP y ese IP se le puede entregar a otra máquina. Si el resto de la red memoriza que la relación IP MAC, que obviamente la MAC de tu notebook es distinta a la MAC de tu compañero, que en distintos momentos de tiempo obtuvieron la misma IP, obviamente si se almacena esa relación dura en otros que participan de la red, esto no va a funcionar, eso tiene que expirar. Entonces, este ejercicio que solemos hacer para tratar de entender el problema de irnos a los extremos, de qué pasa si es muy muy cortito, y qué pasa si es infinito o muy grande, está bueno justamente porque nos permite encontrar ese compromiso. Y ese compromiso hace que esto, en realidad, sea de unos minutos. No me acuerdo, la RFC, pero en el orden de minutos. Fíjense que todavía está medio "stale" ahí, pero probablemente si nos vamos a recrude y volvemos ya haya desaparecido de acá. Entonces, está en el orden de minutos, más o menos, de esa memorización. Justamente para permitir esta flexibilidad de que la misma IP esté en otra MAC. Como todo caché, entonces habíamos dicho, la otra dimensión, la dimensión tamaño, que esa es más simple y es la que algunos sugirieron. Este caché tiene un tamaño... ¿Cómo debería estar "sizeado" este tamaño? ¿A qué debería ser, entre comillas, "proporcional"? Al tamaño de la red. ¿Qué es el tamaño de la red? ¿El tamaño de toda la internet? No, o sea, la cantidad de vecinos que pueda tener. Bien, ok. Y eso va a estar relacionado con la máscara, ¿sí? Para R24, sabemos que tiene un máximo de X. De todas maneras, esto es KPIP, esto es ARP, pero es como para ver los órdenes de magnitud. A mí me ha pasado de ver ocurrir en redes muy anchas, como bien puede ser esta red virtual, pero ahora, en realidad, con la memoria de esta red es tan ancha como 65K, y probablemente si tuviéramos 60 y pico K, o muchas decenas de K de nodos en esta red, habría problemas de ARP. Perdón, del caché de ARP, de la memoria de ARP, que sencillamente haga overflow. Si yo tengo, y ahí es donde viene ya un diseño de, ¿qué hago? Si yo tengo que comunicar muchas máquinas, si piensan que no necesariamente son nodos, máquinas finales, sino pueden ser dispositivos móviles. Y tengo una red donde va a haber mucho, como puede ser, no sé, una red municipal, ¿sí? Cuando ustedes van y tienen la Wi-Fi de la ciudad de Mendoza en una plaza, Plaza Martín, por decir algo. Y ahí bien puede ser una red de mucha densidad, muchas vecindades, ¿no? ¿Cómo manejo? Trato de crear áreas donde yo tenga distintas vecindades, rutea entre sí, o creo una gran vecindad, y bueno, están estos desafíos. Me puedo encontrar con dispositivos que tienen una capacidad limitada de vecinos, sin embargo, en un escenario como este no se aplicaría. ¿Por qué no se aplicaría ese problema y funcionaría igual? El escenario es este. Ciudad de Mendoza poniendo Wi-Fi, pone una gran barra 16, y de pronto, no sé, hay una manifestación, estamos todos sacando las fotos, subiendo fotos de la manifestación de esto, no sé. 3.000 personas. ¿Es problema o no es problema? En este caso particular, en esta aplicación particular. ¿Cuál es la vecindad que esos Android o iPhone tienen que resolver? ¿Tienen que resolver los miles de vecinos de esa misma red? No, porque no le van a estar enviando datos a todos. OK. Salvo que estemos usando algún tipo de protocolo de mesh o algo por el estilo, en el cual, no sé, estemos usando alguna de estas cosas locas que te permiten compartir directo de dispositivo a dispositivo, encontrarte vos mismo en la red, que no es así típicamente. Típicamente vamos a estar subiendo la fotito a Instagram, mostrando o a Facebook o a lo que sea, o a TikTok, el video. ¿Y para eso a quién voy a tener que resolver en la red? Y al root, al default gateway. Entonces, típicamente estos dispositivos solamente van a tener una entradita que es la del default gateway, porque básicamente la red la usa para encontrar el default gateway y después de ahí enviar los altagramas hacia el exterior y después el default gateway me los enviará a mí y será. ¿De quién va a ser el problema el tamaño de la vecindad? No va a ser el problema de mi Android. ¿De quién va a ser un poco el problema? Del router. Porque el router va a tener una vecindad barra de 16 y sí va a tener que recordarlos a todos. Entonces, sí va a tener que estar preparado para tener grandes vecindades en el caso de este, ¿no? En el caso que tenga que resolver un montón de vecinos a los cuales tiene que almacenar esta relación. Y es importante que no haga overflow, que tenga el tamaño adecuado, porque si hace overflow... ¿Cómo limpia un caché overflows? ¿Alguien conoce cuál es el algoritmo más usado para limpiar un caché por overflow? Tiene tres letritas. No. LRU. Least Recently Used. Ah, sí. Ah, bueno, es un caché. Vos tenés un problema del caché. Recuerden, todo caché tiene las dos dimensiones, tamaño y tiempo. Y de pronto tengo... El caché mide 10 y viene la entrada 11A. Tengo que sacrificar uno. ¿Cuál sacrifico? El más viejo. El más viejo. El que se ha usado menos recientemente. Más viejo. Bueno, lo sacrifico. No al más nuevo. En este caso, porque si no, básicamente siempre estaría sacrificando el que más me sirve. Entonces, nada, es como para mostrarles a ustedes cómo se aplican problemas en general que tienen que resolver en otros ámbitos de aplicación, como puede ser un caché. Pero esto no deja de ser un caché con todos sus problemas. Entonces, volviendo a este caso particular, este router bien tiene que tener dimensionado o preconfigurado para tener un caché de ARP, de solución ARP, suficientemente grande como para el problema que tiene que resolver. Y los dispositivos estos, si se quiere, lo que hablábamos recientemente, dispositivos Wi-Fi, sea un celu o lo que fuera, solamente tienen que tener una capacidad suficiente como para resolver, en este caso, el router de la red. A menos que, como les comentaba, haya algún otro problema para necesitar comunicarse con toda una vecindad. ARP, en realidad, este es lo que sería, lo que acá le hemos puesto ARP clásico. ARP tiene otros usos que ya han quedado como legacy, excepto algunos que están acá. Lo vamos a mencionar este cuando veamos el HCP. Planeamos verlo luego del regreso del recreo, que ya nos lo vamos a tomar acá un break. Hay un par, además, que me gustaría mencionar. Si yo fuera un buen ciudadano, y yo sé que me estoy yendo, como puede ser cuando estoy a punto, entonces, cerrando el lead de la máquina, así, yo podría, tengo la posibilidad de decirle a la red, "Red, olvídense de este mapeo de IP a MAC, porque me fui de esta red". Terminó la clase, yo bajo acá, me voy, y yo ahí, justo antes, en el último respiro, mando un unARP diciéndole, "olvídense de mí, esta relación que ustedes habían almacenado de mí, especialmente el router, que es el que más he usado típicamente, de IP a MAC, olvídense, ya me fui de acá". Eso se sigue usando. La pregunta es, en broadcast, en unicas, ¿qué les parece? Supongo que a los que yo tengo en mi tabla, que me he comunicado, digamos. Quiere decir que cuando estoy cerrando el lead, me estoy yendo, así, suspendiendo la máquina. Si tengo 20 en mi tabla, tengo que mandar los 20, no sé qué, no sé qué. Ah, entonces, en broadcast. En broadcast, y le digo, entre comillas, a la red, a mi vecindad, le digo, "me fui". Entonces, básicamente, ¿y cómo se llama eso en terminología de cache? ¿Cómo se llama eso? De vuelta, no deja de ser un problema de caching. Cache invalidation. Si acá ocurrió una acción, quien conoce la entrada de cache, que está invalidando esa entrada de cache a quienes lo tienen. Le está diciendo "borralos". Es como casi una llamada remota de procedimiento, donde le dice "borra la entrada de cache". Cache invalidation. Ese es el ANARP y tiene ese caso de uso. Y el gratuitus ARP, en realidad es un refresh, para decir, acá estoy. ¿Cuál de los dos será, de los ARP que vimos? ¿Será un request o un reply? ¿Qué les parece? A ver si lo encuentro acá. ¿Dónde está, maldito? Acá. Este. ¿Dónde está el ARP? Este. Acá recordemos que había un request y había un reply. Si esto es un, hay un caso particular, este se llama gratitus ARP. Y es refresh. ¿Cuál de los dos será? ¿El primero o el segundo? Básicamente así como el otro era "olvídense de mí", este es un "no me olviden, por favor". ¿Es una pregunta o una respuesta? No está esperando respuesta, así que no sé. Es una respuesta, es una respuesta no pedida, por eso es gratuitus. Gratitus. Es una respuesta gratis. ¿Quién te preguntó, macho? Pero bueno, yo digo, porque tengo un ego altísimo, como dispositivo, y le digo a la red, "yo sigo estando acá, yo sigo estando acá". Este puede ser un caso de uso de un router, por ejemplo, no se usa mucho, pero podría ser un caso de uso para mantener refrescada la entrada que tienen el cache, las máquinas que me usan, para mantenerla fresquita. Cuando hablamos de LRU, "List Recent Uses", es como para hacer un refresh de esa entrada, y decir, "sigo estando acá, sigo estando acá", para que no expire esa entrada. O sea, hay que encontrar una víctima para expirar, porque LRU no se elija esa, se mantenga calentita. "Warm it up", ¿no? Un cache calentito de esa entrada. Para eso sería un "Gratitus ARP", decir, "yo estoy acá, sigo estando acá", es como una respuesta no preguntada. Y los otros casos son un poco más catatónicos, o ya en el olvido, legacy. Excepto este, que ya lo veremos cuando veamos de HCP, luego que vengamos del break que nos vamos a tomar ahora. Porque ahora ya nos queda de HCP, nos queda ver de HCP, que esto va a ser unos 15 minutos, vamos a ver, relativamente rápido. Y después ya Diego nos va a contar un poco más de la pictura completa del Router Internet, súper interesante, se va a poner un poquito más simpática el tópico. Y 35, volvemos en 15, ¿les parece a las -10? 8, -10, así tratamos de terminar en tiempo. OK. Bueno. OK. Voy a cortar la grabación, ¿sabés? Dale, perfecto. [AUDIO_EN_BLANCO]Gracias, no más, me había pasado. Ahí vamos grabando. Entonces, retomando el tema del juego de buffers de TCP, el lado A quiere transferir, pongámosle entonces varios megabytes de datos, imaginemos muchos megabytes suficientes como para mantener totalmente lleno todo el canal desde A hasta B, ese canal virtual que se establece entre lo que vendrían a ser estos dos sockets, entre este y este. Entonces estábamos hablando recién que si estos son los, acá yo he dibujado sockets de transmisión en verde, perdón, buffers de transmisión en verde corresponden a los mismos sockets, cada socket tiene dos buffers, uno de transmisión y uno de recepción, el rojo el de recepción. Entonces el lado transmisor permanentemente va a recibir un feedback de cuánto espacio de buffer hay libre del otro lado del receptor. Y ese número, 32K habíamos puesto como ejemplo, para hacer el permiso de bytes que tiene el lado transmisor para tener bytes en vuelo a través de la red. ¿Por qué? Porque si yo inicio una conexión, hago el intercambio y leo, "Ah, el otro me publicó 32K", quiere decir que yo tengo el permiso de enviar 32K. Esos 32K no van a llegar instantáneamente, o sí. Si yo envío, ¿Llegan? No, tienen que pasar por los routers. Claro, tienen que pasar por todos estos links, routearse acá, tener suerte de que lleguen. Pero tengan presente que, qué sé yo, el otro día probamos cuántos milisegundos teníamos contra los POPs de Miami, de la costa este de Estados Unidos, y tenemos 100 milisegundos, 120 milisegundos. Obviamente tenemos un bufferío interesante, obviamente dependiendo de la distancia en hops y en, en definitiva, en distancia geográfica también, que hay entre las dos puntas. La red me está haciendo de un gran buffer. Pero los transmisores tienen que agarrar de algo para arrancar. Arrancamos y no puedo decir, "Ah, bueno, te envío". Si la aplicación, la bestia de la aplicación, me acaba de escribir un mega, me acaba de hacer un write al descriptor de socket de un mega, y yo no puedo, como TCP transmisor, decir, "Bueno, lo recorto, voy a redondear ahora en mil". Sabemos que el MTU en realidad es 1,500, menos cabeceras. Lo que yo voy a ahora hablar como un K es en realidad literalmente 1,460 típicamente. Entonces, volvamos. La aplicación me hizo un write de un mega, lo corto en mil pedacitos, en mil rebanados, en mil segmentos de un K, y los tiro así a lo bestia, martillazos, salen mil segmentos de un K desde A hasta B. Mal. Tengo que respetar lo que me dijo B como buffer de recepción. Si me inicio una conexión, y durante toda la conexión, como les decía, lo voy a estar leyendo, pero en el inicio yo reí 32K, y la bestia de la aplicación me escribió un mega, y bueno, recortaré de ese mega que me escribe la aplicación, tomaré los primeros 32K, lo corto en 32 pedacitos de un K, y los voy enviando uno atrás del otro. ¿Y cómo sigue evolucionando esto? Imaginemos ese escenario. La aplicación escribió un mega, el buffer mide solo 32K, todos estos buffers que vemos acá miden 32K, esto estaba vacío antes, yo soy el TCP del lado A, del lado transmisor. ¿Qué ocurre ahora entonces? ¿Qué ocurrirá? Primero se llena este buffer. Tenemos una situación de buffer de transmisión lleno, porque sencillamente, acá el sistema operativo que tiene este socket asociado acá, tiene este buffer de transmisión lleno, y con este buffer de trabajo, que de alguna manera es despertamos a TCP, un hilito ahí en el kernel, o algo en el kernel, que dice TCP, tenés laburo. Tenés este buffer de 32K, tu misión como TCP, es hacer que esos 32K lleguen obviamente al lado RX de B. Entonces, ¿qué hace TCP con esos 32K? ¿Cómo sigue esto? Aunque repite lo mismo que lo que... Lo envía. Nuevamente adaptándose al tamaño de la tagrama. Estamos redondeando en un K, hablamos que no es el número típico, pero lo recorta, por ejemplo, en pedacitos de un K, y los va enviando. Y después, ¿cómo avanzamos? Ok. Resolví los primeros 32K, pero tengo un Mega menos 32K hacia adelante, papi. Yo como TCP de la transmisión del lado A. Tienes que volver a llenar el software de transmisión con otros 32K. Claro, pero ¿cómo lo vacío? ¿Cuál es la condición que me hace vaciar este buffer de recepción? Estamos tratando de ver cuáles son las condiciones que permiten que esto fluya. Fíjense que todo es una gran montaña rusa. Si quieren, de un lado a otro. De TX a RX. RX lo consume la aplicación. ¿Y cómo yo voy despejando el buffer TX? Porque esto no es elástico. Buffer de transmisión no es que se va adaptando y va así estirándose. Es fijito. Entonces, ¿cómo yo despejo espacio en ese buffer de transmisión para poder tener bytes frescos de la data de aplicación para poder ir encolándolos para que vayan saliendo? ¿Qué les parece? Y B tiene que confirmar que le llegó los 32K. Perfecto. Las confirmaciones de B, es decir, acá está claro. La condición sería, tenemos este buffer de transmisión lleno. Lo recortamos en 32 pedacitos de 1K. Ya vamos a ver que eso es mentira, que no es así. No solo en tamaño, sino en la secuencialidad. Pero un detalle que ya lo vamos a ver. Van esos 32K. Y a medida que suben en RX acá, obviamente el TCP acaba haciendo el chequeo. Llegaron bien, llegó bien, llegó bien, llegó bien. Y va enviándole acá acusas de recibo. Y esos acusas de recibo son los que me permiten a mí ir, como hacer este desplazamiento del problema. Mi problema inicial era de acá a acá. Imaginemos que ese fuera un pedacito de 32K. A medida que yo voy recibiendo los acusas de recibo, este segmento se me va moviendo. Es como que, si ha habido un ACK a esta posición. Como consecuencia del ACK en esa posición, lo que va a ocurrir va a ser que esos 32K se me mueven acá. Y yo puedo morder este espacio de diferencia que estoy dibujando acá. Como que inicialmente yo tuve este permiso de 32K. Y se me va ampliando el permiso, no se me va ampliando, se me va moviendo el permiso a medida que se me van ACKeando lo que yo recibo. Fíjense que el ACK es ahí, acá no estoy en la escala, pero más o menos es como que lo que me alcanzó a ACKear a mí acá, es lo mismo que este segmentito de acá arriba, lo que me permite a mí avanzar. Acá estoy en el punto 1, se me ACKea y se me mueve a la derecha. Es decir, esto vendría a ser el punto 1, este es el punto 3. Y vamos a ponerlo acá. Este es el momento 2 con el ACK. ¿Se entiende más o menos? Yo estaba acá, se me ACKea, entonces si el otro lado me dice, "Che, loco, ya recibí los primeros 5K, ok". Yo ya puedo morder, que sería el segmentito de arriba, puedo mover esto y decir, "Ah, bueno, puedo olvidarme de estos 5K iniciales que estaban acá, despejar este espacio de buffer". Y ya liberé de estos 35K, liberé 5K porque el otro lado me dijo, "Ok". Con lo cual yo movería, esto no es así por una cuestión de optimización, pero lo podemos pensar conceptualmente. Muevo estos bytes que estaban acá esperando para salir hacia abajo, me despeja el espacio de buffer, muerdo más de la aplicación y pongo otros 5K acá. Entonces, de alguna manera la misión de TCP es ir avanzando. No quiero decir la ventana porque se puede confundir con el concepto de ventana de recepción, pero este segmentote de problema en el cual TCP dice, "Bueno, mi problema empieza acá, empieza acá". Y de alguna manera siempre hay, esto lo mencionamos, hay como varios punteros en juego, pero hay un puntero. Acá, por ejemplo, es donde empieza mi problema, el que estoy marcando acá, en el momento 3, esto sería para TCP. Acá empieza mi problema porque de acá hacia adelante tengo datos sin confirmar. Tengo en vuelo esto ya, que aún obviamente no ha sido confirmado, por eso estaba antes ahí, pero ya tengo despejado esto porque me acaban de confirmar el mismo espacio al comienzo. Entonces, yo me he podido mover, dado que el otro me está diciendo que tiene una ventana libre, me puedo mover y seguir empujándole datos. Entonces, siempre es un juego de TCP tratando de, el problema que le tira la aplicación, que es una secuencia de bytes, tratando de ir empujándola, en este caso, de izquierda a derecha. Aquí se complica porque en realidad ocurren dos cosas simultáneamente. Ocurre este flujo, al igual que este flujo. Todos los protocolos, no todos, generalmente los protocolos son bidireccionales. Entonces, acá hay como, si se quiere, dos instancias del problema de empuje de TCP, porque T, como habíamos mencionado en la clase pasada, no por nada es transmission control protocol. El problema de TCP es como empujo de data. ¿Se entiende más o menos esto? Era muy importante que lo visualizáramos. Va a quedar más claro a medida que lo vayamos viendo, pero ¿se entiende? Sí, seguro. Sí, va bien. Vamos a abrir una nueva antes de ir a las diapos. Porque me interesa que hablemos un poco de cómo es este famoso three-way handshake de TCP. Acá yo podría... ¿Cómo abría acá? Bien, perfecto. Entonces, voy a dibujar dos líneas verticales. Y acá estamos poniendo el foco entonces, en el inicio de la conexión. Acá está. Por una cuestión meramente de simplicidad, vamos a asumir que A inicia la conexión. Nuevamente, si lo vamos a un ejemplo concreto y vemos que acá hay mucho push ahí, esto sería un caso típico de que A inicia la conexión para empujar data, por ejemplo, un upload de medios. Lo que decía recién de imágenes a Instagram, por ejemplo. Bien. Entonces, a algunos de ustedes les debe sonar, o lo habrán visto, que el intercambio de TCP para iniciar una conexión es lo que se llama el three-way handshake. Discúlpenme, esto deberían ser... A ver, podría ser. Creo que si yo ponía ahí, y apretaba shift. ¿Alguien recuerda cómo hacer líneas? Hay una manera. Lo era con el shift, ¿no? Sí, ahí va, ahí va con el shift. Perfecto. Gracias. Vamos ahí. Vamos ahí. Un poquito menos. Fucking shit. Vamos ahí. Y eso sí, las flechitas se las voy a dibujar a manopla. Así. Así. Y así. Ya vamos a ver más detalles, pero vamos a ir al hueso. Este paquete se llama "SIN". Ya vamos a ver por qué se llama "SIN". Este paquete se llama... "SIN". "SIN". "SIN". "SIN". "SIN". Vamos a ver eso en realidad. Vamos a ver que son flags dentro de la cabecera TCP, pero básicamente el "SIN" es por... Viene del "sincronicemos secuencias". Lo que tenemos que hacer es sincronizar nuestros ceros de comienzo de conexión. No es como decir "sincronicémonos". Yo que inicio la conexión, mando un "SIN". El otro lado, ¿qué corresponderá a ese "SIN"? ¿Cuál es la respuesta al "SIN" que yo mando aquí? Desde "A" hacia "B". ¿Con qué me responde? ¿Cómo sé yo, como "A", que al otro le llegó el "SIN"? ¿Qué les parece? Veo que ahí me está volviendo otro "SIN". Bien. ¿Pero ese "SIN" en qué será? ¿Como respuesta a mi "SIN" o...? Recuerden, acá hay algo importante. Siempre se tienen que parar en que acá ustedes no somos dioses que vemos "A" y "B". O somos "A" o somos "B". No sabemos lo que... El único feedback de lo que está pasando en el otro lado son los paquetitos que me llegan. Yo soy "A", yo envío un "SIN". Y ahora me viene un "SIN ACK". ¿Qué les parece? ¿Cuál sería el significado de ese "ACK"? ¿Qué me está "ACKeando"? Yo no le envié... La sincronización del "SIN". Claro, me está "ACKeando" el hecho de haber recibido el "SIN". Quiere decir que este "ACK" en realidad corresponde a este "SIN". ¿Y qué me está diciendo el otro? ¿Por qué me dice "SIN"? Para el puerto. Para también sincronizar. No, los puertos ya van todos definidos en este momento. No hay un... Este primer paquete tiene toda la info de puertos en juego. No hay después un cambio de puertos acá. ¿Qué pasa? Este "SIN" con el "ACK" me permite abrir mi lado de transmisión. Pero yo no sé el otro. Recuerden, recuerden. Y esto es súper importante. Esto es súper recontra-bidireccional. Todos los lados hay que abrirlos ambos. Y después son igualitos frente a la ley. ¿Sí? Por lo tanto, yo en el primer "SIN" y con el "ACK" yo si se quiere es mi lado de transmisión. Pero le tengo que permitir al otro que abra su lado de transmisión. Por lo tanto, ¿qué será ese "SIN"? Justamente el otro diciéndome "OK, bien". Acá va mi inicio de conexión o mi sincronización. Entonces, obviamente, él abre su lado y yo... Acá yo le estoy "ACK"ando ese "SIN". Desde ese momento ya podemos transferir data. Ahora acá ocurren varias cosas súper interesantes. ¿Conocen el problema de los generales bizantinos? ¿Lo han visto en redes? No, no lo sé. ¿No? OK. No importa. ¿Cómo yo puedo estar absolutamente seguro de que B ha recibido este "ACK"? El tercer "ACK". Mejor dicho, el tercer mensaje. Porque pongámonos... A ver, a ver. Varias cosas primero. ¿Qué son estas líneas verticales? ¿En qué las mido estas líneas verticales? En tiempo. Excelente. Quiere decir que si yo acá tuviera que ponerle una unidad a esto, ahí, se lo pondría en segundos, milisegundos. Pero, ¿eso qué representa? Esto tiene un nombre en redes. ¿Le suena? Empieza con "R". "R". "Round". "Round trip time". RTT. Exactamente. Fíjense que es fundamentalmente igual a un "ping", si se quiere. Nada que ver el "ping" con lo que estamos estudiando ahora. Pero es lo que nosotros leemos con el "ping". Es a qué distancia está de ida y vuelta el otro lado. Yo no puedo saber la distancia de ida y la distancia de vuelta, a menos que el otro me ayude, me ponga timestamps y demás. Yo puedo saber cuánto tarda el boomerang en ir y volver. Entonces, ese es el RTT que yo estoy midiendo contra el otro lado. ¿Qué sería, por ejemplo... Muy bien esa respuesta, por cierto, de que esto es tiempo. ¿Qué sería ese tiempo? Este tiempo que yo a propósito le diría que una pequeñita distancia. Procesamiento. ¿Procesamiento por quién? Por el "A". ¿Qué cosa del "A"? ¿Cuál capa de "A"? Muy bien que es "A". Es tiempo porque está en "A", no que otra. Pero esto qué sería. Es tiempo... Si yo te tuviera que preguntar de cuál de las tres capas es la que más está llevando tiempo ahí. En realidad todas, obviamente, porque depende de yo a dónde medí que llegó el "A". El "A", lo medí acá, lo medí acá, acá. Pero como esto es "A", que es un concepto de capa de transporte, obviamente, IP no tiene la más mínima idea de qué son estos "in" y "ax". Estamos diciendo que acá acabamos de leer un "A" entrando acá. Entonces, yo lo estoy midiendo acá porque es cuando soy consciente que entró ese "A". Hasta que... Leo el "A" del otro lado. ¿Hasta qué le puedo yo decir mi "A"? Este tiempo, ¿por quién va a ser ocupado? ¿Quién está ahí tomándose ese tiempo y por qué no es cero? ¿Qué les parece? Ojo, ese tiempo es absolutamente equivalente, yo no lo he dibujado acá, a este tiempo. Está muy bien, que es el tiempo de procesamiento de algo en "A" y algo en "B". ¿Qué será? ¿De quién? Esa es mi pregunta en realidad. No es IP, no es enlace. Estamos demasiado arriba. Quedan dos posibilidades, transporte o aplicación. ¿Qué les parece? Transporte. La aplicación no es consciente del "sin" y el "ax". Muy bien, excelente. ¿La aplicación qué hace? Hace, como ustedes recuerdan, "socket", "connect" si es el lado cliente, "write", "write", "write". "Write" y "read", "write" y "read", "write" y "read". Pero nos dice, che, enviemos un "ax", che, llegó el "ax", enviemos un "sin", che, llegó bien ese "sin" "ax", ah, no, mirá, hay que retrasar, no, mirá. No, no, no, así, justamente la idea de, muy bien, que el transporte, justamente la capa de transporte que tiene rascarse la cabeza y resolver todo eso. Pero la aplicación tiene que quedar todo en una bandejita de plata, así, donde la aplicación haga "writes" de un lado, la otra puede hacer "read" del otro y listo. Entonces, efectivamente, un tiempo de procesamiento de TCP. ¿Y qué se les ocurre que está haciendo TCP? Se toma ese tiempo, hace un "time" y le dice, no, a este "boom" no lo vamos a hacer, tardó un poco, meternos 20 milisegundos y listo. Ya está. ¿Por qué no es cero? ¿Qué está haciendo ahí TCP? ¿Qué les parece? ¿Qué es lo que está haciendo TCP? Calculando si no llegó erróneo, por ejemplo. Por ejemplo, bien. Recuerden que, muy bien, muy bien, el chequeo de integridad de datos de TCP no va a ser solamente cuando transfiramos datos, sino que también tiene que proteger su propia integridad de cabecera y demás. Por lo tanto, ese procesamiento va a ser, bueno, yo levanté este segmento, bueno, la cabecera, le corro el checksum, veo que esté bien, veo que además, súper importante tengan presente que este paquete no entra ya directo al socket. Es decir, acá hay mucho procesamiento para decir, acá en TCP, acá está súper simplificado, entra este segmento, pero hay algo que dice, este socket estaba abierto, ¿alguien envió acá un SYN? ¿Esto está en curso? Para recién enchularlo y decirle, ah, sí, clack, esto corresponde a esta conexión que sí existe y no es un flaco que me está tratando de atacar mandándome SYN/AXE para SYN que nunca existieron. Y ahí es donde está todo el tema del estado, ¿no? Lo que habíamos hablado del estado. Acá hay un estado no conectado. Díctenme, ¿cómo pondrían con sus propias palabras los distintos estados? Yo ya les spoileé uno. Estado sin conexión. ¿Cuáles podrían ser los siguientes estados? Al mandar el SYN entra en conectando. Bien, perfecto, excelente. Y al recibir el AXE, conectado. Bien, y obviamente eso está 100% sincronizado de un lado del otro, ¿no? Al mismo momento de tiempo, prácticamente no existe el problema de la relatividad. Así, chk, están conectados. ¿O no? El Einstein, ¿no? Perdón, hagámoslo correcto. Esto es sin conexión hasta acá. Estado conectando sería precisamente, exactamente, en el momento en que está ocurriendo esto. En este momento ahí. Estado conectado, más o menos acá al medio, porque acá esto es tiempo de procesamiento TCP. Podríamos decir que, yo lo voy a dibujar más o menos acá al medio. ¿Cómo lo puedo dejar? Está mal diciendo. Acá ahí, pegadito ahí. Entonces, estado conectado. Estado. Junto. Estamos conectados. No hay nada más que dudar de nada. Ahí más o menos a la mitad. Bien, ¿qué pasa del lado B? Empieza sin conexión. Sin conexión, pero acá hay algo interesante que el lado B hace apertura pasiva. Sin conexión, pero esperando, ¿no? Porque, bueno, pasiva. Está esperando, está listo, o mejor dicho, listo para conectarse si se quiere. Si lo quisiera hacer un poco mejor. Bien, ¿cómo evolucionaría en estos estados? ¿Qué les parece? Cuando le llegue el SIN, entra en conectando. Muy bien. Y al recibir el ACK, conectado. Correcto. ¿Qué les quiero mostrar acá? La dura realidad. ¿Cuál es la dura realidad? Seguramente no es así. No, no, no, es así. Está muy bien, está muy bien. ¿Cuál será la dura realidad? Que el tiempo existe, ¿no? Y que la relatividad existe. No hay un tiempo absoluto, ¿no? Yo ahora, para nosotros, en nuestros ojos, es muy fácil jugar a ser Dios y decir "Ah, mirá, ah, sí, está conectado el otro todavía, no, yo lo veo y tengo una instantánea". Pero piensen nuevamente en la dificultad de que yo soy A o soy B y no tengo más feedback del otro lado de lo que ocurra y que venga con los distintos paquetes, ¿no? Yo tengo que figurarme, tratar de entender que el otro está o no está. Y ahí volvemos entonces a la pregunta. ¿Qué pasa si se pierde el primer SIN? Vamos a hacerlo más simple de todas. ¿Qué pasa si se pierde el primer SIN? ¿O no se puede perder el primer SIN? Sí, puede pasar. Es IP abajo, ¿sí? Yo armé, yo subí un TCP súper bonito, qué sé yo, le puse todos los firuletes, pero después abajo tengo una red que es BEST DEFAULT. Absolutamente puede pasar. Y más si estoy con el célulo con muy baja señal, una red Wi-Fi muy ruidosa o en el patio de casa muy lejos de mi AP. Sí, ese SIN, bien que se puede perder. Listo, se rompió la conexión, ya está, sonó. Listo, ya. Tengo que abrir una nueva conexión. ¿Qué podrá hacer TCP del lado A que está intentando iniciar una conexión hacia B? Y ese SIN se perdió. Esperaron, claro. Esperaron un tiempo y... Considerarlo, y acá hay algo interesante que vamos a empezar a ver. Considerar el SIN como si fuera el primer byte virtual. No es el primer byte, obviamente, pero pensarlo como un byte virtual. Y meterlo en la cabeza como que tengo que hacer el mismo esfuerzo de cuando yo estoy enviando datos. Entonces, bajo ese concepto, ¿el TCP qué va a hacer? Va a ser como si hubiera enviado este primer byte virtual y dice "envíe el SIN". Yo estoy esperando que me lo hagan ACK, igual que cualquier byte que enviaré luego. No me hicieron ACK, pasando el terminado tiempo, ACK timeout, reintento. SIN forzara a un error en la aplicación de decir "pucha, tu connect falló, dale fruta" y haces la aplicación con un violento "while connect" o "while not connect", así. No, TCP por debajo está haciendo toda la paquetización de esto, está haciendo todo el laburito. Cuando tiene éxito, alguna vez que cuando pase este SIN, intenta uno, timeout, intenta otro, quizás también se pierde por cuanto a timeout, reenvía otro SIN. Imaginemos que llegó a B, con lo cual acá yo tendría que dibujar, obviamente, distintas flechitas, ¿no? En donde la raíz de esas flechitas sería el ACK timeout. ¿Se entiende? Es decir, a ver, lo voy a dibujar, pero después lo voy a borrar para que no quede sucio el dibujo. Es como que TCP envió este SIN, además con la gravedad de que no tiene todavía un feedback de cuál es el RTT, porque no ha tenido, asumamos, que no ha tenido previo contacto, previa historia con el otro lado. Por lo tanto, TCP envía un SIN y dice "bueno, sí, pasó un rato y acá no me llegó nada". Acá está el segundo SIN. Lo que quería decirles es que esta distancia en tiempo vendría a ser el timeout que hizo TCP, llamado ACK timeout. ¿Por qué? Porque timeouteó el ACK, dijo "no, acá no hubo ACK, tengo que reenviar el SIN". Y es básicamente el mismo segmento, intentar reenviarlo, reenviarlo, reenviarlo, hasta que reciba el ACK. Entonces, cuando yo recibo el ACK, ahora sí, yo estoy contento. ¿Qué pasará ahora? Recordemos que estos dos son iguales ante la ley de TCP. B ahora está enviando su lado SIN. Logra ACK el segundo, y acá está el three-way handshake. Primero, segundo, tercero. El segundo, ok, llega hasta acá. ¿Qué pasa si ese segundo no llega? ¿Qué les parece? ¿Cuál es el segundo? ¿Cinco? Ajá, este es paquete uno, paquete dos y paquete tres. Le vamos a poner un numerito. Le vamos a hacer uno. ¿Qué pasará? Y se queda esperando el ACK, y como no llega, lo vuelve a mandar. Un timeout. ¿Y este lado cómo lo interpretará? Profe, disculpe, el SIN y el ACKC recibe el ACK. ¿Son dos paquetes distintos o no? No, son flags dentro del mismo, son flags a la cabecera, y lo vamos a ver. Es una optimización. Está muy bien tu pregunta, podrían serlo, pero como vamos a ver cómo esto es tan bidireccional, sería un despropósito mandar data. Pensemos al SIN como un byte virtual de vuelta, tratemos de meternos eso en la cabeza. Es como que yo enviaría, bueno, acá van los datos en este paquete que yo te empujo, y acá va otro paquete con el ACK al tuyo. No tiene mucho sentido y voy a gastarle el doble de PPS, packets per second, a la red. Más vale pongámonos todos uno solo, y la cabecera tiene tanto mi lado como la... tiene mi cara transmisora como mi cara receptor, la misma cabecera. En mi cara transmisora yo le digo lo que estoy empujando, SIN, espacio, secuencia que empujo, en mi cara receptora yo le voy a ir dando ACK a lo que él me ha estado enviando. Con ese mismo criterio, entonces eso es un solo paquete. Bien, entonces, ¿qué pasa si dos se pierde? Claro, porque ninguno de los dos recibiría un ACK recibo, entonces los dos como que volverían... Fíjense, ¿qué les quiero mostrar con esto? Hace falta que... lo que les quiero mostrar es la complejidad del problema. Uno piensa, primero, primera asumpción, que la red es perfecta. Horrible asumpción, y más aún ahora que somos tan wireless. Jamás podemos pensar en esa asumpción. Por lo tanto TCP tiene que hacer un montón de laburo. Fíjense lo complicado que es que se pierde el segundo, porque si se pierde el segundo, los dos lados están perdidos ahora. ¿Por qué? Porque para A, por más que llegó el SIN al otro lado, no le llegó el ACK. Entonces para A, en realidad es como si el primero se hubiera perdido. ¿Se entiende? Si se pierde el dos, para el lado A es lo mismo que si se hubiera perdido el uno, porque nunca le llegó el ACK. Entonces, ¿qué va a ocurrir ahora? Va a depender un poco los timings, de un lado y de otro, pero acá obviamente, ¿quién va a tener la misión de retransmitir, en principio, el paquete dos que tiene el SIN, el lado B, de reempujar ese SIN ACK? Pero a su vez el lado A, si se cansa, si se termina el timer, que se le va a terminar antes que el lado B, también va a reenviar el SIN. Entonces, bien puede ser que esa retransmisión de los dos, del uno y dos, se cruce en el camino, ¿no? Si es que yo lo pudiera fotografiar en algún punto, ahí, intermedio de la red. ¿Se entiende ese problema? Y la complejidad de ese problema es lo importante de entender, ¿no? Por suerte, el SIN, hacer un byte virtual, tiene garantía de empuje. Garantía de empuje es que quien lo puso, va a pelear por él. Quiere decir que, vamos a super simplificarlo, por este interlacing de timing que hay entre uno y el otro, pero el SIN que va en el uno, el lado A va a pelear por él, porque es el que sabe, yo tengo que mandar este SIN, byte virtual. Tengo que empujar al otro lado y lo voy a empujar hasta que me lo acknowledge. ¿Sí? Bien, perfecto. El lado dos, lo mismo va a hacer con su SIN, tengo que empujarlo hasta que me lo haga acknowledge. ¿Qué pasa si se pierde el tres? Nada, si ya va el uno y el dos, si se pierde el tres... ¿Alguien se va a enojar acá? Y el B se va a enojar. Se va a enojar, sí, claro. ¿Y qué va a hacer B ahí? Volver a enviar dos. Claro, volver a enviar dos. Ahora, fíjense lo interesante. Para el lado A, ¿cuál es la situación del universo para el momento en que envía el ACK? Ese tercer, el tercer mensaje con el ACK solito. ¿Cuál es su estado del universo? ¿Cuál es su visión del universo para A? Que se piense que está conectado. Por lo tanto, para A, si tengo data para enviar de A hacia B, démosle fruta, muchachos. ¿Cierto? Sí. Démosle fruta, ya está. Ya envié el ACK y acá tengo un mega... Y para el pobre B, todavía el guaso está tratando de recibir el ACK de su SIN y le está llegando todo un flujo de data. ¿Qué quiero destacar con esto? Lo complejo que es mantener un estado sincronizado entre dos cosas que están distantes en el tiempo. Porque en definitiva, acá la diferencia es el vertical que tenemos es tiempo. Entonces, para TCP es muy stateful y tiene que tener muchas cosas en consideración para tratar de mantener la coherencia entre esto. En esto, ¿no? ¿Cómo podré...? Y acá viene algo que quiero que nos saquemos de la cabeza. Va, mejor dicho, que lo aprendamos es... Fíjense que para ese tercer ACK, "Flaco, te envié el ACK, plim". Tu problema si no te llega. Porque no hay un ACK del ACK, porque si no después vendría un ACK del ACK del ACK, con lo cual voy a necesitar un ACK del ACK del ACK. Y ahí viene el problema de los generales bizantinos. ¿Cómo hacen...? Imagínense dos generales en dos cerros distintos, en dos lomas distintos, teniendo que atacar a alguien que está en el valle, al enemigo que está en el valle, y su única forma de comunicación es con mensajeros que pasan a través de este valle, con potencial pérdida. ¿Cómo hacen los dos para sincronizarse si no tienen otro medio de...? No tienen por decirte lucecitas ni nada, ¿no? ¿Cómo hacen para sincronizarse, para estar seguros de que los dos recibieron el mensaje de atacar a tal hora? La idea es asegurarse de que vamos a atacar a las dos de la tarde, son las once de la mañana. Esperar el round trip time. Claro, a ver, yo soy el general A, que le envío el mensajito al B, y tengo que esperar que venga un soldadito de B a decirme "A recibió bien tu mensaje". ¿Y cómo sabe B que A lo recibió bien? Con el último "ac". Mandó un tercer soldadito. ¿Y cómo sabe A que el tercer soldadito sobrevivió? No sabe. No lo sabe. Entonces le pido a B, le exijo a B que mande un cuarto soldadito. Sí, pero sería infinito. Sería infinito, a eso quería llegar. No hay manera, ¿sí? Acá tienen que haber timers, tienen que haber expectativas, y si no recibo, lado B. Si no recibo el tercer mensaje, entonces asumo ese periodo, tengo que retransmitirlo. Pero no hay una visión unificada del estado de ambas lados. Siempre va a haber un desfasaje. Eso es importante, importantísimo que lo tengamos presente, ¿no? ¿A qué fui con todo esto? A que no hay "ac" de los "acs". Porque no tiene sentido. Los "acs" solamente "ackean" a nueva data que había estado en vuelo. Y quien tiene que pelear por recibir esos "acs" es el lado transmisor. La receptor obviamente los envía, si los recibió bien, si los checks son "done ok". Pero es el lado transmisor el que tiene que empujar para que esos "acs" lleguen. ¿Sí? Eso es un concepto súper, súper importante. Y ahora vamos a volver a las diapos. Déjenme que las abra acá. Maldito tiempo relativo, ¿no? Qué lindo fue ese día, el tiempo fue el absoluto. Ok, nosotros entonces la clase pasada habíamos terminado de presentar acá y ahora vamos a entrar en un concepto súper importante que es el siguiente. Acá como bien habíamos hablado, TCP mantiene una ventana que es determinística, que es esto, ¿no? La ventana, lo que el TCP transmisor, es decir, "a", va a mantener en todo momento, va a ir recibiendo un feedback del lado B de cuánto es el buffer recepción del otro lado, lo que se llama la ventana de recepción. Esa ventana de recepción, como hemos hablado bastante ya, regula de alguna manera el ritmo indirectamente, la cantidad de data que yo puedo tener en vuelo, como lado transmisor, en base a la ventana de recepción. Hemos hablado en la clase pasada que esa ventana de recepción puede ser tan despejada como todo el buffer, generando una aplicación que es súper, súper, que tiene la posibilidad de despejar este buffer, de leerla, de consumir ese buffer lo más rápido posible, y tenerlo siempre súper despejado. Pero bien puede ser una situación, sencillamente que la aplicación, el próximo paso que tiene que hacer, el próximo procesamiento con eso que le envía "a", la aplicación del lado B, sencillamente no lee ese buffer y "b" tiene, perdón, "a" tiene más velocidad de transmisión de lo que "b" puede consumir eso. Entonces se va a presentar una situación de buffer lleno, situación de buffer lleno es una situación de ventana cero hacia el lado de "b" hacia "a", imaginando que "a" está tratando de enviar. Ese buffer es determinístico, porque yo lo leo, va en cada cabecera, "b" puede decir taxativamente flaco, ahora tengo 16k, 15k, 14k, y lo escribe, lo escriben las cabeceras, 2k, 1k, 0, 0, 0. Con lo cual el lado transmisor dice, ups, la ventana es cero, no puedo seguir transmitiendo hasta que el lado receptor no abra la ventana de recepción, es decir, la aplicación del lado B, no consume y me despeje espacio de recepción de buffer, no voy a poder seguir transmitiendo. Ahora, si lo pensamos, eso solamente contempla, del lado transmisor, la situación del lado receptor, la situación esta de determinística de buffer, pero como bien sabemos hay otro jugador acá, súper importante, que TCP debería ser un poco cuidadoso. A ver, ¿qué pasaría si TCP tomara esta actitud como dijimos al principio? Imagínense, ¿no? El handshake acá, fla, fla, fla. Por cierto, vamos a ver luego que en todas las cabeceras va la ventana, incluso en este SYN, en este SYN inicial, en el primero, este lado dice, porque también tiene su buffer de recepción, como lo vimos, el lado A tiene su buffer de recepción, le va a decir ventana 32, imaginando que fueran iguales de un lado y de otro. En el primer paquetito que recibo de B, el SYN ACK S también me dice ventana 32, y después en el ACK final, ventana 32. Estamos todos de acuerdo que esto está despejado de ambos lados, porque de hecho estamos recién iniciando la conexión. Y de pronto dice, ¡uh! 32K, listo. La aplicación, la bestia de la aplicación escribió "Mega, tengo 32K, este es mi momento para lucir", me dijo el TCP transmisor de este lado y quizás del otro lado también, si es que ambos, si es que empiezan un intercambio direccional, y escriben los 32 segmentos, luego datagramas IP hacia uno tras otro. ¿Qué les parece eso? ¿Está siendo cuidadoso con la red? O está, mejor dicho, ¿está teniendo en cuenta que también está la red cuando toma esa decisión? El TCP debe decir, listo, el otro me publicó una ventana de 32K, yo tengo 32K para llenarle esa ventana, y se lo... Le tiro el 32 paquete de 1K. ¿Qué les parece? No, no le está importando nada. Bueno, ve. Ni tiene en cuenta la red. ¿Y qué pasaría si todos los TCP del mundo, o mejor dicho, todos los TCP que comparten esta misma, de comillas, "zona de red", decidieran hacer eso con cada inicio de conexión? Y se saturaría la red. Sería bastante desastroso. Y más aún si tengo cada vez máquinas más poderosas que tienen posibilidad de tener buffer recepción más grandes, ¿no? Blancar con un mega de buffer recepción. Imagínense que todos TCP dijeran "¡Wee! ¡Ay!" Y vamos a transmitir. Bueno, entonces, ¿qué es lo que apareció a medida que TCP se fue desarrollando? Apareció el concepto de una ventana, de una ventana heurística, ¿no? De terminística, que se llama ventana de congestión. La ventana de recepción en realidad contempla... No sé si pongo el ruido acá. No, no lo voy a... No me va a caer bien el dibujo. La ventana de recepción contempla un estado determinístico básicamente de esto. ¿Cuánto me está diciendo el otro lado que puede recibir, que tiene espacio libre en buffer? La ventana de congestión va a ser una ventana dibujada por el lado transmisor, en base a lo que huele de la red, de qué tan bien están dando. ¿En base a qué este TCP puede empezar a percibir "La red está... no está muy buena hoy, debería acá bajarle la rosca" o "La red está fantástica"? ¿Qué tipo de feedback puede tener TCP ahí para decir "Es IP que le va a ir diciendo su Squench, no, mirá, la red está fallando" y de pronto cuando la red se congestiona, la misma red empieza a gritar a todos los TCP que tiene en sus bordes "¡Ah, no, no, no!" ¿O será el mismo TCP que va como aprendiendo, que tiene que tratar de decir "esto no está muy bueno, tengo que adaptar acá"? ¿Qué les parece? Supongo que TCP porque IP no tiene la manera de hacer eso. IP no hace ningún aporte a la capa de transporte. ¿Y cómo sería si este TCP, este TCP de hecho, el que puede decir "esto no está muy bueno" o "esto está... qué tiene para...? Y si está retransmitiendo muchos paquetes. Bien, si está retransmitiendo mucho, el ritmo con el que llegan los hacks del otro lado. Y entonces ese feedback que tiene TCP de cuán bien o cuán mal está la red, va a ir ajustando esta ventana, yo le llamo ventana heurística porque no está... Está obviamente almacenada la transmisión pero nadie te dice acá, no hay un Dios que te diga "Che, loco, está bien, este te dijo 32K originalmente, pero yo, red, te digo que tenés 3K de ventana de congestión". No, este va a tener que ir diciendo y decir, "Uh, bueno, lo voy ajustando". Y siempre transmitir con el mínimo permiso de las dos ventanas. La ventana de recepción determinística, la que está del lado B. Y una ventana fantasmagórica, heurística, que yo como TCP transmisor voy a ir construyéndola en base a arrancarla en principio, ya vamos a ver que no es tan así, pero arrancarla con un máximo de la ventana de recepción del otro lado, y penalizándola, penalizándola significa bajarla a medida que veo que la red no se comporta bien. Pero siempre tratando de tender a abrirla y a que la ventana de congestión iguale a la ventana máxima de recepción, para decir, cuando la red está perfecta, la ventana de congestión iguala a la ventana máxima de recepción, la que leí en el primer intercambio, y cuando la red está mala, ¿a cuánto usted lo bajaría? ¿a cuánto le hacía martillazo al TCP? En este caso al lado A/B, diciendo "¡ah, horrible, horrible!" ¿Cuál sería ese número mínimo? De ventana, median bytes. La de 1. 1K, sí. Podría ser 1 o 1K, no es lo mismo. 1 es un byte, 1K es un MTU, estamos hablando de 1.5K, para ser más precisos. ¿Cuál de los dos? Lo dejamos picando y lo vemos ahora. Se los dejo picando porque es un tema interesante. Bueno, vamos a ver entonces, ¿qué es lo que vamos a ver en estas dos nuevas diapos? Un montón de... ¿Conocen ese dicho en inglés que "el diablo está en los detalles"? O decir "¡Uh, mira qué bueno este protocolo, año 81, qué hicimos, anda fantástico hasta que no anda fantástico". Andaba fantástico hasta que dejó de andar fantástico. ¿Por qué el diablo está en los detalles? "Debilice in the details". Vamos a ver el primer fenómeno. ¿Por qué nos enfocamos en esto? Esto está muy bien explicado en el Internet Core Protocols. A nosotros nos gusta enfocarnos en esto, no porque queramos aprender todos los chirimbolitos que tiene TCP, pero lo que sí nos interesa es entender el problema porque eso va a afectar como yo escribo las aplicaciones y como yo le saco el mayor jugo a la red cuando tengo una aplicación bien escrita. Entonces, veamos qué es lo que ocurre acá. El primero que es Silly Windows Syndrome, que es del lado de recepción, es... ¿Qué pasa? Imagínense la situación esta que venimos hablando reiterativamente de que A está empujando a lo bestia, tiene un montón para transmitir contra B, buffer de transmisión lleno, y acá tenemos la situación de ventana cero y esta aplicación le da un byte por segundo. ¿Por qué? Porque está programada así, o porque no sé, o la programaron mal, o tiene un bug y viene, tiene un loop, main loop, y el flag con el main loop le hace un read del FD, tamaño 1. Entonces, la situación es, todos estos buffers de transmisión de A hacia B y de recepción en B, obviamente, están llenos. Yo los fotografío y están llenos. Y la aplicación viene y cada un segundo hace... saca un byte y lo procesa. Espera un segundo... y hace un read de un byte y lo procesa. Si ustedes son estrictamente TCP, ¿qué harían acá? Con lo que hemos aprendido hasta ahora. ¿Qué novedad tiene el lado B, al cual le han despejado un byte de su buffer lleno? Tiene una novedad ahora. ¿Cuál es la novedad? La ventana. Ajá. Antes era cero y ahora es... Un byte. Uno. Un byte. Ojo, no un "k", es uno. ¿Qué debería hacer B? Para seguir con lo que hemos aprendido del protocolo hasta ahora. Palabra clave, publicar. ¿Qué debería hacer B? A estaba parado porque tenía ventana cero y ahora yo, como B, tengo una novedad. Y la app lo lee y le tiene que avisar al espacio que le queda. ¿Cuánto es ese espacio? Uno. Perfecto. Entonces, si yo sigo estrictamente el protocolo sin ningún hack, yo como B debería decir "¡Uh, buenísimo! Estábamos ventana cero, ahora tengo ventana uno". Agarrar, armar un mensajito de TCP con cabecer y decirle "Che, tenés ventana uno ahora". ¿Y A qué debería hacer? Siguiendo lo que hemos aprendido hasta ahora. Intentar enviar uno. Envía uno. De los 32 "k" que tiene lleno y todo lo que tienen para arriba, agarra, toma un byte, le pone una cabecera de 20 bytes de TCP mínima, le pone una cabecera de 20 bytes de IP mínima y envía ahí un divino mensaje, un datagrama que mide 41 bytes y lleva un byte de data, que fue lo que se había despejado en el buffer de B. Llega hasta B, imaginemos que la distancia networkeana entre los dos es de pocos, 100 milisegundos o 200 milisegundos, ponle lo que quiera. La aplicación, recordemos que le haría un byte cada un segundo. Estamos muy abajo de eso, estamos a 100 milisegundos de round trip time. Por lo tanto, le llegó, reaccionó, envió, con lo cual es como que la aplicación enala un byte y a los 100 y pico de milisegundos ya tengo el buffer lleno de vuelta porque hizo "ch, ch, ch" y le dijo "eh, hay un byte libre, buenísimo, ahí te vivo" Vienen los 41 y se llenan. ¿Va a haber algo que corrija en el futuro? Primero, ¿qué tan bueno está este comportamiento? ¿Qué les parece? No, está malísimo. Horrible. ¿Por qué es horrible? Porque para enviar un byte estás enviando 40 más. Básicamente tiene un ratio de 2,5%, 1 sobre 40, y 1, bueno, más o menos. 2,5% de uso de la red para enviar datos. ¡Espantoso! Te sacaste un 0 TCP. Lo que es interesante es que, al menos que TCP tenga un hack, si TCP se comporta como hemos aprendido hasta ahora, este va a ser un comportamiento catatónico que va a seguir para siempre. Porque la aplicación va a seguir leyendo cada un byte, cada un segundo. "Ch, ch, ch" Ventana, "ch, ch, ch" Y se va a venir, se va a llenar rapidito con un byte. Y tuvo que bajar un montón de overhead ahí. Listo, y la aplicación lee de la punta del buffer y después se le llena la colita al buffer a los 100 y pico milisegundos y después se le llena de vuelta. Y en realidad ese uso final va a ser horrible de la red. Siendo que encima, esta aplicación tiene 32K menos un byte todavía para consumir y este tiene también como los 32K para enviar. Así que no le agregan nada que llegue ese byte atrás de todo esto que había para hacer. Entonces, este es el primer caso que es el más sencillo de entender de los hacks que aparecen. No son hacks, son en realidad implementaciones dentro del protocolo de TCP para evitar esto, porque si no, ¿qué alternativa queda a TCP? Hacer la gran alternativa de TCP papiestado, es decir, prohibimos las aplicaciones que leen de un byte cada un segundo. Listo, plum. Están prohibidas. Estoy obviamente teatralizando algo estúpido. Tengo que poder soportarlas, pero tengo que poder soportarlas bien. No tengo que poder, no tengo que tener, de vuelta, que cargar a la red IP con un mal comportamiento de la aplicación. Es mi misión como capa de transporte hacer que esto funcione bien incluso cuando tengo una aplicación estúpida. Eso es súper importante. Entonces, ¿qué hace? ¿Qué hace TCP? Miente. Miente. ¿Cuál sería esa mentira? ¿Dónde estaría esa mentira? ¿Quién es el primero que tiene que mentir acá? Si hay algún intercambio de paquetes, tengan presente, que por cierto que esto fue nada más que de A hacia B. Acá pueden estar fluyendo perfectamente paquetes de B hacia A, entre el verde y el rojo este. Por lo tanto, hay AX en ambos sentidos. El AX va siempre, ya vamos a ver. Excepto en el primero, que es un SYN. No tengo que hackear, pero después siempre viaja AX. Entonces, en esos intercambios, cuando el lado B tiene que decir "y mi ventana ahora es 00001", 1, 1, 0, 0, 1, 1, 0. ¿Qué podría ser B ahí? En todos estos intercambios, ventana 0. Acaba de despejar un byte en el buffer. ¿Qué ventana le digo A? Para que no sea tonte. 0. Devolver un byte a la última. 0. No, está bien, sí, ok. Ok, buffer, sí, sí. Todo lo que vos quieras. Tenés un byte, tenés dos bytes, tenés tres bytes, tenés cinco bytes, tenés cien bytes. Ventana 0. 0. Tenés 200 bytes, 500 bytes. Ventana 0. Y miento, miento, miento. ¿Por qué no tiene sentido? Porque tengo una ventana de 500, tengo todavía 31 IP, 31... ¿Para qué le voy a dar una ventana más chica al otro que se va a venir como loco a transmitirme? ¿Cuál sería un buen punto de inflexión cuando ya dejo de mentir? ¿Cuándo debería ir? ¿Cuándo yo, como B, empiezo a decir "ah, sí, sí, sí, ahora sí hay ventana"? No sé, la mitad o por ahí. Bien, es una buena idea la mitad. Pero, ¿cuál es el paquete más interesante, más gordito que puedo enviar a la red, que mejor utiliza la red? Y esa va a ser nuestra unidad de... Vamos a ver que toda la furia de TCP, que vamos a estudiar todos estos hacks, un PMTU, muy bien, un PMTU, un PASMTU, ¿no? Entonces, TCP ya ha aprendido para el estado conectado. Está aprendiendo cuál es el PMTU, y es una memoria que tiene ambas puntas, tanto A como B memorizan los PMTU. ¿Qué va a ser típicamente el mismo? Muy raro que sea distinto, el mismo va a terminar memorizando, va a aprender el mismo PMTU. Imaginemos, ese PMTU va a ser típicamente 1.500, imaginemos para simplificar lo que estamos hablando y los números, un K de PMTU entre ambos lados. Entonces, nuevamente, la aplicación recuerda, ¿no? Lee muy lentamente de a un byte. Pero acá hay intercambio de segmentos de un lado a otro y de cabeceras. Lado B dice 0, 0, el buffer tiene 100, 0, el buffer tiene 800, 0, el buffer tiene 1.200. ¡Ah! ¿Cuánto le pongo de ventana al otro lado? 1.200 le digo. Es como que no empiezo a publicar la ventana hasta que el otro lado, que no sea mayor que un PMTU. Y eso va a hacer que el otro lado reacciona, el lado transmisor dice, ¡uh, buenísimo! Tengo 1.200, voy a poder armar un paquete de un K y ahí aparecerá otro retoque de si vale la pena o no vale la pena enviar esos 200. En realidad va a enviar esos 200 al estado de orden, hasta donde yo sé, mandaría el un K y otro K de 200 también. Pero lo importante es que esta idea de mentir para proteger a la red. Y vamos a ver que todas estas optimizaciones están, de alguna manera estos son hacks, son ajustes de TCP para proteger a la red. Cuando esto se empezó a implementar, se implementó en el lado recepción. ¿Y cómo sería una implementación también protectiva o defensiva, mejor dicho, del lado transmisión? Lo que estamos viendo es una implementación defensiva del lado recepción. Esto de mentir y solamente publicar un buffer, una ventana de recepción, una vez que supero un PMTU. Y del lado de transmisión, imaginando que tengo un TCP mal implementado del otro lado, muy simple, un sensorcito, que se yo, que no implementó el SWS, se llama esto. Silly Windows Syndrome. ¿Por qué? Porque es como ventana, síndrome de la ventana tonta, por esto de que es una ventana de uno que se va transmitiendo, obedeciendo el caso original. Ahora lo tenemos arreglado en el receptor, pero imaginemos que no lo tuviéramos arreglado en el receptor. ¿Hay algo que el transmisor podría hacer? Si el receptor en realidad con cada intercambio va diciendo, "Ay, sí, ahí hay una ventana uno, ventana dos bytes, ventana tres, ventana cuatro, y yo soy transmisor. ¿Qué puedo hacer en forma defensiva frente a eso?" Y hasta que no me dicen que tiene una ventana de un PMTU, lo mando. Exactamente, tal cual, tal cual. Entonces fíjense que hay como implementación del lado receptor esa mentira, pero el lado transmisor también tiene que ser cuidadoso y decir, "No, flaco, ok, sí, vos decime dos, tres, cuatro, cinco, pero hasta que no venga un caca, Milky, hasta que no me digas Milky, yo no te mando nada. No, no, no. Porque acá tengo todo esto bufereado hacia arriba, sí. Una cosa distinta sería si no tuviera nada bufereado y también está ese concepto. Entonces, habiendo entendido conceptualmente cuál es el problema, acá vienen las reglas. Entonces, publico ventana cero hasta que la ventana, acá en realidad debería ser mayor o igual a un PMTU. Fuck, shit. Mayor o igual a un PMTU. O, y acá hay un concepto que típicamente uno no lo ve, uno no lo ve, pero alguno de ustedes nos mencionó que estaba muy bien cuando la ventana sea la mitad. Pero eso es para una ventana chiquita. Imagínense ventanitas de un K que nunca vamos a llegar a un MTU, sí. Imagínense una implementación muy, muy restringida en memoria, no. Nuevamente, más difícil de verla hoy en día, pero algo acá que tengo un buffer recepción, no sé, o vamos a hacer distinto, de 2K, es bastante arriesgado esperar hasta que pasen los 1500 de PMTU para decirle "ya tenés ventana". Entonces ahí se pone una regla, o que puede ser un MTU, o que toques más allá de la mitad del buffer, que fue un criterio que alguno de ustedes mencionó que está muy bien. Cualquier de las dos condiciones dispara la actualización de ventana al lado receptor. Bien. NUG lo vamos a ver después del recreo porque es un poquito más complicado. Es más tricky de entender. Vamos a ventana de congestión y la vamos a... Yo ya les presenté esta idea de la ventana de congestión y fíjense cómo se penaliza la ventana de congestión. Imaginemos una situación en donde hay un flujo normal entre ambos lados, ¿no? Es decir, acá hay... Asumamos por simplicidad de que A está transfiriendo a B. Todo fluye normalmente, fluye hermoso. Y si saquemos esta aplicación catatónica, imaginemos que tenemos una aplicación ágil del lado B que está consumiendo el buffer recepción y esto se da, va todo bien y no hay pérdida. En esa situación, la ventana de congestión tiene el mismo valor que la ventana máxima de recepción que yo había medido. En el inicio de la conexión. 32K. Eso está señalizando, y la pongo horizontal para tratar de hacer una mímica de que la ventana de congestión está acá, ¿no? Representa la red. Y la ventana de recepción representa el tamaño del buffer libre. Entonces, tenemos una ventana de congestión de 32K. Esta ventana de congestión en realidad se va adaptando también a la ventana de recepción, ¿sí? Si la ventana de recepción está arrancó en 32K, después se bajó a, no sé, 20K, la ventana de congestión, en un caso de sin pérdida, se va siempre adaptando. Ahora, ¿qué pasa? La ventana de congestión, se supone que no es una copia de la ventana de recepción, es una copia penalizada de la ventana de recepción, penalizada por situaciones anómalas de la red. Y es así como se va penalizando. Fíjense, si hay un act duplicado, ahora lo vemos, ¿qué significa act duplicado? La ventana de congestión se penaliza a la mitad. Si yo vengo a Hermoso, imagínense que veníamos con una ventana estable, 32K era cuando estaba vacía, imagínense que la logro tener 20K. Si tengo un act duplicado, el lado transmisor va a decir, ups, act duplicado, la corto a 10K. Y es como que yo, arbitrariamente, mi ventana de congestión ahora es la mitad. Es 10K justamente porque observé un act duplicado. Y si tengo un act timeout, y esto es lo más loco de TCP, si TCP, el lado transmisor, observa un act timeout, es decir que no me vino el act en tiempo, la ventana de congestión se baja a un MTU. Así de violento es. A un MTU. Estábamos quizás en unos divinos 20K o 32K, si estaba totalmente espejado el buffer, y tengo yo el lado transmisor act timeout, y la corto a la ventana de congestión, y solamente me autopermito, por la ventana de congestión, un MTU, un PMTU. Y después voy a tener que pelear por subirlo. Esto más o menos sería así. Vamos a ver si me sale el dibujo. Vamos a hacer dos ejes. Este eje es el tamaño de la ventana, y vamos a ponerlo a las dos. Este eje es tiempo. Imaginemos que... ... ...esta es la ventana RX. Es decir que esta altura sería estos 32K que veníamos hablando a modo de ejemplo. Y lo que voy a dibujar, y esta es de alguna manera fija, vamos a asumir la fija por simplicidad, que la estamos viendo fluir naturalmente y bien. La ventana de congestión va a seguir entonces un tránsito más o menos, yo lo voy a dejar acá en azul, arranca ahí, va todo bien, pero se baja acá, a la mitad, bajo un evento de ACK duplicado. Se baja a la mitad, ya vamos a ver cómo se vuelve a levantar, tiene un comportamiento como suave al levantarse. Yo por ahora lo voy a dibujar así, de manera semilineal, se va a ir levantando, un evento de ACK duplicado. Recordemos acá a modo de ejemplo, imaginemos que estos son, por ejemplo, estos 32K que habíamos hablado, para tener una idea de número más o menos. Por lo tanto, con un ACK duplicado, se le baja a la mitad, acá baja a 16K. ¿Y qué pasa si tengo un evento de ACK timeout? ¿Cómo debería seguir dibujando esta línea? ¿Qué les parece? Estaba tratando de levantarla, imaginemos que logró levantarla y llevarla de vuelta, y ahora viene un ACK timeout. ¿Qué ocurrirá con la ventana? Baja el P, venta. Así de violento. Tuk, acá. En donde esto es, entonces. Timeout. ACK duplicado. Ya estudiamos enseguida, por qué ACK duplicado tiene un sabor, hay un problemín. Y ACK timeout es más fácil de entenderlo como que hay un problemón. Pensemos que ACK timeout es que desapareció el otro lado. Crasheó el nodo, no obtuve ningún otro tipo de feedback del otro lado, no estás del otro lado para mí. Porque si no me hackeas, si me dio timeout, estaba esperando que me hackee, y no llegó, para mí no existís. O dejaste de existir. Entonces, por eso es que, vamos a ver, entonces, acá. Y ahora vamos a ver enseguida, por qué este T7 tiene un comportamiento, más o menos así, una primera parte exponencial, y otra segunda parte lineal. Pero este ACK timeout, esta altura acá, va a ser un PMT1. A ver cómo lo podemos dibujar. Actube, entonces acá le vamos a poner, WB, Fx sobre 2. BK, esta altura acá. Un PMT1 de altura. Poner acá entonces, sobre la X. ¿Entienden? ¿Ustedes han percibido esto? ¿Les suena cuando la red está...? ¿Qué es lo que uno tiende a hacer cuando, cuando, si esta página está lenta para cargar? La recargas. Y generalmente tiene más éxito recargarla o no. Digamos, el tiempo final. ¿Suele convenir esperar que eso se recupere, o suele convenir recargarla? Típicamente, ¿no? ¿No? Yo a mí a veces siento que si la recargo, a veces que mejor. Y es por lo que estamos viendo acá, justamente. Esta memoria que tiene TCP de que este socket ha tenido un problema, y que se ha presentado una situación de ACK timeout. ¿Sí? ACK timeout provocó esto, y el ACK loop provocó esto. Este ACK timeout me hizo que este socket, esta conexión, que memorizara que acá ha habido un problema, y la recuperación es muy lenta. En general, es más, suele ser, ya vamos a ver que no es general, no es necesariamente así, pero suele ser más fácil romper ese socket, y decir "ah, esta conexión está espoileada, está embrujada", y directamente empieza una conexión fresca desde cero, que arranque sin memoria, que no arranque con una memoria de que había tenido un problema, que no arranque de una manera penalizada. Porque no solo eso, sino que este PMTU, y acá voy a tener que aumentar los tiempos de retransmisión. TCP, cuando retransmite algo que se perdió, y ahí va una pregunta interesante. Cuando yo tengo, yo soy TCP, hay un ACK timeout, estoy penalizado a un PMTU, por lo tanto puedo transmitir un solo segmento grandote, un PMTU por vez, a pesar de que tengo un montón, esa es mi vida, mi penalización, mi ventana de congestión me dice un PMTU. ¿Cada cuánto lo retransmito? Tengo que retransmitirlo, ¿no? Si yo había transmitido todo un pedazo de una secuencia de segmentos que representaban todo un espacio de secuencia interesante, ACK timeout. Me bajo a un PMTU. Retransmito. Si el otro lado en RTT estaba a 100 milisegundos, ¿qué hago? Retransmito cada 110 milisegundos, retransmito cada 110 así. Y me quedo ahí medio en modo TOC, modo así obsesivo-compulsivo. Y todos los TCP que hay alrededor de este problema de congestión de la red, todos... ¿Qué deberían hacer TCP ahí? Además de que ya está restringido un PMTU, el ritmo de retransmisión. Y no sé, porque si hay un timeout, puede que se haya apagado la computadora del otro lado. Sí, sí, sí, no puedo saber nada, no me vino ninguna señal, así que yo soy TCP transmisor. La pregunta es, si el otro lo había medido a 100 milisegundos, me dio ACK timeout porque esperé, no sé, 125 milisegundos, ya veremos, vamos a ver, 100 más X milisegundos, y no vino y retransmito. Y con la penalización de ventana que estamos viendo ahora. La pregunta es, retransmito, yo había esperado, no sé, 125, retransmito, espero 125, retransmito así, chup, chup, chup, chup. O tengo que, no solo cambiar la dimensión tamaño, sino cambiar la dimensión tiempo, y ser también gentil con el ritmo de retransmisión. ¿Qué les parece? ¿Qué pasaría si esa red que está congestionada, hay pérdida de paquetes? Yo no sé si es el nodo que se fumó, o la red que se comió mi, yo no sé qué pasó, ¿no? Ventana y congestión a mí me ayuda porque mi asumpción es que es la red el problema, no el destino. Entonces, bajo asumir que es la red el problema, yo tengo que proteger la red. ¿Qué pasaría si todos los TCP quedaran en un PMTU, pero mantuvieran ese ritmo de transmisión muy similar al de RTT que habían medido antes, al round trip time? Yo chik, chik, chik, y todos mis hermanos chon, chon, chon, y todos sus primos chon, chon, chon, chon. Y no bajaran el ritmo, no dijeran "eh, eh, eh, eh, para que te llegue el AC, tranquilo, no seas tan toc TCP". ¿Qué significaría eso en la implementación del tiempo? ¿Qué harían ustedes? ¿Eran 100 milisegundos en el próximo intento? ¿Cuántos harían? 200, no sé. Bien, 200, no pasó nada todavía. ¿En el próximo? 300. ¿Y si quisiera ser más gentil con la red? 400. ¿Quién es la mejor apuesta? El doble, ok. ¿Y en el próximo? 800. Bien. Y llegó hasta un punto máximo, ese punto máximo está en alguna referencia que creo que son 30 segundos, una cosa por el estilo, pero ese mecanismo se llama "exponential back off". Quiere decir que yo me freno exponencialmente. Y es algo que tenganlo presente siempre cuando ustedes se estén tratando con este tipo de problemas. Tienen que pensar en la escala del problema. Tienen que pensar en qué van a hacer todas las instancias de su aplicación. Acá estamos viendo el protocolo de transporte, ustedes no tienen que pensar esto porque ustedes duermen cómodos como aplicación que TCP se encarga de hacer toda esa retransmisión. Pero es importante que, si TCP no tiene ningún feedback del otro lado, entonces, pará, pará, pará, pará, pará. Dejemos que esto se recupere. Entonces, tengo que bajar todos los ritmos de transmisión que yo tengo, al menos, contra este destino. Y para bajar el ritmo, si yo estoy limitado a un PMTU, la única manera de bajar la velocidad de transmisión es aumentar el tiempo. Velocidad es tamaño dividido a tiempo. La dimensión que me queda es tiempo. Y sabiendo que la red, además, es sensible a cantidad de PPS, no solo a la cantidad de paquetes por segundo, no solo a la cantidad de data que muevo, entonces, yo me empiezo a estirar en el tiempo y empiezo a bajar mis expectativas de que la red tenga la posibilidad de pasar eso, Exponential Backoff. Cuando uno hace F5 o Control+R para recargar una página, fundamentalmente, el PMTU todavía se sostiene, ya vamos a ver por un fenómeno que vemos ahora enseguida, pero lo que se resetean son los timers de transmisión. Es Exponential Backoff. Eso que uno observa que, uc, esa página se quedó en, blin, cargando, así, se quedó, cum, cum. Y se quedó ahí, ¿por qué? Porque tengo los Exponential Backoff del otro lado, el lado, por ejemplo, si es un web server que está intentando transmitir y, hay algo de pérdida, capaz que perdió uno de mis hacks, y, tac, tac, está haciendo el Exponential Backoff. Pin, pin, pin, pin, pin. Está estirando los tiempos. Yo cuando hago F5, es como que arranco fresco desde cero. Y arranca el, el, el timer de retransmisión del otro lado, va a arrancar en un RTT, en lo que memorizó de a qué distancia de tiempo. Por eso, es como que, hago una trampa, corto ese Exponential Backoff, y al arrancar la conexión fresquita desde cero, arranco con un, con un timer de retransmisión mucho más bajo. Y con eso, dependiendo, obviamente, del estado de la red, y si la red es capaz de, de, de absorberlo, generalmente tengo más éxito. Y esa es la razón por la cual un recargar algo funciona. Funciona mejor. La razón es que le hago trampa al Exponential Backoff. Bien. Entonces. 19.31. Hagamos un recrédito. ¿Qué nos queda? ¿Nos quedan estas dos? No, estas son, son relativamente rápidas. Sí, no podemos terminar hoy y ver, al menos hacer un preview de la cabecera. Hacemos un recrédito, son las y media, volvemos a la, y 31, volvemos a la -10, ¿eh? 8-10. ¿Rearrancamos? Bueno. Antes de ir al recreo, ¿alguna duda de esto que hablábamos hasta ahora? No, está, para mí está bien claro. Está bien claro y curioso. Sí, es muy interesante como me ponen la lupa ahí abajo, porque uno nuevamente está sentado como en la aplicación, haciendo push. Bueno, en eso le meto write, todo lo que tengo, todo tal. Y en realidad hay maneras en las cuales uno puede sacarle mejor jugo al ritmo de la red. No, no se quiere presionar tanto TCP, entender lo que pasa abajo, y no pensar que es una manguera infinita de bytes, sino, mmm, esta manguera está paquetizada abajo, entonces tranqui, veamos cómo hago la aplicación cuando escribo, cuando leo, para que fluya mejor. Así que, bueno, por eso es que nosotros nos consideramos importantes tener esta lupa en que pasen transportes. Bueno, paro la grabación y ya obviamente hacemos una nueva cuando volvamos. [AUDIO_EN_BLANCO]Me volví a unas diapos para no "spoilear" lo que viene más allá de lo que ustedes tienen. Estas diapos, pero... Siempre decimos que algo configura las IP de esta máquina. Bien tenemos la experiencia de que yo vengo con una máquina pelada y sin esfuerzo la conecto a la red, es decir, le doy link, le pongo, no sé, le pongo las credenciales para entrar a Wi-Fi, en caso de una Ethernet de placa, le conecto el cable y, ¡pum!, mágicamente obtengo una IP. Díganme, ¿cuáles son los parámetros de trabajo? Lo digo así muy genéricamente, que yo necesito básicos básicos para poder decir "bueno, esta máquina ahora es usable en el stack TCP/IP". ¿Qué es lo que mi máquina necesita aprender para que sea usable? Para que yo, como usuario final, pueda poner "www.google.com" y usarla de una manera útil, vaga, redundante. Díganme entonces, ¿qué necesito? ¿Una IP? Bien, ya está, con eso me alcanza. Que alguien me dé una IP ya alcanza. ¿Leer datagramas puede ser? Sí, sí, pero es una propiedad de mi placa, de la implementación de, asumo que viene con stack TCP/IP instalado, es decir, asumo que la máquina de mi lado está lista, yo me refiero a parámetros de configuración para poder usar esta red, que es distinta a la red de la universidad cuando voy, es distinta a la red de mi amigo cuando voy a la universidad. Cada una tiene sus parámetros de configuración. ¿Cuáles son esos parámetros mínimos, minimorum? ¿Qué necesito? La IP y el default gateway. Listo, y con eso ya estamos, ¿cierto? Sí. Bien, perfecto. Yo tengo que buscar, porque tengo acá, miren, miren, acá tengo el cuadernito donde están las direcciones IP de todas las máquinas del internet y cuando "www.google.com" lo pongo, ¿qué es lo que me va a dar? ¿Qué es lo que me va a dar? Acá es donde están las direcciones IP de todas las máquinas del internet, y cuando "www.google.com" yo busco acá que es la 172.35. Y la "tpeo". ¿Qué quiero observarles con esto? Y esto no es una burla en absoluto, sino que, ojo, bien, con IP y con gateway, en realidad, estoy siendo, bueno, estoy siendo Santa Claus, modo navideño de admitirles que IP alcanzó. IP con gateway me alcanzaría, en realidad, ya me dicen por qué no, para poder empezar a tener capa 3 lista. Pero no me alcanza con la capa 3. Ahora vemos qué más necesito. ¿Alcanza solo con la IP? Me han dicho IP y gateway. Y un puerto. ¿Puerto? Para TCP. No, los puertos los maneja el protocolo TCP, vamos a ver bien cómo lo maneja, pero no hay nadie que me diga "puedes usar estos puertos". El permiso de usar algo compartido es el espacio de direcciones IP. Me dicen "vos, solo la .1", que obviamente alguien memoriza, quien a mí me dio la .1, memoriza que está en uso, y a otro le dará la .2, .3, etc. Esto de prestarle una IP, hacer un lease, "lease" en inglés, lo más parecido a un contrato, si se quiere, de prestar una IP por algún tiempo. Ahora, me quería tener un momento ahí. ¿Alcanza con IP y gateway? Para poder hacer usable la capa 3. Ya vemos más para arriba, pero para poder hacer usable la capa 3. ¿Alcanza con IP y gateway? Y la otra definición importante es que Alzad le puso un precio al mega de internet, el mismo precio en cualquier lugar del país, vale lo mismo comprarle a Alzad en Tierra del Fuego que en La Quiaca que acá en Mendoza Capital, una cosa que no ocurre lo mismo con los demás proveedores de internet, porque es real que el costo no es el mismo, no es lo mismo darle soporte a una fibra o una red que tiene 300.000 kilómetros y que tiene otros costos que, bueno. Pero en este caso, con el objetivo de, esto es una situación que es global en el mundo, hasta donde los estados desarrollan las comunicaciones y es verdad que la Argentina perdió la soberanía sobre las comunicaciones con los gobiernos de Menem cuando privatizó, que era lo que había que hacer porque las compañías no eran buenas, y dividió el país, le dio un pedazo a la telefónica y otro pedazo a Telecom. Son esquemas que no ocurrieron en otros países. En Chile, por ejemplo, la red troncal es del gobierno chileno y toda la operadora usa la red troncal y pagan por usar la red troncal. Bueno, Alzad es una compañía nacional que persigue hacer eso, con todos los problemas que tiene una empresa estatal también. No es que es súper eficiente, le falta ancho de banda, no tiene el ancho de banda, para que se den una idea, no sé, Alzad, si le querés comprar un giga acá en Mendoza no te lo puede vender porque no tiene. Entonces, bueno, se está ampliando, pero digamos que ese es un poco el objetivo. Pero es una red nacional también. ¿Hasta acá me siguen? Sí, sí. Sí, sí. Bien. ITC está conectado a este, está conectado a Alzad, pero voy a decir, che, pero pará, ITC está conectado entonces a tres proveedores. Cuando alguien viene a contactar a alguien que está en ITC, ¿por dónde entra? ¿Cómo puede ser? ITC, es decir, esto que le acabo de dibujar acá es real. ITC tiene Telefónica, tiene Alzad y tiene Lumen. Tiene un router que está conectado a los tres proveedores. La pregunta es si alguien que está en la internet quiere contactar a alguien que está en ITC, ¿por dónde viene? Por cualquiera. Sí, pero... Por el camino menos costoso. ¿Y cuándo vimos que era menos costoso? ¿Qué tal el ruteo tenía menos costoso? No, bueno, eso lo vemos en comunicación. ¿Y de quién va a depender por dónde viene? ¿De quién depende? Es decir, en este dibujo que está acá, por ejemplo. Si alguien viene, no sé, yo estoy acá en un proveedor en China que está conectado a... Perdón. Que está conectado a este router acá. No sé, yo estoy ahí. ¿De qué va a depender que me mande por Taza o que venga por Alzad? En ese dibujo que está ahí. ¿Con las cosas que nosotros hemos estudiado? ¿De quién va a depender? ¿De la tabla de ruteo? ¿De quién? Del routercito. De este router. De la tabla de ruteo. Es una muy buena cosa. Siempre va a depender de la tabla de ruteo. Entonces vos decís, bueno, pero ¿y qué? ¿Quién maneja esta tabla de ruteo? ¿Quién es la entidad? Claro, a ver si este es el router. ¿De quién es este router? Si acá está Arzad, acá está Telefónica, acá está... ¿Y el ANAC? ¿Quién es el ANAC? No, me acuerdo, no, no sé si lo escribí bien, pero la entidad que manejaba las IP públicas. ¿La GNIC? La GNIC, sí, me equivoqué. Bien, esto que está acá, ¿qué es? Vos decís, ah, mirá, acá hay un router y hay tres proveedores distintos, es algo que se conoce como un IXP. Es una cosa... Internet Exchange Point. Es decir, es un punto donde, de alguna manera, están vinculados proveedores que son distintos, que deciden cooperar, pero que no tienen nada que ver con la internet. Están vinculados proveedores que son distintos, que deciden cooperar, porque si yo quiero ir de la red de Claro a ITC, por ejemplo, y esto no existe, y, por ejemplo, este que era Claro, solo me saca por un cable submarino hasta México, y en México tiene un cable que lo conecta con la red de Lumen, ¿cómo hago yo para ir de acá, Claro de Mendoza, a ITC Mendoza? Si esto no fuera así, iría hasta donde en algún momento un camino me trae a vuelta, porque está claro que ITC no tiene un cable tirado acá a Claro Mendoza, ¿no? ¿Se entiende eso? Es decir que este que está acá es un router con algunas características particulares, y es lo que se conoce como un IXP o un IX, un punto de intercambio. Ahora, imagínense por un momento eso, ¿quién administra este router? ¿El flaco de Telmex, el de Taza o el de ARSAT? Todos tienen password el router, por ejemplo. ¿Quién carga la tabla de ruteo? No, no es el mismo router. ¿Cómo? ¿Cómo? ¿Por qué le va a ser el mismo router? ¿De dónde la vas a sacar? Y si no, profe, la entidad de esa que habíamos dicho... No, pero esa les dio la IP y dijo "bueno muchachos, acá están las IP, yo les pongo ruta desde acá, desde el router de la Atlántida, les tiro la ruta a ustedes de acá y chau, está bien". Es decir, esto va al ACNIC, supónganse. Se ve que este router, ustedes coinciden que acá tiene que haber entrada en esta tabla de ruteo para ver por dónde vienen las cosas y tenemos un tema de quién carga la tabla de ruteo acá, que está claro que no le vamos a dar un password a un flaco para que haga esto, sino que tiene que tener un poco de automatismo. Ahora, perdón, no sé si alguien me iba a decir algo. No, no, no. De alguna manera sabemos que estos tienen direcciones IP específicas, que los routers tienen que tener la entrada para orientar las cosas, pero nos falta un poco la idea de cómo se coordinan las tablas de ruteo que no estaría bueno que estuvieran estando a mano. No sé si me entienden. Ahora, por ejemplo, este router, para mandarme a mí por acá, ¿quién necesitaría avisarle que yo quiero que mis clientes los traiga por acá cuando vengan? Es decir, ITC tiene, porque ITC maneja la dirección IP que le dio el ACNIC, a ITC le dieron la 190.15, tanto, tanto. Él tiene que lograr hacer que este router, cuando a alguien le caiga un paguete de 190.15, lo mande por acá. ¿Se ve? Pero es ITC el que tiene que lograr que este router tome esa decisión. O no, si él quiere que los clientes de JVV van por Lumen, este router le pueda decir a este que quiere que los clientes 190.15 vengan por acá. No sé si me explico. El router o ITC. Y eso tiene que terminar la tabla de routeo, porque nadie routea si no tiene información en la tabla de routeo. ¿Se ve? Para eso, y yo hasta acá se los he mantenido medio escondidos, bueno, no escondidos, eso en realidad requirió que cuando yo, y en realidad, cuando yo voy a hacer esa gestión en LACNIC, en realidad, lo que LACNIC me da es lo que me dice, OK, le voy a dar las direcciones y le voy a dar un sistema autónomo. Un sistema autónomo se define como la cantidad de recursos y prefijos de direcciones que administra una entidad que da soluciones de red, digamos, y da servicios de conectividad. Y el sistema autónomo en realidad es, tiene un identificador, un número de 16 bits, y entonces, en realidad, todas las empresas que juegan a internet tienen sistema autónomo. Es decir, este es el sistema autónomo de Claro. Este, que serían todos los routers, es el sistema autónomo de Telefónica. No sé, y este es el sistema autónomo de ITC. Entonces, esto es como que ya tuviéramos una capa de abstracción diferente. De hecho, fíjense que cuando vimos acá, acá dice, "ah, usted tiene esta dirección IP", dice, "ah, el ASN, el Autonomous System Number, es este". Y si yo le hago clic acá, me dice, "información acerca de ASN, etc, etc, etc". Ah, informática y telecomunicaciones. Y fíjense qué hay. ¿Qué son estos? Bloques de IP. Claro, porque lo que empieza a ocurrir es que, y así es como realmente funciona, la internet de verdad son charlas entre sistemas autónomos. Este sistema autónomo habla con este sistema autónomo, este habla con este. Que en realidad, lo que hablan es qué tienen que intercambiar ellos entre sí. ¿Qué le tiene que decir el sistema autónomo de ITC, en este caso, al de Telefónica? Claro, le tiene que decir, "che, mira, yo quiero que a través tuyo, te publico, te digo estos bloques, avísale a la internet que vengan por vos". Entonces, el sistema autónomo de Telefónica, que está acá, este que se lo dibujé, se lo dibujé a propósito, esto que está acá, es súper importante, se llama CABASE, hoy en Argentina. De hecho tiene un IXP acá en Mendoza. CABASE tiene un sistema autónomo también. Entonces, por ejemplo, imagínense, lo que ocurre en la internet es que los sistemas autónomos, en realidad se hace a través de los routers que están en los bordes, hacen peering, hablan con el router del otro lado, usando un protocolo que se llama BGP, que es el protocolo que se usa para hablar entre sistemas autónomos, para intercambiar rutas. Refijo, en realidad. Entonces, acá aparece, y ahí se conecta con lo que ustedes decían, es verdad, estos routers no los graba nadie, estos routers corren BGP y hablan, protocolo BGP, entre los routers de los sistemas autónomos. ¿Qué es lo que habla la charla BGP? La charla BGP dice "che, mirá, hola, habla ITC con Taza, por acá te publico este prefijo, este prefijo, este prefijo, este prefijo". Entonces, el sistema autónomo de telefónica, que acá lo he dibujado en celeste, que también tiene a todo Arlington, le avisa al sistema autónomo del IXP, que está acá, todos los prefijos que están a través de él. Dice "che, mirá, yo ahora tengo todos estos prefijos a través mío". Entonces, atrae el tráfico por él, porque el sistema autónomo de Arlington le publicó tales prefijos, y el sistema autónomo de ITC le publicó. Y eso es extremadamente dinámico, ocurre todo el tiempo. Es decir, yo puedo estar en cuestión de segundos, diciéndole, por ejemplo, el sistema autónomo de ITC podría decirle, en realidad, ITC está conectado a telefónica, al sistema autónomo de telefónica, al sistema autónomo de ARSAT, y al sistema autónomo de Lumen. Y le podría estar publicando prefijos, barra lo que quiera, por distintos sistemas autónomos. Entonces, el mundo, Lumen, hablaría con el próximo sistema autónomo de a los que él está conectado. Y así, en realidad, tengo charlas entre sistemas autónomos que son bloques agregados de toda la gente que me está publicando a través mío. No sé si se entiende eso. Eso permite que, fíjense qué poderoso es un mecanismo de comunicar la situación de ruteo de manera dinámica empoderando al dueño de las direcciones. Es decir, ITC, y en realidad, ¿qué es lo que le dio la ACNIC a ITC? Lo que te da la ACNIC es el sistema autónomo. Vos no jugás acá si no tenés sistema autónomo. Porque no sirven solo las IPs. Lo que sirve es el sistema autónomo. Y el sistema autónomo, en realidad, sirve a medida de que yo tengo mi sistema autónomo y yo puedo hacer peering, hablar con otro sistema autónomo. Y si los dos estamos aislados del Internet, no sirven para nada. Pero normalmente yo hablo con el sistema autónomo de mi proveedor, que es más grande que yo, y este está conectado a otro sistema autónomo. Y en realidad, la Internet en general termina siendo una gran red que vincula sistemas autónomos que hablan prefijos, que cambian todo el tiempo. Y ahí es donde aparece lo que ustedes decían, es decir, "No, a ver, ¿qué es lo que puede hacer ITC?" Sí, ITC puede, en cuestión de segundos, decir, "Che, mirá, de hecho, es como ocurre". Tengo muy cargado el vínculo... Primero, dos cosas. Yo puedo, una cosa importante, yo soy ITC, puedo hacer que un cliente mío salga a Internet por telefónica y de ahí se vaya a la Internet, y cuando la respuesta vuelva, vuelva por ARSAT. Porque depende de lo que yo anuncié a la Internet. No sé si me explico. Vamos a nuevo. Yo saco un paquete, tengo IP origen 190, pero este router que está acá dice, "Ah, bueno, esto lo voy a sacar por acá por telefónica, porque tengo ganas". Pero le voy a avisar que este bloque del que flaco salió, le aviso a Lumen que me lo traiga de vuelta por acá. Entonces yo puedo salir a Internet por acá y volver por este otro lado. ¿Hace balanceo de carga? La verdad que no es balanceo, es un tema de ingeniería de tráfico. De hecho, es más, yo puedo decidir, y acá voy un poco a por qué existen los IXP. Los puntos estos de intercambio, a ver si se los puedo mostrar. Fíjense esto. Yo hago "ping" a Google Cloud y me dice que estoy a 24 milisegundos. No sé si lo ven. Si lo hace "ping" a 190.15.211.1, que sería una puerta de enlace de mi proveedor. Es decir, eso es de mi casa a una puerta de enlace en ITC. Me da 7 milisegundos, y me da 7 milisegundos de carga. Es decir, tengo solo 3 veces más a Google. Eso significa que Google está 3 veces de acá a ITC, yo estoy a 20 kilómetros. Google está en San Martín. No sé dónde está. ¿Cómo es que Google está tan cerca? A ver si le vamos a poner los nombres. Yo estoy haciendo un MTR. Bueno, bienvenido al mundo de las IPs públicas, privadas. Estoy "nateado" dos veces, ¿no? 172, 17, todo esto son IPs privadas. Pero acá aparece una IP que ya parece pública. Preguntemos quién es este muchacho. Who is este? Me dice "Kabase". Es decir que este salto es Kabase. Vamos a ver quién es este otro salto. Profe, entonces Kabase también es como otra empresa, otra organización. Muy bien, ahí vamos. Veamos quién es el próximo salto. Esta también es Kabase. Es decir, acá hizo un Kabase, otro Kabase. Ya vamos a ver por qué. Pero me interesa Google. Es decir, esto es una IP privada, es dentro de mi proveedor. Las tres primeras. Este es mi router de mi casa, ¿no? Este es el proveedor, esto es una IP privada. Esto es Kabase, este también es Kabase. Nada más que un poquito, vamos a ver por qué. Veamos quién es este. ¿172? ¿Quién es este? 172. Google. Es decir que... Es decir que qué. ¿Qué sería esto? En este dibujo. Si yo tuviera que dibujar a Google acá, ¿dónde lo dibujo? Unidad, una unidad. Unidad de KBase. Ok, es decir, pará. What the fuck. Acá está Google. De hecho, miren estos dos minutos. Youtube.com Vamos a ver un buen video. Pará. Pará. Ahí tengo el... Pará. A ver si lo corro el video. Lo voy a adelantar para que... Fíjense la IP del tráfico, ¿no? Dice 443, ¿no? Este es el stream. Esta era la IP. ¿Qué dice? Estoy viendo un video de Youtube y no sé si lo vieron. ¿Qué dice? ¿Se entiende lo que... Decía KBase. ¿Ah? Decía KBase, ¿no? Claro. ¿Qué es esto? Es decir, acá está... Acá está Youtube. Conectado a KBase. ¿Está Youtube ahí? No. Pero el video viene ahí, ¿no? Tiene que ser un servidor ahí. ¿Cómo un servidor? ¿Está todo Youtube ahí? No. Lo que hay acá, y por eso está KBase. KBase es, las siglas de la Cámara Argentina de Base de Datos, pero en realidad hace rato que KBase es una red nacional de IXPs. Es decir, es una empresa que ha puesto puntos de intercambio en todas las ciudades del país, los ha interconectado entre sí, y en Buenos Aires tiene cachés de Google. Es decir, tiene un aparato que... Cuando alguien pide algo a Youtube, ese aparato habla con el contenido original, es decir, esto tiene... Acá el colega lo puede conocer mejor que yo, no sé si está ahí todavía, pero... Este aparato tiene una fibra a la red de Google posta, que es una red global del planeta. Es decir, Google tiene su propia red. Este aparato que es el caché de Youtube, que está enchufado, es decir, cuando haga un caché, es un servidor, un fierro, conectado ahí con una IP de KBase. ¿Y qué le permite esto a los... Piensen ustedes, ¿qué le permite a los proveedores de Internet en este problema que vemos acá? Si no estuviera eso, y yo estoy en ITC y pido Youtube, ¿a dónde debería ir a buscar... ¿A dónde está Google? En el altaciente central que tengan. ¿En el altaciente de Montambiú o en algún lado donde lo tengan? ¿Qué significa para un proveedor de Internet desde el punto de vista del tráfico eso? Y que debería ir a... cada vez que alguien ve un video, sacarlo acá, sacarlo por la astonina e irse al mundo. Claro, con Netflix pasa lo mismo, ¿no? Ah, Netflix, ya vamos a ver que es un tema parecido... No es tan parecido, es decir... Pero se los da como a los proveedores directamente. Es más picante lo que hace Netflix, pero... Y aparte el problema es distinto, porque Netflix, el inventario de Netflix no es infinito. El catálogo de Netflix es finito. ¿Cómo es el catálogo de Youtube? Es prácticamente infinito todo el contenido que hay adentro de Youtube. Entonces... Diego, perdón, te diría, son las 10 menos cuartos. Podríamos hacer un sync acá en todo caso. Rapaz, está súper interesante la comparación con el caso de Netflix, es súper relevante. Pero por ahí, en todo caso, lo podemos arrancar en la clase que viene, si te parece. Sí, sí. No vi la hora, nos fuimos a los caños. No hay problema. Bueno, voy a dejar el dibujo ahí y para dar... Como todos tenemos una vida, lo vamos a dejar y lo vamos a retomar en la próxima clase. Además de eso.Bueno, retomando, lo que queremos hacer es cómo modelamos, pasamos de este problema que está resuelto en papel, por decirlo de alguna manera, y lo queremos modelar y hacerlo animado. A algunos se les ocurre cómo lo haría y nos cuentan qué podemos usar, cómo lo haría. Es para no mostrárselo a ellos y yo sé cómo hacerlo. Me gustaría que cada uno… Hola, ¿estamos acá o no estamos acá? Sí, profe, yo no pude realmente… Intenté pero no me salió. ¿Qué sería? Pero cuéntenme, quiero que me digan qué intentaron, qué intentarían hacer como para ver cómo se resolvería. Profe, yo en MiniEdit traté de crear un switch, pero no sé… ¿Se puede poner dos direcciones para los switches en MiniEdit? No, switch no, router también como no. Router, perdón. No, pero es parte de lo que queremos resolver. Pero por eso, quiero que me digan a ver cómo harían, porque… ¿Qué pueden dibujar con el MiniEdit y qué dificultad puede ser que tengan? Recuerden que dijimos que íbamos a hacer dos sucursales, ¿qué habría que poner? Un router central y después dos routers para cada una de las sucursales. En realidad si son dos sucursales no haría falta un router central, podríamos conectar esos dos routers directamente. No quiero eso, no dije que se puede hacer eso, nunca dije que se puede hacer eso. Un router central y un router en cada una de las sucursales. No, y la máquina. ¿Qué tiene dibujado esto? Acá tienen que poner un router central, un enlace a otro router, una red que hay acá y un host. El otro router, esta red y otro host. Es decir que acá tienen uno, dos, tres, cuatro, cinco equipos… No estabas presentando, Diego, no sé si te estabas guiando por lo que… Sí, estaba dibujando en el aire, perdón. Gracias por avisar. Tenemos que hacer un host, este host, el router, otro router, otro router y otro host. ¿Qué es lo que ven que se les dificulta y que lo que no han podido resolver? Si el otro día vimos cómo hacer… Yo el profe pude capearle el IP al host, pero después no pude cambiárselo al router y lo que hice fue asignarle un IP desde el archivo con BIM, pero hasta ahí llegué. A ver… Ahí estuvimos probando y hablando por el grupo de WhatsApp con los chicos y porque como que desde la interfaz no podíamos configurar el router, digamos. Entonces por eso nos fuimos a fijar al archivo .py y tampoco no sabemos cómo ahí configurar para que tenga lo… A ver, bien, bien. Está claro cuál es la dificultad y… Veamos esto. Yo acá pude agarrar y decir, bueno, el router es lo mismo, es un host. Me está presentando, profe, no sé si… Pero de nuevo, perdón. Vámonos. Ok, ahí vamos. Abrí mi mininet y me puse acá. Está bien. El host lo puedo hacer con… es lo mismo, para el mininet es todo un host. Acá cada router es otro host y después tengo otro host. Acá hay un switch, otro switch. Todos coinciden que esta red es así. Está bien. Es decir, acá hay un cable porque esto es un switch, acá hay un switch, acá hay otro cable, otro cable, otro cable, otro cable, otro cable. Si quiero puedo agarrar y para ponerlo más bonito le puedo poner que este se llama R central, router central. A este le puedo poner R sub 1. Le podría poner… Esto es lo que le está pasando, que no le están poniendo un IP, pero supónganse que le queremos poner… A este le puedo poner 192.168.101. Era este. 101/24. Barra 29. A este le queremos poner… Router sucursal 2. 192.168.100. Si este era 1, son 8 más allá. 9/29. Una cosa así. Y después, este es host sucursal 1. Dijimos que este era el 10/10. 1/254/24. Ok. Y el host de la sucursal 2 le vamos a poner… Host sucursal 2. 10/10. ¿Cuánto? 2. ¿Cuánto? 2/54. Barra 24. Ok. Era 10/0, profe. Bueno, lo mismo, pero… No, no era… Ah, 10/0, perdón. Sí, no es lo mismo. Gracias por avisar. 10/0. Bueno, esto es así. ¿Qué podía hacer con esto? Bueno, dijimos que esto lo puedo grabar. Le voy a poner caso 2. Y puedo mandar a que genere el código. Export, level 2, script. Le voy a llamar caso 2. Listo. Está grabado. Voy a salir de acá. ¿Qué podía hacer con esto? Bueno, lo puedo correr. A ver si es vivible lo que armé. Puedo poner sudo python caso 2 python. Esto dice que tiene… Ha creado esos hosts. Entonces, ¿cómo hago para meterme en cabo esto? Voy a poner Xtem, router central. Y estoy adentro del router central. Le pongo medium, le pongo large. ¿Se ve bien ahí? Sí, se ve bien. Se ve claro que tiene… A ver, esto tiene las interfaces, lo que pasa es que tiene cualquier IP. Tiene una que es la eth0 y otra que es la eth1. Tiene dos interfaces, es decir que les hizo las placas. De hecho, fíjense, ustedes pueden preguntarle acá a Mininet que les dibuje cómo está hecha la red. Le puse net y me dice "mirá, tengo el router de la sucursal 2 que tiene la interfaz eth0 al switch 4 y eth2". Me muestra más o menos cómo está la red. Yo le puedo poner acá cuáles son los nodos que hay acá. La pregunta es, ustedes dicen los switch no llevan IP. ¿O llevan IP los switch? ¿Llevan IP los switch? No. No, porque son switch. Vamos a ponerle que nos queremos meter Xtern host sucursal 1, IP adres. Vamos a poner más grande para que se vea. Este tiene bien la IP. Con quién tendría que hablar este? El host de la sucursal 1 tendría que hablar con quién? Con el router de la sucursal 1. A ver, entonces me dice Xtern, R sucursal 1. Se acuerdan que le pusimos un IP a este. Le pusimos un IP o no? IP adres. ¿Cuál de estas dos interfaces que tiene este router? Tiene dos interfaces el router. Se ve que tiene esta que da la 1 y esta a dónde da. Esta interfaz es la que se ve con este. ¿Qué podría hacer para probar si se ven? Un ping. ¿A quién? ¿Qué IP tiene esta interfaz? No la tiene. Esta interfaz no tiene IP porque no se la pusieron nunca a ustedes. ¿Qué IP tiene que tener esta interfaz para poder hablar con esta? Le estoy preguntando, ¿qué IP tiene que tener? Está dibujada en el dibujo 800 millones de veces. ¿Qué IP tiene que tener? Para verse con este. La 10.10.1.1. Igual esa red está configurada como 10.10. El de al lado sale como 10.10. Bueno, le pongo 10.10 para que veamos. 10.10. Tengo que asignarme una IP en esta interfaz. Entonces yo le hago ip address add 10.10.1.1/24 al device rsucursal1-eth1-brd+ Este es el comando que asigna una IP con el comando IP address. Estoy sumando la IP a esta interfaz, que es la que se ve con esta otra interfaz. ¿Qué podría probar ahora? Bueno, 10.10.1.254. Ahí. Y de este lado, el pin 10.10.1. Perdón, 10.10. 10.10.1.1. Y también responde. Bueno, acá yo he hecho esto a mano. Lo que nos gustaría hacer es, ¿cómo podemos hacer para que... ¿De dónde salió toda esta configuración? ¿Quién prendió esta configuración? ¿Quién la hizo andar? Que es un poco lo que contaban que estuvieran haciendo. El archivo Python. Ok, es decir que en este archivo, de alguna manera está... Fíjense, ¿qué hace este archivo? Si lo miráramos, ¿qué creen que está haciendo? Ahí se encuentra toda la configuración de la red. Por eso, pero vamos a la... Está usando una librería, que son las librerías de Mininet. ¿Está bien? Que tienen, al hacer prompt Mininet, import Mininet, y simplemente este objeto lo puede crear, el objeto net. Es una instancia de la clase Mininet que le importó acá. Y después fíjense que todo lo demás hace net, está llamando a métodos de este mismo objeto. ¿Esto qué hace? ¿Qué creen que hace esto? Crea un switch. ¿Esto qué hace? Crea un host. Esto le tira un cable entre Router Central y el Switch 1. Este tira un enlace entre el Switch 1 y el R Sucursal 1. ¿Qué harían como programadores? ¿Qué es lo que habría que buscar? Que está bien lo que estaban pensando y es lo que quiero que hagan. Y configurar ese archivo para crear la red. Eso ya crea la red. ¿Qué es lo que no está bien todavía? Que lo vimos recién. Y todo lo que sería la parte del ruteo. No, no, no. Pero hay un problema anterior que no tienen resuelto. Que lo dijeron ustedes. Asignarle la IP al equipo. Claro, por eso. Está faltando en algún lado. ¿Qué es lo que falta? Cómo le asignamos... Claramente, por ejemplo, el host que se llama R Sucursal 2 tiene dos interfaces. Pero yo le estoy asignando una sola IP acá. El R Sucursal 1 también tiene dos interfaces y le estoy asignando una sola IP. ¿A dónde podría ir a buscar para saber si...? ¿Qué dijo el profe? ¿Que se le cortó? ¿A dónde podría ir a buscar? A ver, estoy tratando... Hasta acá vengo haciendo todo si se dan cuenta en esta clase. Le hice yo el dibujo, le hice yo la primera dirección IP. Quiero que pongan su parte del problema para ver cómo lo resolvemos. Porque es un práctico de la materia. Está claro que... Primero, les digo, esto se puede resolver. Tiene solución. Tenemos un problema de software, en realidad, acá. ¿Qué es lo que nos está faltando? Nos está faltando poder... Agregarle otra IP. ¿Y a dónde hay que ir a buscar para saber si se puede agregar IP? En los links. Al manual. ¿A dónde? Por eso. ¿A dónde habría que ir a buscar? ¿Al manual de quién? De Mininet, la documentación de Mininet. Entonces, hay que ir a buscar la documentación. Lo voy a dejar acá, porque quiero que lo resuelvan ustedes. No lo quiero hacer yo. Así que vamos a hacer así. Este problema lo voy a cortar acá. Quiero que la clase que viene lo traigan resuelto. Pero traten de hacerlo ustedes. Es el mismo problema del año pasado. Si van y lo buscan, hagan el esfuerzo de poner la parte de ustedes. Están poniendo poco de parte ustedes. En serio, les pedimos, por favor, que repasen las cosas. Primero, todas las clases, quiero que entren antes de entrar a la clase y revisen su instancia, que estén las cosas instaladas bien, que estén prendidas. No podemos estar, "Ah, profe, que a mí no me conecta". Que a mí, ¿cómo fue la palabra que usamos? "No me engancha", dijo alguien. No es lenguaje cuarto año ese. Porfa. Me tienen que poner su parte. Porque no es una materia... Para que ustedes hayan una idea, es como si estuviéramos haciendo, teniendo que estar a explicarles cómo sumar y restar, y queremos hacer integrales con ustedes. Queremos ver cloud, queremos ver un montón de temas, pero la verdad que están muy verdes para que podamos ver esos temas. Pónganse todo a estudiar de cabeza. Profe. Sí. Una pregunta. ¿Por qué usted en Mininet, cuando hizo el diagrama, usó host y no ahí había una herramienta que decía legacy router? Porque no me deja cambiar el nombre. Y yo sé que es la misma. La primitiva es la misma, miren. Te lo muestro acá. Pero lo aprendí porque... lo aprendí... Es decir, quiero que piensen como programadores. Están pensando como técnicos. Como técnicos de la Academia Pitman. No están pensando con enfoque de programadores. Si yo hago esto, mira esto. Pongo un host y voy a poner un router. Lo voy a grabar. ¿Qué haría yo pensando como programador? Lo grabo. Le pongo test. Le pongo que lo exporte. Pongo un script, le llamo test. Y me voy a mirar qué metió en test. Perdón. ¿Se puso un switch? No, un switch. Me quería poner un router. Perdón. Esto es lo que quería hacer. Pongo un host y pongo un router. Ahora lo voy a hacer. Esto es lo que quería hacer. Pongo un host y pongo un router. Lo voy a grabar como test. Ok. Y ahora lo voy a exportar. Esto lo hicimos en la clase pasada. Pusimos host y router. Pero fíjense que si yo miro el archivo test. Pero... No. R3 es add host. Mirá. Y H1 también es la primitiva host. Es lo mismo. No sé si se ve. Sí, sí, sí. Está bien. Entonces, de hecho, esto... Acá hay un poquito más de pistas para cosas que ustedes decían. Esto es realmente lo que transforma a este host en router. Le está dando un comando al sistema operativo y le está diciendo que prenda el forwardeo de paquetes. Pero la primitiva es la misma. Por eso puse host. Es lo mismo. Me parece bueno para que traten de conceptualizarlo ustedes. La punta del ovillo es esa. Yo iría a buscar la documentación de MiniNet y debería ver cómo hago para sumarle algún IP. Pero quisiera que lo resuelva cada uno y lo compartimos la semana que viene. Porque el caso 2 lo tienen que resolver ustedes. ¿Ok? Perfecto, profe. Buenísimo. Siempre, siempre. Bien. Bueno, no sé si te parece, Juan. Si querés podemos retomar el camino en términos de teoría de que examinemos la parte de datagrama IP como para completar esta horita que queda. Dale, dale. ¿Te parece? Sí, bien, pa, pa. De paso, ya que los tenemos a los muchachos también, como para ir picoteando a medida que vamos viendo la cabecera. Hacer algunos ejemplos, hacer referencia a lo que tenemos en las consolas. Bueno. Dale, Barro. Dame un momento. Eso, dale, eso. Eso, volteé la pantalla. Tengo un momentico que... Tenés, creo que tenés en las diapos, las diapos que están en, pero no están visibles, está en las azules, creo que son. Está la... Ya te digo, Barro. Sí. Tele. Sí, era, va, ahí este... Sí, teníamos la diapos. Ah, está en la misma, está en la cabecera. Ah, sí está. No, sí que está. Hay que retomar en donde habíamos dejado el puntero, por decirlo de una manera. No, esto. Tenés, los que están en la cátera, en los que dicen... Perdón, los que dicen, en la sesión, que están en la sesión 3. De 2020. Sí, sesión 3, datagrama IP que está visible. Les slides de datagrama IP 0416, página 11. Eso, a ver, pará. Sí, claro. Ahí retomamos. Más específicamente para que saco... Presentar una ventana, a ver si le puedo... Siempre le pillo a la ventana que quiero presentar. Creo que es esa. No se puede compartir, permiso. Puto maco ese, la con... Perdón, estamos grabando. Sistema operativo del orto, por favor. Segundo. Ahí vamos. Si me permiten una pestaña. Ahí, quizás, ahí capaz. Ese es. Yo voy a acomodar que quede visible esa diapo para la sesión 4, que es la de hoy. Bueno, dale. Sí, totally. Sí, totally. Sí, totally. Bueno, para que me reorganizo un toque acá las... En realidad lo que debería hacer es... Un segundito. Vamos a necesitar sesión, lo que pasa es que tengo el escritorio lleno de otras cosas. Bueno, no importa. Eso no importa. Vamos switchando en todo caso entre una y otra. Bien. Entonces. Contexto. ¿De qué vamos a hablar ahora? Nosotros ya habíamos visto este diagrama, el que tanto hacemos referencia. Acá tenemos los end systems, acá en el medio los routers que hemos visto. Y lo que vamos a ver ahora es qué formato tiene que tener este datagrama IP. Que como bien decían ustedes, no cambia de origen a destino. En realidad vamos a ver que sí cambian unos pequeños bits, pero no cambia fundamentalmente. Entonces, como todo protocolo tiene que estar escrito de alguna manera. Y lo que vamos a ver ahora es cómo se escribe esa cabecera. Entonces vamos con la primera pregunta. ¿Cuánto mide esa cabecera sin opciones? Tal como la tiene en la pantalla. Así. Fresquito la pregunta, frío la pregunta. ¿Cómo es? ¿Cuánto miden de bytes? Pero para, ahora. Ponele presentar, Juan. No, no, ahí en el botón presentar, ponele que se ve la pantalla. Ah, listo. Está bien, perfecto. Porque se ve súper... Ah, ahí está. Ahí está. Bien, perfecto. Dale. ¿Cuánto mide la cabecera IP? Lo que estamos viendo son secuencias de bits. Sí, cada una de esas marquitas verticales. ¿Cómo se hacía acá para tener...? ¿Se ve mi cursor acá al mouse, no? Sí, se ve. Perfecto. Cada una de estas marquitas es un bit. Pero yo no voy a pretender que cuenten todos los bits. Tenemos alguna referencia de cuánto mide esto. Y acá tenemos... Lo que yo le pido es, ¿La cabecera IP vendría a ser todo este bloque? Acá, ésta. Y lo que le pido es que me digan cuánto mide... ...la cabecera IP. Podría ser los octetos, los bytes, que vamos a poner ahí en la cabecera para que lo que sea que cargue pueda viajar de origen a destino. ¿Cuánto mide? 32. ¿Qué? Bits. 32 bits es un renglón. Y eso no alcanza para la cabecera IP. De hecho, no te entraría en las direcciones de origen y destino de 32 bits, porque cada una es de 32 bits. Cada renglón mide 32 bits, porque vas del 0 hasta el 31. Así que ahí está numerado. 6, sin opciones. Está bien. Admito 6, pero no 6 bytes. ¿Cuánto es el ancho de este renglón? 4 bytes. Ok, ahí vamos. 4 bytes, que son 32 bits. ¿Cuánto es el alto de esto? 24 bytes sería. Ok, perfecto. Sin opciones yo les había pedido, porque las opciones, esto en realidad es elástico, es plástico. Sin el último renglón de opciones. ¿Cuánto mide la cabecera IP? 16. 20. 20, bien. 20 bytes. 20 bytes, porque tenemos 32 bits, que son 4 bytes de ancho. Y el alto acá son 5, sin opciones. Nuevamente son 5 renglones. 1, 2, 3, 4, 5. 5 por 4, 20. 20 bytes. Eso es mucho, es poco. Es el mínimo, ¿no? El mínimo, sí. Menos de eso ya no podés construir una cabecera, de hecho. Porque fíjate que el destination address es el último renglón. Y es el mínimo requerido. La pregunta es tramposita, como son nuestras preguntas, ¿no? ¿Es mucho, es poco, 20? La segunda pregunta, que es la que esperaría que ustedes me hubieran re-preguntado, es respecto de qué. Claro, sí, voy a decir. Bien, ok. Díganlo, díganlo. Respecto de qué, ¿con qué lo podríamos comparar ese 20 contra 100? ¿Contra 100? ¿Contra 10? ¿Qué es un número razonable de limitación que conocemos física, de tamaños de plotagrama, o de tramas? ¿Qué número les suena en la cabeza, así de decir, "y no, en esta red en realidad hay que meter", yo lo voy a poner entre comillas, "paquetes de hasta bytes". ¿Qué es? ¿Ethernet? ¿Cuál es la limitación de tamaño máximo de paquete de Ethernet? ¿1500? 1500, perfecto. Perfecto, 1500. Bien, redondemos así, muy a lo bruto, porque a mí me gusta que tengamos órdenes magnitudes en la cabeza, no me hacen falta los números exactos, pero al menos en este contexto, órdenes magnitudes, pongámosle 2000. Y esto mide 20, quiere decir que es un 1%, poquito más, porque es 1500, 1,5% de cabecera respecto de todo lo que yo puedo llenar una trama bien, bien llena en Ethernet. De 1500 yo ocupo 20. Entonces, ahora va la pregunta, es chico, grande, ¿qué les parece? Chico. Chico, ¿no? Bien, y es algo... Perfecto, y es algo que buscamos, ¿no? Voy a decir una estupidez, si la cabecera tú mira 1000 bytes, te ocuparía más la cabecera que lo que podés cargar, nuevamente en una trama, en la tecnología más común difundida que es Ethernet. Sabemos que IP es independiente del medio, pero IP trata como es el medio y trata que sus datagramas entren... Yo voy a ponerle el poder entre comillas, "cómodos" en la trama, en las tramas de las redes que usa. En trama de Ethernet, 1520, bien chiquitito. Perfecto. ¿Qué onda si yo tengo que transferir un archivo, por ejemplo... Pongámosle, vamos a hacer números súper redondos, ¿no? Son 1500 bytes que tiene, un archivo de 1,5 mega de una máquina a otra, conectar a la misma Ethernet. ¿Hay algún problema si transfiero de un byte, con paquetitos de un byte, versus tratar de mandar paquetitos de 1500? ¿Es lo mismo? Y si mando muchos paquetes, ¿va a haber mucho trabajo en el medio para redireccionarlos? Para procesarlo, no sé si redireccionarlo. En este caso, el ejemplo que di, las máquinas estaban en la misma red, así que no hay ninguna redirección. Pero, ¿dónde pongo el estrés? ¿Cuál es el escenario? Estoy comparando. Tengo que mandar, a ver, números. 1500 bytes, tengo que mandar un archivo de 1,5 mega. ¿Cuántos, si llenado a todas esas tramas, cuántos paquetes son? ¿Diez? De 1500 bytes a 1,5 mega, tengo... Si divido 1,5 mega, divido 1,5k, tengo mil. ¿Sí? Mil. Muchachos, también, orden de magnitud, matemática. Es otra cosa importante a tener en cuenta. Bien, mil. Mil paquetes y yo logro llenarlos completos. Si en realidad, si en vez de eso yo... Imagínense una aplicación, nuevamente insistiendo mucho en lo que siempre insistimos, especialmente Diego, haga una aplicación que básicamente hace un while read del archivo, lee un byte y escribe un byte. Y fuerza que ese byte viaje por la red, ¿no? While read character del archivo abierto, le envía un character por la red. ¿Cuántos paquetes usaría para este archivo de 1,5 mega? ¿Un mil? ¿Lo dijimos los 100, no? Sí, sí, pero si los escribo de un byte. ¿15 mil? ¿Puede ser? No. 15.000.1,5 mega es un millón y medio. Un millón y medio de paquetes. Estamos hablando de un millón y medio de datagramas versus mil datagramas. ¿Qué quiero estresar con esto? Y es algo que van a ver que comúnmente hacemos de ir a los extremos para entender cuál es el problema. Acá hay un problema que nosotros vamos a ver en todo el stack de protocolos, que la primera optimización que tenemos que hacer es tratar de usar al máximo lo que el medio nos provee. En este caso, Ethernet, por ejemplo, nos va a proveer 1.500 de tamaño de trama. Entonces, van a ver que el protocolo en general, sobre todo los protocolos de transporte, van a ser un millón y medio de protocolos. Y en general, sobre todo los protocolos de transporte, van a ser un esfuerzo importante para tratar de llenar esas tramas, hacer unos datagramas lo más grandes posibles para evitar el overhead de las cabeceras. Porque si a mí me pesa mucho más la cabecera que lo que transporto, ¿cómo sería, por ejemplo, en números, un datagrama que está llevando un byte de una punta a otra? ¿Cuánto me diría? Dejemos la parte de transporte de lado. Imaginemos, lo cual no es cierto, porque faltan otras cabeceras, pero por ahora, con lo que conocemos hasta ahora, si pudiera mandar un byte a través de IP, así, genérico, ¿cuál sería el tamaño total de ese datagrama final y cuánto ocuparía la cabecera? 21 y 20 en la cabecera. Claro, una locura. Sí, exacto. Uno sobre 20, estábamos hablando de un 5% de uso del paquete, ¿no? En datos. 95% de lo que ocupa la cabecera, un 5%. Entonces, ¿se entiende? Estas cabeceras nos van a servir para transportar el paquete, pero es importante el esfuerzo que va a hacer todo el stack para tratar de hacer que el payload, ¿qué es payload? La palabra payload, ¿qué significa en inglés? Carga. Carga, perfecto. El payload es lo que va detrás de esa cabecera, ser lo más grande posible. Bien, vamos entonces. Arranquemos. Lo que vemos ahí es una secuencia de bits. Ustedes ya han visto, el año pasado han hecho Wild Shark, creo que han hecho y han visto la cabecera, y le han desplegado a la cabecera. Lo que estamos viendo ahora es ese formato. Estos son todos bits, uno tras otro. ¿Yo puedo hacer overlay acá? No, no puedo hacer overlay, no. ¿Ves qué quería hacer? No, que quiero escribirle arriba esto, debería irme. ¿Me copias la diapo? Porque quiero anotar la cabecera, pero la quiero anotar sobre el whiteboard. Ah, ya te la busco. Ya te la busco. Acá ya te la busco. No, acá estoy haciendo la copia. Si me pasás nomás la-- No, la voy a buscar en la RFC. Que es el Arteaki. No, no, no. En realidad, lo que quería era que me pases de vuelta el link del whiteboard. Pero acá lo tengo. Acá creo que lo tengo. No, todo bien. Ah, o debería estar acá como el Jamboard. No, abrir otro. Bueno, como quiera, abrir otro. Si abro otro, dale. Dale, dale, José. Un segundito. Yo ya estoy pegando la pizarra del otro que hicimos. Así que-- Ah, empiezo una pizarra nueva. Dale, perfecto. Dale. Compartir. Ahí viene una pizarra, pero seguramente acá tengo que hacer un share this tab instead. Ahora, ¿se ve la pizarrita esta? Sí, ahí se ve. Sí, se ve. Perfecto. Buenísimo. Voy a pegar entonces acá. Vamos, niño. Ahí está. Excelente. Esto es lo que quería. Porque voy a borronearlo un poco. Vamos a borronearlo, ensuciarlo un poco. Bien. OK. Versión. ¿Qué versión de protocolo estamos estudiando ahora? ¿Qué versión de IP estamos estudiando ahora? 4. Versión 4. Bueno, entonces díctenme cómo tengo que escribir los bits acá en donde dice versión. Me van dictando, por favor. 0100. ¿Por qué es eso? Acabo-- Alguien me dijo 01. A ver si lo puedo hacer con otro color. Un segundito. Switchar color. ¿Cómo se switcha color? Ahí en el texto mismo. Uno, teniendo apretado. Arriba, arriba en la letra, mirá. Ahí está la A. Arriba en la barra al lado de normal. Ahí cambiá el color de la letra. Ah, perfecto. Gracias. Buenísimo. Ahí vamos. Ahora. Vamos a ver si se ve bien. Entonces, alguien me sopló ahí que yo debería escribir acá. 01. ¿Cómo era? 00. Vamos a poner con un bold. No sé si puedo bold. Me parece que no. No, lo que pasa es que se me va a ir demasiado el tamaño. Déjame ver si lo puedo boldear con Control + V. No. Bueno, no importa. Se ve ahí. ¿Por qué es 0100? ¿Qué tiene mágico ese número? Yo se lo soplé acá al compañero. ¿Qué es 0100? 4 en binario. Ajá. Y ¿cómo tendrá que escribir ahí IPv6? 0110. 0110. Perfecto. Bien, perfecto. ¿Qué tiene que hacer? Imagínense que ustedes son el, yo voy a decir así entre comillas, el driver de IP, digamos, o la implementación del stack, a la cual el driver de ethernet le dijo, uy, acabo de detectar que lo que cargo yo, yo si soy ethernet, he visto una trama. Le saco la cabecera al trama y tengo un payload que es el protocolo de capa superior, el protocolo de capa red. Detecto que es IP y se lo tiro IP. IP, este es tu problema. Imagínense que IP tiene una función de entrada que es receiveDatagram, IP receive. De hecho, así es en el kernel del Linux más o menos. ¿Qué es lo primero que tiene que hacer? ¿Qué pasa? ¿O se los pregunto? ¿Cómo, perdón? Leer la versión. OK. Esa va a ser una de las cosas. Tienen que hacer varios chequeos de integridad. Igual que cuando un usuario, fíjense la analogía. Cuando un usuario que ustedes le permiten hacer un input, tienen que limpiar ese input. Acá el input de la función es todo este datagrama que puede venir con cualquier cosa. O alguien exige que lo que entra en la placa de red tenga determinado contenido. >> Y el protocolo le exige que tenga. >> Sí. Pero cualquiera te puede escribir verdura ahí. De hecho, hay maneras de, había, cada vez menos, maneras de hacerle pantallas azules de pánico a algunos sistemas operativos si le escribías cosas incorrectas ahí. Porque faltaba el chequeo de input. ¿Sí? >> El frame check sequence. >> ¿Cómo, perdón? >> Es el frame check sequence. Eso. >> Pero vos fíjate que eso lo único que hace es chequearte la integridad de la trama respecto de lo que escribió el origen sea correcto. Ahora, ¿qué tal si el origen es un atacante que te puso verdura ahí a propósito para hacerte fallar tu, digamos, el driver de IP, por decir, o la función de recibir IP? Porque sabes que el sistema operativo tiene una falla que se le ponga un bit acá o allá, pum, explota. ¿Sí? >> Entendido. >> Entonces, el punto es, todo lo que vamos a ver ahora es importante porque es lo que hace el sistema operativo. La primera operación es desconfiar de lo que recibe. Igual que cuando ustedes hacen un mini input box, creo que todo, ¿no? Tenemos esa actitud. Hay que desconfiar de quién está del otro lado. Porque el que está del otro lado bien podría ser un atacante que puede tratar de hacer un punto y coma, select asterisco from password y traerse todas las passwords de mi aplicación web. Si no, hice un chequeo de integridad de que no tenga determinados caracteres raros lo que me hacen de input. Nuevamente, este es el equivalente. Entonces, entre los chequeos están tamaño, tamaño máximo 20 como vimos y este tipo de cosas. ¿Qué debería ser el protocolo si acá viniera, no sé, 1111? >> Lo agropea el paquete. >> Bien, perfecto. Porque no existe IPB. ¿Cuánto sería el 111? IP versión. >> 9, 9, no, 7. >> No, versión 15. >> No, versión 15. >> Versión 15. IPB 15 no existe, por eso 111 sería incorrecto. Bien, ahí vamos. Se va viendo más o menos por dónde voy. Las diapos en realidad tienen la descripción de esto, pero a mí me gusta hacer esto interactivo de ir y entender cómo está esto escrito. Yo voy a ir salteando de nivel de dificultad las distintas cabeceras. Hay dos cabeceras que son obvias acá. Vamos a ir ahora a esas que son source address y destination address. Acá va a estar la secuencia de bits, obviamente, que representa la dirección IP, que como sabemos, la dirección IP son de 4 bytes, 32 bits, que entran justito obviamente en este renglón. No hay mucho para decir al respecto, excepto cosas como, por ejemplo, ¿cuándo ustedes no admitirían un paquete que acaba de entrar a través de la ethernet? ¿Qué destination address para ustedes sería? Esto huele a verso. Y bien, no, lo descarto. Con un criterio similar a que estos bits estuvieran todos en uno, por ejemplo, de la versión. Un destination. Sí, mi amor. Sí. ¿Cuál podría ser un destination address que decen, no, esto no está bien? La source address. No se me ocurre la verdad. Bueno, es buena, es buena. Alguien que vos veas entrar por el link, uno que tiene el source y el destination, igual suena tramposo, sospechoso. Gracias por las palabras esas. Por ejemplo, podría ser 0, 0, 0. Todo el destination address, todos los bits en cero. No hay un destination address que sea eso. No es ni un broadcast. No es ni una dirección de red. En realidad, como sabemos, es como se pone en una ruta por default. Nuevamente, acá solamente quiero mostrar el hecho del laburo que tiene que hacer la función de entrada desde un datagrama IP respecto al chequeo de integridad. Sigamos con los campos. IHL es Internet Header Length. Medido en renglones. ¿Cuál es el valor mínimo que tiene que tener el IHL? 5. Correcto. ¿Qué pasa si ahí dice 4, por ejemplo? 4 sería también 0, 1, 0, 0. Está mal. Me está verseando. Y tengan presente que es el tamaño de la cabecera, ¿no? No de todo el datagrama. Solamente la cabecera medido en renglones. Quiero decir que acá sí o sí, acá esto va a tener que ser siempre mayor e igual que 5. ¿Sí o sí? Si es 5 tampoco tiene mucho sentido, ¿no? Porque sería como una cabecera suelta que no tiene payload. La idea de IP es que siempre cargue con payload. Pero, bueno, vale el hecho de que es como para recalcar que esto tiene 5. Type of service, vamos a venir después. Total length es todo el tamaño, el tamaño completo posta, real, de un datagrama IP desde acá, desde el primer bit hasta el final. Porque fíjense que total length no es payload length. Entonces ahí va la pregunta, ¿cuál es el tamaño máximo de un datagrama IP? ¿Cuántos bits tengo para expresar ese tamaño? 32. No, fíjate cuánto mide total length. 8 bits. Ah, no, conté otro. Conté otro. Cuánto tenemos ahí. Recuerda que mide 32 todo el renglón y está justo la mitad, por lo tanto este mide-- 16. 16 bits. OK. ¿Cuántos-- expresado en números decimales, cuánto es? 16 bits. ¿Qué cálculo tienen que hacer si tuvieran una calculadora con capacidad binaria? 2 a la 16. OK, 2 a la 16. Regla mnemónica. 2 a la 10 es 1024. 2 a la 10 es 1024. Si ahí le sumo 6 bits, es como 2 a la 6 más. 2 a la 6 es 64, eso es 64K. De todas maneras, estas potencias, 2 a la 16, 2 a la 32, es como que son potencias, es como que casi que ni siquiera habría que pensarlas. 2 a la 16 son los 64K. Entonces, esto lo vamos a anotar acá. Esto tiene un máximo de 2 a la 16, que es igual a 64K. 64K, obviamente estoy redondeando, son kilobytes, pero son 65,532. Bien. Fíjense que eso-- listo. ¿Qué pasa si yo tengo que mandar un archivo que mide más de 64K? No me sirve bien. OK. ¿Quién lo rompe? ¿Quién lo manda? Bien. Está bien. ¿Pero qué capa lo rompe? ¿Capa 3? No. ¿Por qué? Porque tengan presente que, y acá vamos de vuelta al stack, tengan presente que nosotros teníamos enlace, capa de red, que es lo que estamos viendo ahora, capa de transporte y aplicación. La capa de transporte es la que se va a encargar de hacer todas esas adaptaciones. Vos como usuario, uno como usuario, le voy a decir a la capa de transporte, mirá, yo tengo que enviar esto, un archivo, como decíamos recién, de 1,5 megas. Tu problema, ¿cómo te lo arreglas para vertela con el que tenés abajo? Capa de red orientada a paquetes como esta, con determinados tamaños máximos. Entonces, la capa de transporte va a ser la que va a hacer de alguna manera, si quiere, el adaptador entre una vista más continua de lo que yo puedo hacer respecto a lo que me permite como limitación en sí la capa de red. Eso para el caso de protocolos como TCP. Pero vamos a ver que UDP lo conocen, UDP, el otro protocolo, en realidad, tiene una capa de transporte que no enlaza datagramas entre sí. Por lo tanto, UDP tiene como limitación máxima, máximo de 1,64K, porque solamente puede entrar un solo datagrama IP cada paquete UDP. Bien. Vamos a seguir, vamos al time to live y nos vamos a ir a la, vamos a saltar a la consola. Un segundito, déjenme, quiero ver si puedo instalar, hay una extensión que me permite hacer, buenísima esa extensión, Chrome SSH extension. Por alguna razón acá el Mac que estoy usando, duro, no me está permitiendo compartir otras aplicaciones, otras pantallas de otras aplicaciones. Por ese problema que tengo. Un segundo. Pero déjenme ver si, SSH2.arroba, un segundito, ¿dónde tenía? ¿Cuál era el IP que yo tenía acá? 3.251.3.25. Terminal. Launch app. Acá está. New connection. Arroba. No. Segundito. Ah, no, claro, no. Un segundo, me voy a tener que tomar el tiempo para poder compartir esto. Vamos a parar esto. Presentar ahora, porque esto de todas maneras lo voy a necesitar en alguna otra ocasión. Así que vamos con esto. ¿Dónde están las preferencias de sistemas de porquería? OK. Me sorprende mucho que todavía consideren que es user friendly este sistema operativo. En serio, se rasgan la vertidura de que es user friendly. No deja compartir el script. No, sí, pero por ejemplo, ahora que le permito a mi browser compartirlo, me está diciendo quit and reopen. Tengo que salir del navegador y reabrirlo para poder darle permiso de compartir. No. Voy a tener que hacerlo, así que ya vuelvo. Fíjense esas cosas. Le han dado una Mac en el trabajo y está rabiando con la Mac. Se está intentando negar con el sistema operativo. No, no, está negado. No, no, no. En realidad, bueno, no sé si le ha pasado. Si usas Linux durante mucho tiempo, hay cosas que te resultan muy incómodas porque son muy fáciles de hacer cuando te acostumbras a hacerla. Sobre todo el uso de la terminada en Mac no es lo mismo. La verdad que es verdad. No sé, también parece que está sobrevalorada para los desarrolladores el uso de-- Pero, bueno, como que le gusta. ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Qué pasa si no te gusta? ¿Por qué se le ocurre a ustedes que hace falta eso? Porque por si hay algún error de enrutamiento que no esté saltando de router a router infinitamente. Ok, que se me arme un loop, pero ¿eso es posible? ¿Cómo puede estar tan mal diseñado IP? ¿Es posible, por ejemplo, tener, imagínense, súper simple un triángulo entre routers en el cual la ruta por default, la 00/0, apunte mutuamente entre sí? Entonces un datagrama que entra... ¿Se ven mis manos, no? Sí. Sí, perfecto. Bueno. Un datagrama que entra, imagínense, el triángulo, un datagrama que entra por la punta de arriba del triángulo, va a este y dice "ah, el default router es este al lado", "ah, el default router es este", y el datagrama queda acá atrapado infinitamente. ¿Es posible que las rutas estén tan mal así? Sí, ¿por qué no? Sí, acá yo tengo dominio de administración distinto, también puede ser un error humano, un error de protocolo de ruteo. Como bien hemos estado viendo, uno como humanos, tiene el poder de crear estas entradas en la tabla de ruteo, cada una de las entradas, y bien, pueden estar mal estas entradas, entonces, ¿qué pasaría con un paquete si no tuviera algún mecanismo para evitar esto? Sencillamente estaría ahí para siempre, cada nuevo paquete aumentaría, aumentaría, aumentaría, y hace rato no tendríamos internet si no tuviéramos un mecanismo para evitar eso. Ustedes lo están diseñando ese mecanismo, tienen ese campo que se llama "time to live", voy a volver a presentar en realidad esa... Así lo vemos entre todos. Segundito. ¿Cómo alcanzo con una pestaña? Con esto. Acá... Presentar. Estamos hablando de este campo "time to live", que en realidad no es tiempo, porque acá no hay ningún timer, como ustedes pueden ver en la cabecera no hay ningún tiempo de envío, tiempo de recepción, ni nada, ¿no? Esto es "timeless". ¿Cómo lo diseñarían ustedes eso? Si ya saben cómo funciona, por favor no lo cuenten, no me spoileen. ¿Cómo lo diseñarían ustedes para proveerle a IPS mecanismo de autoprotección frente a eso? Ese es el detalle que usted había dicho que sí cambiaba dentro del paquete. Va a serlo, pero eso es un coro horario de que alguien me cuente cómo funciona. Sí, ese es el que cambia. Piensen que lo están diseñando ustedes, piensen que... Y esto es súper importante, porque esto refuerza el hecho de que esto es "stateless". El problema de cada router, recuerden, empieza y termina con haber forwardeado el datagrama de una interfaz a otra. Me saqué de encima, me llegó, "¿Quién es el próximo?" Se lo tiro al próximo, siempre asumiendo que no se están conectando a mí, no me están administrando como router. Mi problema como router es levantar un datagrama, ver cuál es el destino, y patearle el problema a mi próximo router, o si es el host final, porque yo soy el vecino del host final, tirárselo al host final. Pero mi problema es sacarme los datagramas de encima rápido y pasarlos. Mi problema empieza y termina en cada datagrama. Yo como router tengo posibilidad de escribir esta cabecera y voy a tener permiso de todas las cosas que no puedo escribir, no puedo tocar esta cabecera, voy a tener permiso y voy a deber tocar esa cabecera "time to leave". ¿Sí? Con esa especificación, ¿qué harían ustedes? ¿Cómo, qué reglas pondrían, cómo lo harían para evitar esto que estamos hablando de que llegue un punto en el cual pueda quedar para siempre loopeando datagrama IP? Y cuando se manda empieza con todo en cero, y cada vez que se abre le va sumando uno y cuando llega al límite lo dropea. Bien, bien, podría ser. Bien, está muy bien, está muy bien. En realidad es exactamente al revés, pero está muy bien. Está al revés, claro. Pero bueno, pero eso, ¿por qué es al revés? ¿Cuál es la razón de que sea al revés? Ojo que lo que acaba de mencionar tu compañero, vaya para arriba o vaya para abajo, está muy bien en ambas maneras. Lo primero que hay que hacer es ver qué número tiene. Si es cero, y si dijimos que iba al revés, cuando llega a cero, alguno lo encuentra en cero, lo descarta. Bien. Ojo que está muy bien lo que dijo tu compañero. Bien, podría arrancar, por ejemplo, ¿qué pasara? Vamos a hacer todo el proceso completo. ¿Qué pasara si lo arrancáramos en cero? Siempre. El origen siempre lo pone en cero. ¿Cuántos routers como máximo podría flipar o irse forwardeando hasta que directamente el router, que es el número dentro de esa secuencia de routers, diga, no, loco, ya, ya, se le acabó la nafta a este datagrama? Dos a la ocho veces. Correcto, correcto. 255. 56, pero 255 porque hay uno que va a tener que arrancar en cero y se va sumando y cuando vea todos los bits en uno, lo dropea. Bueno, ese bien podría ser un criterio. Se eligió el criterio de ir para abajo porque no necesariamente queremos que explotar las 255 posibles forwardeos. ¿Cuánto debería ser un número razonable de veces que yo le dejo un paquete de IP pasar por un router? En base a que, ¿cuál es esa escala? ¿Qué le ponemos? ¿2, 10? ¿50? ¿20? Una vez. Quiere decir que si yo mando un paquete a la Internet, pasa por el router acá de mi IP y se dropea. Se le acabó la nafta. Sí, sí, sí, entendí mal. Bien, piensen en el type to leave como la nafta que ustedes le ponen a este datagrama que tiene que pasar. Esa nafta se gasta uno por cada router que pasa. Entonces, el mecanismo es justamente va a cero y quien envía el datagrama tiene la total autoridad para ponerle ahí la cantidad de nafta que quiera. ¿Cuál sería un valor razonable de nafta o comparable con qué sería ese valor? Le ponemos. No depende de a dónde queramos ir en la nafta. Sí, sí, sí, exactamente. Entonces, ¿contra qué debería compararlo así a grandes rasgos? Contra la cantidad de routers. ¿Qué hay entre el inicio y el destino? Entre todos los posibles inicios contra todos los posibles destinos, ¿no? Ah, sí. ¿Sí? OK. Bien. Bueno, básicamente lo voy a decir de lo bruto. El máximo ancho que tenga la Internet medida en routers entre cualquiera puntos. ¿Sí? Ese número, que en realidad es un número que, pobre protocolo, no depende de protocolo, depende de cómo esté el despliegue del routing, la interconectividad de la Internet completa. Ese número más o menos se encontró, se definió que no tiene que ser más de 30 ish, 40. Entonces, hay una RFC que dice que por default todos los iniciadores de un datagrama, los que crean un datagrama IP, le ponen 64. Así. 64. ¿Sí? Uno lo puede ajustar a eso, pero el default es 64. Quiere decir que 64, 63 y se va a ir consumiendo y cuando toca 0, ¿cómo sería la situación? ¿Cuál de todos estos routers, el router que observa eso y dice, "Ux, se te acabó la nafta, flaco, te tiro"? El 63AU. Bien. ¿Qué número va a levantar desde la interfaz por la cual le llega? ¿Qué número va a decir el TTL ahí? O sea, va a ser 7 ceros y un 1 al final. Correcto. 1. Y como la regla es, yo como router te decremento eso en 1 y te dejo seguir y como básicamente ya es 0, se te acabó la nafta. Listo. Dropeo el paquete. El router que observa que el TTL es 1, dropea el paquete. Porque ya básicamente se le acabó la nafta. Entonces, ¿cómo se le ocurre a ustedes que podemos hacer una aplicación tal como... Y ahora sí voy a compartir de vuelta la pantalla, la ventana del Shell. Ahí dice "route -n" Vamos a hacer 3 routes y después vamos a meterlo. Para lo cual ustedes van a tener que hacer lo mismo. Tener sudo apt install Está medio pequeña. Si la podés levantar un poquito. Sí, como lo negro. Ahí vamos. Dale. Se ve mejor en el video. Ahí está. ¿No? No cambió mucho. ¿Eh? Qué loco. Ah, me debe estar cambiando... Claro. Me está cambiando el tamaño completo de la pantalla. Ahí. Ahí. También cambia el tamaño de la pantalla. Ahí va. Ahí mejora. Perfecto. Bueno, ¿qué fue lo que hice? Instale la aplicación esta 3 routes. Voy a hacer esto. 3 routes -n Luego... ¿Cómo? Ahí estamos. Bien. Esa aplicación 3 routes, 3 routes, en realidad abusa de ese campo TTL de la siguiente manera. Cuando un router descarta, porque se le acabó la nafta, no solo descarta sino además ¿qué hace? ¿Qué les parece? Hemos hablado tangencialmente... Devuelve un mensaje que dice que se rompió. ¿Y con qué protocolo devuelve ese mensaje? ¿Recuerdan el nombre del protocolo? ¿UDP? No, ese es un protocolo de transporte y esto es RED. Esta es la RED ayudándose con otro protocolo hermano de RED, el helper de IP, que lo usa para reportar problemas. ¿CIDR? CIDR en realidad es la anotación IP/Máscara. ¿ICMP? ICMP. Recordemos que, y acá viene lo importante entonces, recordemos que la capa IP en sí, el protocolo IP es el que mueve datagramas, pero tiene de respaldo, de ayuda, un protocolo ICMP que también es carga de IP, es payload de IP, pero lo usa para que la RED reporte problemas. Cuando se le acaba la nafta a un datagrama, el router que descarta reporta al origen el problema diciéndole "che, tuve que descartar este datagrama porque el TTL se le acabó". ¿Qué estamos viendo en la pantalla? En la pantalla estamos viendo una traza de las IP de los routers para llegar a determinado destino. Si yo hago un ping acá, ping, doble doble, google com, si ustedes ven es este destino que está acá, que es el mismo de este último destino. Pero a mí me interesa ver cuáles son las IP de los routers que están en el medio, de los intermediarios antes del destino. ¿Cómo usarían ustedes entonces todo lo que acabo de comentar en estos últimos minutos para construir esta aplicación? Esta. Y voy mandando, mando un paquete con un TTL de uno, y después me va a devolver a donde llegó, después le sumo al TTL para dos, para tres, hasta que llegue al destination adres. Ok, y ¿cómo? Ahora vos cuando envías ese, envías por ejemplo un paquete, imagínate que lo haces como un equivalente a un ping, pero vos envías un ping y ¿qué recibís a cambio? ¿El pong? Sí. Bueno, ahí va el punto. Ese ping, ese paquete, ¿a dónde va? ¿Cuál es tu destino? Pensá que vos lo único que sabes en este momento es a dónde querés ir. Lo voy a poner con IPs así no me mete ruido los nombres. Vamos a poner con IPs, una IP de Google, de una pata de Google acá de Buenos Aires. No, no, capaz que es de Rodríguez Peña, me parece. Diego sabe más de esto, capaz que está acá nomás. De qué cosa. No, no, la pata de, no sé si Google al final tiene un POP acá en Rodríguez Peña, acá en el... No, me parece que no. Ah, ok, ok, entonces Buenos Aires. Bueno, anyway, no importa. Piense que para el momento en que yo, yo soy la aplicación de Route, 3Route, me han pasado esta IP, yo lo único que sé es esto. Desconozco totalmente esto. Por lo tanto, yo voy a construir un datagrama IP que va a tener como destino final, el destino que me pasan, como nosotros ahora con el diario del lunes vemos que es un destino muy remoto, pero la aplicación no sabe cuán lejos está. Entonces, construye, por ejemplo, un paquete ping con ese destino. Como bien decía su compañero, le pone ttl=1, es decir, nafta=1. ¿Y qué le va a ocurrir? Cuéntenme cuál es la vida de ese datagrama. Llega el primer hop y ya se que hace un nafta, entonces tiene que devolver una... Perfecto, entonces el primer hop, el primer router lo descarta y devuelve, ¿qué cosa? El pong. No devuelve un pong, porque si devolviera un pong estaría jugando con el... ¿Quién es el único que devuelve un pong acá? El destination address. Claro, cuando yo logro un pong es que ya llegué, pero en el medio yo me fui topando con piedras. Yo tiro un ping, el que me hace pong, y el único que me puede hacer pong es el destino final. Todos los del medio básicamente me fueron insultando en el medio, me fueron diciendo "no llegaste". Entonces yo, lo importante de esto es yo le apunto al final, pero le pongo poca nafta a propósito para que cuando se le termine el ttl, ese router me reporte. Entonces yo acá en la aplicación lo que observo es... ¿Cómo yo como aplicación 3Route puedo escribir esto acá? ¿Qué es lo que leí de este router? Y de este y de este. ¿Qué fue lo que... qué es lo que fui leyendo? ¿Cuánto tiempo tardó en... No, el tiempo es lo que está después, pero fundamentalmente... ¿El reporte de error? Claro, el reporte de error. ¿De quién viene el reporte de error? Yo le apunte allá lejos y en realidad hay alguien en el medio del cual yo desconozco. Piensen que para el momento en que yo escribo y pongo esto no tengo la más absoluta idea de estos. ¿Qué sé yo que son estos? Ni idea. Si no, sencillamente los voy descubriendo porque justamente son los que en el medio me han ido reportando que se le ha terminado el ttl. Entonces la aplicación 3Route es un gran loop en el cual lo que va haciendo va incrementando el ttl de 1, 2, 3, 4. ¿Y cuál es la condición final? Como veo que yo me ya me spoileé, pero bueno. ¿Cómo sé yo que ya llegué al destino? Recibiendo el pong. Recibiendo el pong. Recibiendo el pong y yo digo "ah, listo, ya está, ya los descubrí a todos". Hay una versión, Linux viene medio que bastante por default. Fue una versión un poco más interesante que es mtr. Básicamente hace lo mismo pero de una manera más interactiva. Como ven aquí, en realidad en vez de ser un single shot, un disparo único como fue recién y listo, es como un continuum. Entonces es muy, muy útil para cuando uno está bugeando problemas de red. Porque si uno ve los, fíjense que acá les va mostrando los a medida que ocurre. Si acá hubiera algún tipo de pérdida en el medio, vamos a probar algún destino mucho más lejano, como por ejemplo Japón. Fíjense que ahí hay uno que me está reportando los, acá en el medio, que no necesariamente puede ser que este router de acá esté decidiendo a propósito no reportar tanto por una cuestión de autoprotección frente a ataques. ¿A qué destino le puse? Le puse .co.jp. .co.jp sería lo más parecido al destino por default com de Japón. Uno siempre elige Japón cuando quiere pensar en lejos. ¿Cuántos routers hay en el medio? 20. 18. 19. Porque este acá en el cero soy yo, en el este el destino final, así que serían 19 routers en el medio. Y fíjense también, no está relacionado con lo que estamos viendo en la cabecera, pero también es útil entender un poco aquí las latencias. ¿Cuándo les parece que hemos cambiado de continente? ¿Dónde ven ustedes que hemos entrado en una estiróptica que cruza el...? ¿Por qué? Por el... aumentan ahí los average. Bien, estos son en milisegundos. Y fíjense, el orden de decenas de milisegundos estamos hablando de tierra cercana. Estamos hablando de esto, seguramente la salida de Buenos Aires. Estoy adivinando acá, esto posiblemente sea Brasil o algo por el estilo. Y acá fíjense el salto, 100 milisegundos. Estamos hablando de que hemos posiblemente entre esos dos está todo un cable subterráneo que va quizás desde una pata de Brasil hasta alguna pata en Estados Unidos. ¿Ven algún otro salto por el estilo en donde estemos saltando de continente? Y después, o sea, va de la red 176, después va a la 5. Sí, no, eso sí, pero fíjense que ahí no hay un mapeo... ¿Está bien lo que decís vos? Los periféricos podrían ser, pero están mezclados números, es decir, direcciones IP crudas con DNS. En la 14 a la 15. Ajá, la 14 a la 15 está interesante. Fíjense que hay otro salto de 100 milisegundos. Es muy posible que acá esto sea Estados Unidos y acá... No, no, no, no, no. ¿No sería Japón por el DNS? ¿Cuál? En la 15 y en la 16. Bien, sí, suena a JP. Sí, porque cambia de US a Japón. Y esto en realidad, este CA es seguramente por California. Ahí no sé qué toca, no son los... Esto debe ser costa oeste de Estados Unidos, este. Acá US dice clarito, acá dice .jp. Pero no sé lo que... Ahí les voy a... Ahí, ahí les dice trampa. Está bien eso, porque puede servir de hint, pero yo quería que nos enfocáramos en esto. ¿Sí? Acá. Fíjense que acá nos ha servido para medir la latencia. Entonces, ¿a qué voy con esto? ¿Qué está aplicado? Yo estoy apretando la tecla N que me switchean entre ambas. Por cierto, esto lo pueden hacer ustedes también. Esa era la idea de que lo hagamos en la cloud. Cosa de mostrarles que ustedes también pueden ir haciendo eso si quieren probarlo. Fíjense que acá ya estamos... Ya se está reportando algún loss ahí. Pero les quería mostrar esto, ¿no? De las latencias de las que estamos hablando. Y también un poco los órdenes de magnitud. Fíjense que un TTL de 64 por default, con esta muestra que estamos haciendo de Argentina-Japón, que tiene que cruzarse un buen pedazo de la internet, estamos hablando que tenemos 19, 20 routers entre medio de los dos. Así que 64 es un número que todavía es seguro. Y es el número... Y es la razón por la cual también... Si en algún punto la internet midiera en alguno de sus máximos 70 routers, habría conexiones fallidas realmente. Empezaría, ocurriría esto, no llegarían las conexiones porque hay una RFC. Recuerden que las RFC son las normas, si se quiere, que se han discutido y que establecen cómo tienen que comportarse y cómo se escribe el protocolo. Hay una RFC que dice específicamente que el default es 64. Bien. Y ahí, profe, había 80% de los de paquetes. Sí, como les decía, ahí eso puede ser una actitud de seguridad acá. Este router en particular puede estar decidiendo no reportar el 100% de los errores, sino solamente un subporciento. Porque fíjense que hacia adelante no hay pérdida, es solamente en ese punto. Si acaso tuviera pérdida y la observara el mismo grado de pérdida hacia adelante... ¿No estoy compartiendo? Sí, estoy compartiendo. No, sí, pero recién había también una pérdida. Sí, en uno había un 5%. Me pareció que eran los cambios de continente que habíamos hablado. Igual es que el número de pérdida no lo tomen... Por eso estaba justamente completando la idea. Acá bien puede ser una configuración de seguridad de este router que decida solamente reportar un subporcentaje de ICMP para evitar ataques. ¿Qué es lo que le quería decir? Una cuestión meramente física. Si de este router, si hacia este router hubiera pérdida en el link, yo debería observar esa pérdida propagada hacia adelante. Porque si tengo pérdida hasta ese router, tendría pérdida ese router para atrás. Entonces, un feedback interesante que uno tiene para observar si es que el router está decidiendo no reportar todo, o si es que efectivamente tengo pérdida, es, entre comillas, ¿cuánto se arrastra esa pérdida hacia atrás? Si yo leyera 80% acá y acá y siguiera leyendo en ese orden de magnitud 70, 80 hacia atrás, entonces diríamos, sí, estamos teniendo pérdida desde ahí en adelante. Pero si como estoy leyendo 0 hacia atrás, efectivamente está súper limpio, está buenísimo, no estamos teniendo nada de pérdida. Simplemente que este guacho está decidiendo, este, el 10, está decidiendo no reportar de regreso 100% de los errores. Esto es la pérdida, por ejemplo, recién decía en ese 80% y no sé si era en el 15 o en el 16, decía como 25. Un 5% creo. Llegó a un punto al 21, me quedé a 80. Eso es más de 100%. Eso se lee como 101% o es el 21 de lo que pasó, digamos. No, no, no, pero ahí estás sumando peras con manzanas, con hojas. Eso es siempre en cada router. Pensálo, como siempre decimos, los routers son independientes entre sí. Son todas entidades independientes. Entonces siempre tenemos que pensar en cada una de ellas. Igual lo que está diciendo Juanjo, que ese comando es muy útil, muy útil para hacer análisis. No hay pérdida en el viaje. La única manera que ustedes pudieran garantizar es que todos pierdan de manera equivalente y en realidad es, la manera que ese comando construye esta respuesta es, si todos los routers les respondieran todo lo que ustedes hacen, volcarían a los routers para atender a ustedes para que les anden el MTR. Entonces, por un criterio de seguridad, se protege respondiendo una muestra. Entonces, no es que los enlaces no tienen pérdida acá. De hecho, a ver, si pudiera, el destino, ¿quién es ese destino? Tirale un ping al destino. ¿Quién es? Estaba probando .co.india, .co.jp de Japón. Por eso. No, pero si hay un caso por el destino. Sí, claro. Ven que el destino no pierde. Que es lo que importa. Ok, entendido. A ver, me quedo con las ganas de que pierda, para. Y a los routers siguientes del día 80. Ahí empezó el rock and roll, ahí me gustó el rock and roll. ¿Qué le puse ahí? Le puse que mande un paquete cada 0,1 segundo, porque por default manda cada 1 o 2 segundos. Y nos dice 0,1. ¡Huija! Rock and roll, baby. Now we're talking. Fíjense que hasta le estoy molestando a mi pobrecito AP que tengo acá, ¿no? Que ha dicho, no, loco, no, no te voy a responder todo. Pero fíjense, esto es un comportamiento. Se ve ahí, ¿no? Espero que no me esté auto afectando mi stream. Sí, se ve. Se ve, pero esto es pérdida. Fíjense que a partir de este punto, estamos teniendo consistentemente alrededor de 1% de pérdida. Entonces eso es pérdida en serio. Porque seguramente a partir de acá, de este, voy a frenarlo, esto lo pauso así. Ahí lo pause. Fíjense que esto está buenísimo porque está mostrándole 0,9% desde acá en adelante y muy consistente. Quiere decir que acá sí bien puede ser. Maldición con mi uso del mouse. Vamos de vuelta. Vamos a frenarlo ahí. Es bien consistente la cantidad. Entonces acá sí puedo decir que desde acá para abajo, desde el 14 para abajo, estoy observando alrededor de un 6% de pérdida. Desde el 11 para abajo, alrededor de un 2% de pérdida. ¿Sí? ¿Se entiende? O al menos un 2% y acá al menos un 6%. Y el 83 es un valor como inflado. Por eso les digo, ahí hay algo especial de ese router, porque recién veíamos todo en 0 y ese siempre en 80. Ese router está haciendo algún policing, alguna política para no responder todo ISMP. O capaz que no recibir todo ISMP. El papá tiene un filtro de entrada que cuando le entra este ping dice, no, macho, yo voy a permitir que entren pings uno de cada cinco o uno de cada cinco de cada dirección IP. Que es un filtro que se puede construir por una cuestión de protección, de seguridad, para evitar que le hagan denegación de servicio o ataques. ¿Sí? Bien, buenísimo. Bien, creo que quedó súper bien entendido el-- Esto, vamos a volver a dejar de presentar y presentar-- ¿Esa es la protección que tienen páginas para que no los crasheen así con máquinas virtuales metiéndose 30,000 personas en un segundo? Pueden estar a otras alturas del stack. Depende de qué altura. Esta altura que estamos hablando ahora, estamos en la altura de red, capa 3. Bien. Pero hay para capas 7, perdón, para capa transporte, 4/5. Y para capa 7, que es aplicación. Y cada capa tiene su problema distinto a resolver para protegerse. Bien. No va a ser consistentemente igual. Bien, seguimos. Entonces, vimos time to live. Time to live. Entonces, le vamos a poner una notacióncita acá. Esto es max. Ay, mi colorcito. Ahí. Entonces, vamos, vamos, max. 255 default, igual a 64. Bien. Bien, seguimos. Entonces, protocolo. Pero no estamos hablando del protocolo IP. ¿Por qué tiene que poner protocolo? Tiene que decir, ah, no, yo soy IP. Sí, porque no sabe qué otra cosa puede ser otro protocolo. ¿Qué otro protocolo podría ser? El ICMP que hablábamos recién. Bien, ICMP, payload IP. ¿Qué otro protocolo uno leería ahí, entonces? ¿De qué protocolo estamos hablando? Que se le-- Esta cabecera es cabecera IP. Esto es IPv4. Entonces, ¿qué protocolo especifica ese campo? ¿PIN puede ser uno? No, no, no. Eso es ICMP. Es el protocolo. PIN sería más aplicación o un uso de ese protocolo. ¿Qué protocolo carga IP? Lo vimos en la primera clase. Cuando veíamos las capas, teníamos enlace, Ethernet, red, IPv4. TCP, UDP. Y eso es lo que va a estar escrito ahí. TCP, UDP. Y ICMP también, a pesar de que no es un protocolo de transporte, es carga de IP. Entonces, acá le vamos a poner, por ejemplo, esto sería TCP, UDP. Y lo voy a poner entre paréntesis, ICMP, nomás por el hecho este que mencionamos, de que es un protocolo de red a pesar de ser carga. Eso es lo que va a especificar acá, entonces, de alguna manera. A ver si lo puedo dibujar. ¿Cuál era? Bolígrafo. Este era bolígrafo libre, ¿no? Sí. Y para cambiarte el color. Entonces, este es el protocolo que vendría acá, ¿cierto? Ahí. Justamente especifica qué diablos de protocolo viene como carga de IP. El protocolo del payload. Yo, cabecer IP, estoy cargando una cabecera de un protocolo TCP o UDP. Bien. Sigamos viendo un poquito. Header checksum. ¿Qué indicios le da el header checksum? ¿Qué está chequeando el IP? La integridad de la cabecera. Pero no habíamos dicho que IP no chequeaba nada, que no había chequeo de punta a punta, que el protocolo de transporte era el que chequeaba. Chequea la cabecera. La cabecera. ¿Cuánto mide la cabecera? Mucho, poco. ¿Cuánto habíamos dicho que medía típicamente o mínimo? 20. 20. Bien. Ahora, ¿por qué estos desgraciados que diseñaron el protocolo IP, por qué no dijeron, ya que estábamos haciendo el chequeo, ¿por qué no chequeamos todo el datagrama y listo? ¿Por qué chequear solo la cabecera? ¿Qué les cuesta chequear todo el datagrama? Y eso va a sacar tiempo, porque tiene que hacer procesamiento. Ajá, ok. ¿En qué orden de magnitud de diferencia estamos hablando? Milisegundos. No, no, no. Les pedí el ratio. Estamos hablando de 20 bytes versus cuánto que tendría que chequear cada router. 600. Ok. Ahí estamos. Ahí estamos. Correcto. Entonces, justamente, ¿por qué? Porque la emisión del router, ¿cuál de todos estos campos es el campo más importante para el router? Lo dijo Diego cuando arrancamos la clase. ¿Qué es lo que el router se fija y qué es básicamente el que define su laburo? ¿Cuál de todos estos campos? El destination address. Destination address. Correcto. Es decir que el router, esto, es justamente lo que tiene que leer. Y tienen que estar seguros que no solo eso, sino que todos los otros campos de la cabecera están íntegros. Porque si está algo roto, se flipó un bit, hay algo que está mal, listo. Yo no voy a trabajar con algo que está roto. Y de vuelta, donde pone la lupa el router es solamente en la cabecera. No le interesa el payload. El payload será un problema de otra capa del stack de protocolos. Mi problema como router es garantizar que esto llegue a destino. Y que el resto de la cabecera esté íntegro. Por eso es que es un header checksum. El header checksum, entonces, solamente, como header que es, solamente alcanza a la cabecera. Y yo lo voy a dibujar así específicamente porque estamos hablando de un caso en que no haya opciones. Puede haber opciones, pero para no complicarlo, es como para que quede bien claro que solamente alcanza eso. Bien. Sus adres es simple. Header checksum, type of service. Nos queda este, que es fragmentación. Que es, no estoy seguro si es un concepto para entrarlo, lo voy a hacer una van premiere, ya son las 9. Y lo vamos a ver más en profundidad la clase que viene. Porque es relativamente un poquito más complejo. Eso es si el payload era más grande que lo que podía entrar en el datagrama. No. Entonces, gémelo para la clase que viene. Bien. Les cuento. Les cuento cuál es el escenario de una... Los hosts orígenes no fragmentan. Son súper optimistas los hosts orígenes. Es decir, yo, como host origen, tengo una Ethernet o tengo un Wi-Fi que tiene 1500 de MTU. Yo soy optimista. Si tengo que, por ejemplo, subir una foto a algún... No sé, subir una foto a Instagram, lo que fuera, esa foto, como bien sabemos, mide varios megas, voy a tratar de llenar los paquetes los más gorditos posible por todo lo que ya hablamos. Entonces yo voy, mejor dicho, la estable protocolo, voy a correr mi máquina, voy a escribir datagramas bien gordotes. Tengo una capa Wi-Fi, hasta mi router Wi-Fi, 1500, va dando datagramas llenos 1500. Cuéntame el resto de la historia. Y de hecho, el protocolo IP no fragmenta en origen. Porque la fragmentación, como vamos a ver, es caca, nene. Horrible, tan horrible que no existe ni IPv6. Ish. Pero IPv4 dedicó 32 bits a la fragmentación. Entonces yo escribí acá toda la secuencia, datagramas de 1500. Pero, ¿cuál podría ser el "pero" para el cual necesitemos fragmentación? ¿Estamos seguros que todos los capas de... Si tenemos perdida de datos. No, perdida de datos, perdida es pérdida. Pim, ba, chao, paf. Fin del juego para este datagrama, ¿no? ¿Estamos seguros que todas las capas de enlace, desde acá hasta Instagram.com, tienen 1500 como mínimo? No. ¿Y qué pasará a un router que, ah, qué macana, tengo 1450 en mi próxima capa de enlace y tengo este ñato yo que le mandé un datagrama de 1500? Pero solamente puede escribir un datagrama como máximo 1450 porque resulta que no es internet, es algún otro como un túnel de no sé qué extraño, muy raro que exista, pero existe, el protocolo lo soporta. No entra 1500 en mi próxima capa de enlace. Yo soy el router que recibió por un lado 1500 y mi próxima capa de enlace no entra 1500. Tienen que descortarlo. Ajá, bien. Y es ahí donde actúa la fragmentación. Es decir que la fragmentación en IP en general, en IPv4, está destinada a que los routers en el medio de algo, una posibilidad de romper ese datagrama en pedacitos y que sigan hasta destino. Los datagramitos y que después se reensamblen en destino. Para reconstruir el datagrama original. Pero fragmentación de IP tiene como media horita larga de charla porque hay muchos aspectos interesantes. Por eso, lo quería dejar nomás como avant premier, lo quería dejar planteado al problema, pero lo tomamos la clase que viene. OK. Tenemos, recuerden, porfa, para la clase que viene, vamos a retomar este tema, pero tenemos que traer avanzado la solución del caso 2, que lo vamos a revisar probablemente al principio. Queremos ver eso y queremos cerrar el protocolo IP viendo lo que sería una conceptualización de, bueno, cómo es que funciona la internet y cómo funcionan los protocolos dinámicos que hacen que eso funcione. Entonces, de nuevo les pedimos, miren las clases, repasen las cosas que tenemos, hacemos todo un esfuerzo, si querés, cortamos la grabación. Dale, sí, sí. [AUDIO_EN_BLANCO]Bueno, estamos en 6 de mayo de 2021, la idea entonces, recordemos más o menos el camino hasta acá, hemos visto IPv4, hemos visto las cabeceras de IPv4, hemos visto los protocolos de ayuda de IPv4, ICMP v4, ARP y DHCP, protocolo de aplicación este último, y entonces ahora, en otros años usualmente a esta altura nos íbamos para arriba, nos íbamos para TCP, UDP y quedaba para el último IPv6, vamos a intentar un orden distinto este año para que eso no ocurra, porque si no, básicamente no terminábamos dando juntos IPv6, quedaba para estudiar ustedes, hay buenas razones, como bien la hemos visto prácticamente de compañeros nuestros que ya tienen IPv6 en sus casas, más allá de que IPv6 es la tecnología de capa 3 de TCP/IP con la que ustedes van a trabajar en producción seguramente, y IPv4 quedando obsoleta a medida que pasan los años, así que bueno, nos pareció una buena idea cambiar ese orden y en realidad hoy vamos a ver entonces IPv6, vamos a tratar de verla desde las diferencias IPv4 y una vez que lo entendamos vamos a ver qué cosas propias tiene IPv6. Ahora voy a compartir mi pantalla entonces, a ver cómo se ven, vamos a hacerlo de siempre, que es los ajustes de tamaño de fonts y demás. A ver mi escritorio... Seguramente este se ve chiquito así que lo voy a aumentar, ustedes me dicen... ¿Qué tal se ve ahí el font de la terminal? Está ahí, al borde, dale un toque más. ¿Al borde? Al menos un toque más. ¿Así? Está. Claro, buenísimo. ¿Se ve mejor si lo cambio a Mario Patito? A ver, para un poquito. ¿Lo puedo cambiar? A ver, no, pero si está mejor así. Por supuesto perdí el tamaño de font, vamos de vuelta. Bien, perfecto, contexto, ahí estamos, igual que ustedes, respecto a lo que pueden hacer, les pido que lo hagan por favor, loguéense en la cloud como siempre porque vamos a hacer algunos toquecitos ahí. Vamos entonces, IPv6. Hemos hablado ya del agotamiento de IPv4, eso hemos hablado ocurrió alrededor, en realidad ocurrió progresivamente, pero más o menos febrero de 2017 es cuando se le da el tincazo ya directamente, Diego lo explicó bien, la... ...exhausting, es decir, la finalización de disponibilidad de direcciones IPv4 para los Reels, con lo cual básicamente ahí empezó directamente la falta de disponibilidad, pero bueno, eso lo vimos en la clase pasada. Un poco, vamos a ver una de las cosas interesantes, un poco resumiendo los próximos dos puntos que trae IPv6, es que como bien hemos visto hasta ahora, hemos estado siempre haciendo un juego entre, adentro de mi red, sea mi casa, universidad, lo que sea, despliego las direcciones IPv4 privadas y tengo algún mecanismo de traducción de direcciones con lo cual me alcanza, si se quiere, una única dirección IPv6 pública para aglomerarnos todos detrás de eso, eso se llama NAT, que es Network Address Translation, y es un mecanismo con el cual todos, si se quiere, podemos consumir esa, digamos, como consumidores, usar esa dirección IPv6 pública para aparecer al mundo y esa caja que hace el NAT tiene la manera de poder entender estos flujos y reorientarnos y de alguna manera construir estos flujos de tal manera que vayan y vuelvan al node interno correcto. ¿Qué les suena? A ustedes les debe sonar seguro, especialmente si han estado usando Torrent o jugando en red. ¿Qué pasa cuando ustedes quieren hacerlo opuesto? ¿Lo pueden hacer? ¿Plan de "tengo una máquina adentro y necesito que sea visible afuera, por ejemplo, para poner, lo deben haber visto, un puerto disponible públicamente para que sea alcanzable para mi Torrent que estoy corriendo esta máquina o mi servidor de juegos"? ¿A alguien le suena eso? ¿Me puede contar cómo lo hizo, qué fue lo que hizo? Sí, eso, para que sea visible desde el internet, digamos, al router hay que hacerle port forward para el puerto que vos quieras hacia la IP que tiene asignada tu computadora. ¿Qué pasa si dos máquinas quisieran usar el mismo puerto porque fuera un puerto bien conocido de un juego o de un... lo que fuera? Supongo que no se podría. Es correcta tu suposición, no se podría, tenés que elegir otro puerto. Entonces, esto a modo de muestra de que, obviamente, hay una cuestión muy asimétrica, ¿no? Respecto de cómo nosotros, como clientes, usamos el internet, todos detrás de esa única IP pública, nateados, como se suele decir en la jerga. Pero cuando queremos hacerlo opuesto, que es exponer algún servicio que tenemos internamente en alguna máquina, tenemos que hacer nosotros, si se quiere, una administración de ese recurso escaso, que son el... vendría a ser el pool de puertos disponible detrás de esa única IP pública que tenemos y hacer esto de decir, bueno, me traigo el 54.4.13, me traigo ese puerto y lo mapeo con tres tapes internas, que es 192, 168, blablabla, en tal puerto. Si necesito otro puerto, lo hago así como a condimento, manualmente, administrativamente, de traerme esos. Eso es un efecto de... básicamente, es como que IP cae, no cae. IP es víctima de su... IPv4 es víctima de su propio éxito, donde no hay direcciones para todos los dispositivos que queremos y por eso tenemos que hacer estos mecanismos. Una de las ideas que trae IPv6, más allá de la implementación, que es un poco lo que vamos a tratar de descubrir hoy, es justamente romper con eso y permitir el adresamiento de todos los dispositivos que yo necesite adresar, que necesite en dirección de red, hay IPv6 para todos. De hecho, hay muy pocas definiciones, pero no son para hacer NAT 626, hay alguna por ahí, respecto de este... no existe, la idea es que no siga existiendo esto de que tengo direcciones IP privadas, tengo un dispositivo inteligente que me hace ese mapeo, sino que directamente las máquinas, los nodos internos que están detrás del dispositivo me brindan conectividad, también sean alcanzables simétricamente. Es decir, en definitiva, que los dispositivos que yo tengo, todos tengan una IPv6 pública. Además de otras direcciones IP, que vamos a ver cómo los usa IPv6. Entonces, continuando con esta idea, en realidad, bueno, IPv6 se creó más o menos, si mal no recuerdo, en 1996. Nosotros hicimos, no sé si alguno estaba acá en el 2006, o al menos tenía un poquito más de edad que adolescencia, para haber visto una charla que dimos, nosotros dimos una charla en la universidad en el 2006, respecto de IPv6, para ese momento era incipiente. Pero bueno, ya a este punto de tiempo, en realidad, todos deberíamos estar más o menos entrenados con IPv6. Una de las cosas que trae, que ya vamos a ver pronto, es que el espacio de direcciones es de 128 bits. ¿Cómo se compara ese espacio de direcciones con el de IPv4? Cuánto, o mejor dicho, una dirección IPv6 es de 128 bits, una dirección IPv4 era? 32. 32. Quiere decir que, visto de una manera incorrecta, la dirección IPv6 es cuatro veces más grande que la IPv4, medida en bits. ¿Sí? Es decir, 32 por 4 es 128. Sin embargo, como sabemos, eso no es así porque hay una relación exponencial ahí. Y me voy a detener acá un momento porque ahí es algo que, en particular, tengo mi propia, cada uno tiene su manera de explicar esto. Si ven en el internet van a ver una dirección IPv6 para cada grano de arena del planeta, o para cada estrella del universo. No me acuerdo esos números, yo tengo una manera distinta de, eso es muy personal, de tratar de entender porque para nosotros, para nuestra cabeza, la exponenciación no es algo que ocurra naturalmente. Entonces, ¿cómo harían ustedes, imagínense que ustedes pudieran, sin destruir demasiado la cabecera IPv4 que tenemos hoy, ¿cómo harían para duplicar el tamaño del direccionamiento IPv4? Imaginen que fuera posible, porque tienen algunos bits ahí en la cabecera que podrían abusar. ¿Cómo lo duplicaríamos? La línea de opciones que no se usa, por lo que no hay fragmentación, usarla para más espacio de direcciones. Pero ¿cuánto hace falta? ¿cuánto hace falta para duplicar? Técnicamente, claro, pero técnicamente, si tengo 32 bits, ¿cómo lo duplico? Ah, con un bit más. Un bit más, bien. Si agrego dos bits más... Cuadruplico. Ajá, ok. Y si agrego 32 bits más... Uf, ahí ya no sé, mucho. Bueno, ahí va, ese es el punto. 32, 2 a la 32. 2 a la 32 veces más grande, 4 mil millones de veces más grande. 4 mil 300 millones de veces más grande. A mí me gusta hacer la analogía, no sé si... Ya, se me está quedando vieja la película. ¿Han visto Men in Black? Sí, sí. Ah, bueno, bien, bien. Viene el espíritu nerd ahí. ¿Han visto cuando los personajes sacan del bolsillo a veces un llaverito y adentro del llaverito ese tiene un universo completo? Sí. Ah, ok, bien, perfecto. Entonces, vamos a hacerlo de la siguiente manera. Imagínense que nosotros fuéramos de 32 bits a 64 bits. Es decir, que le agregamos 32 bits. Sería el equivalente, más o menos, haciendo la analogía con la película, que en cada punto actual donde hay una IP pública de IPv4, abrieras todo un internet tal como la conocemos hoy. ¿Sí? Porque justamente en cada punto donde hay uno de esas direcciones, de 32 bits actuales, yo le voy a permitir a cada punto que a su vez tenga 32 bits en sí mismo. Quiere decir que en cada punto que existe hoy, si yo tuviera la posibilidad de duplicar la cantidad de bits de una dirección IPv4, no es posible, yo podría permitir que cada dirección IP pública actual tenga su propia internet adentro. ¿Coinciden conmigo en eso? Sí, sí, sí, claro, lo ponen. Bien, pero vale la analogía con la película. Es como que abro en cada punto donde tengo un internet, abro todo un universo de un internet completo. Con eso, eso sería el equivalente a 64 bits. Para llegar a 128, lo tengo que hacer dos veces más a eso, ¿no? Es decir, en cada punto actual abro un internet de la cual su IP pública, que tengo 4.300 millones, puedo en cada una de sus IP públicas abrir otra internet, ahí iría a 96 bits, y a su vez en cada una de esas podría abrir otra internet y con eso iría a los 128 bits. ¿Sí? ¿Se entiende más o menos esa idea? Como para tratar de dar una magnitud del grado de amplificación, es decir, hay un grado de amplificación exponencial de 4 veces. Es buenísimo el ejemplo, muy gráfico, Juan, muy bueno. Ah, bueno, gracias. Es como para tratar de cazar en la cabeza la exponiciación, y sobre todo en comparación con algo que conocemos, porque, está bien, ¿no? Por ahí no entran en la cabeza los 4.300 millones de direcciones, que no son todas públicas, como sabemos hay espacios que no se usan, pero en ese orden de magnitud, 2.000 y pico de millones. ¿Y qué significa ampliarlo a 128 bits? En realidad, vamos a ver que esto es en orden de magnitud, pero para ese IP de 4 se han recortado espacios, es decir, hay prefijos, direcciones IPv6 que están reservadas, y vamos a ver que esto no es tan así, no es que de pronto tenemos 2 a las 128 direcciones IP públicas, de IPv4, de IPv6 disponibles, sino que vamos a ver que hay, en realidad, bastante menos. Y a mi gusto, a mi gusto, los huasos engolosinaron y entraron a la ciudad. A desperdiciar direcciones ya vamos a ver por qué. Sí, dígame. ¿Y por qué se pensó en un sistema tan exponencial que no creo que llegaría a llenarse algún día? Yo iba a hacer esa pregunta y es, ¿por qué creen que necesitamos... ¿cuántas IP necesitamos por persona actualmente? ¿O dos o tres? La verdad yo creo que fue porque con IPv4 pensaron que nunca se iban a acabar, se les acabó, y dijeron bueno, quedémonos tranquilos con esto. Por eso, pero piensen, hay algo que está muy... hay mucho hipe ahí por ahí dando vuelta, pero hay algo que... ¿por qué podemos necesitar tanta IP? Porque ahora todo tiene IP, básicamente. ¿Y cómo se llama ese momento en el que todo empezó a tener IP? El internet de las cosas. Claro. ¿Y cuánto estiman eso hoy? Imagínense, ya sé que eso no es cierto, pero hoy redondeando 7 mil millones de personas, ¿cuántos dispositivos alrededor tenemos nosotros? Sí, ahora los lavarropas, los atajeadores, hasta los autos tienen internet. Por eso, y después si ustedes empiezan a pensar, piensen en, bueno, queremos Smart City, queremos controlar las luminarias por internet, y cada luminaria se va con una IP. ¿Cuántas luminarias hay por cuadra? ¿Cuatro? ¿Tres? Es decir, no es demasiado alocado pensar que... después saquemos el factor de la seguridad, la gestión de eso y todo eso, pero prácticamente, y sobre todo porque la implementación del protocolo IP, si ustedes se pueden a pensar, no es difícil de hacer, digamos, implementarlo, después darle la conectividad, y a su vez porque también hemos extendido la digitalización a niveles que nos permiten censar, no sé, si yo quiero tener una red LoRaWAN en una finca, y quiero poner sensores en, no sé, cada dos bits, le quiero poner una a cada bit, y quiero que me cense y me mande un dato, imagínense loco haciéndolo con IPv4, y nateando y mandando, ¿les suena a las cosas que les estoy diciendo o no les suena? Sí, sí. Más que nada se hizo para dejarlo totalmente amplio a la experimentación y a ver hasta dónde se puede llegar. Claro, pero tienen que ser, ustedes tienen un poco lo que les decía Juanjo, y ustedes tienen que asumir que este es el mundo en el que nos vamos a desarrollar en breve, digamos, aparte que nos habilita a construir cosas que a veces lidiábamos con el networking o las redes para poder hacerlo a nadie, y ahora decimos, mira, esto se acabó, no es que, imagínense que yo tengo una finca, piénsenlo hoy así, tengo una finca en IPv4 y tengo, no sé, 10 hectáreas de finca, tengo 100 sensores, y tengo que abrir un puerto para cada sensor, para poder instruirlo. No solo eso sino lo "stateful" de la administración de eso, de decir, mantener, entre comillas, una nota, una planillita de este puerto a esta dirección IP, este puerto, ¿qué pasa si tengo que cambiar este sensor o duplicarlo? Tengo que hacer una administración "stateful" donde tengo un mapa de puertos, contramapas de IP, y tengo que de alguna manera memorizar y mapear eso e implementar eso. Relacionado con esto, en algunos de los proyectos en que hemos participado con Diego, no sé, lo de UUID a IPv6 que salió tan bonito, ¿cómo se podría explicar sin irnos media hora de clase? ¿Ustedes conocen lo que es un UUID? Uniform Universal Identifier, ¿lo conocen? ¿Sí? ¿Lo han visto en programación? Sí, sí. Yo no. ¿Sí? Yo no. Ok. Yo tampoco. Uf, a ver, vamos a tratar de no consumir tanto tiempo. ¿Cómo hacen ustedes para identificar... Me tengo que ir a la reunión. Dale, loco, mucha suerte. Dale. Defendémonos. Bien. ¿Cómo hacen ustedes para identificar unibocamente un registro en una base de datos? Ustedes vieron cuando vieron base de datos que en realidad, más allá del nombre de una persona y demás, hay algo que yo tengo que hacerlo independiente del contenido de esos datos, que sería el ID del registro. Si yo cargo un nuevo registro, cualquier tipo, yo estoy poniendo a una persona como un ejemplo simple para decir datos a una persona. ¿Cómo elijo ese ID único? ¿Cómo hago que ese ID sea único? Imaginemos que no sabemos de UUID, así que me gustaría que respondan los que no conocen UUID. Y en las bases de datos buscamos un campo que sea único o una combinación única. Ok. Generalmente hacemos el incremental, autoincremental, bla, bla, y cuando insertamos un registro, si estaba en 4.501, inserto el registro ahora, está en 4.502, y este 4.502 es el ID de la nueva fila o de la nueva entrada en la base de datos. Columna, filas, 4.502, inserto otro, 4.503. Bueno, eso básicamente es, como nos gusta decir, caca, nene. Y de hecho ya cada vez está más, ¿Cómo se dice? Desaprobada la palabra, está más... ¿Mal visto? No, no es mal visto, es desaconsejado eso. ¿Qué pasa? ¿Por qué? ¿Qué pasa si yo quiero un sistema de bases de datos distribuidas? Donde tengo, imagínense, de alguna manera que yo tuviera pedazos de la base de datos en distintos lados y con algún criterio yo pueda hacer una distribución, algún tipo de load balancing. De tal manera de no tener el problema de siempre, de que si yo quiero hacer crecer mi motor de bases de datos, siempre crece verticalmente, comprar más máquinas, comprar más RAM, comprar más discos en una única máquina, que es un single point of failure y demás. Yo lo quiero romper en pedazos. De tal manera que distintos nodos manejen distintas partes de esta base de datos de la que ahora le estamos hablando. ¿Cuál es el problema de seguir usando este esquema? Que tienen que saber el último número. Exacto, tiene que haber una gran coordinación entre todos. Y hay un punto, una bottleneck de loqueo. ¿Y qué tanto puede fallar esa bottleneck? Y bueno, a veces te da el mismo ID y bueno, cada tanto tiene que venir después el administrador a limpiar porque dio el 4.500 dólares o dio 2 veces, qué lástima. Es horrible eso, ¿no? Imagínense si lleguéramos con este esquema, sí o sí, sí o sí, o sí o sí. Imagínense que tengamos cuatro nodos con base de datos, sí o sí tiene que haber algún tipo de coordinación súper recontra central, que sea el que provee, que vendría a ser la semilla secuencial de estos ID. Y siempre que tenemos un punto de coordinación central y tenemos cabezas distribuidas, siempre es un problema. ¿Qué pasa si una de ellas está intermitente, no tiene conectividad? Bloquea toda la creación de nuevos usuarios porque esa no se va a enterar de esta secuencialidad o hasta que se resincronice. Entonces, rompe un poco la escalabilidad, la descentralización, si se quiere. Entonces, una alternativa que suena por ahí tonta, porque es en definitiva la base de UID, es qué tal si genero ese ID randómicamente de una manera tal que sea altísimamente improbable, casi imposible que se genere el mismo dos veces. ¿Cómo, Mongo? No conozco internamente Mongo, pero es muy posible que si lo implemente justamente para seguir esto. Yo les cuento. Contame, contanos, dale. Tiene un identificador que se genera con el identificador del clúster, o sea del servidor. No sé cómo se llama eso. Un número de eso, la fecha y un número dentro del mismo punto. ¿Parecido a esto te da como resultado? Sí, algo así. Es un número excesivo. Fíjense, estoy generando. Bueno, justamente. Bien, gracias. Ese es un ejemplo de uso. La idea es que detrás de eso hay algo que identifica univocamente a la máquina, un generador random y algo que identifica univocamente a este punto de tiempo. En realidad, si ustedes ven, hay una RFC justamente de UID. Hay como 4 o 5 maneras distintas de generarlo. Seguramente, esto es una línea de comando. Prové el entorno de Linux que viene por default instalado. Y fíjense que ahí pueden generar un time-based, un random de acuerdo al tipo de UID que quieren. Fíjense que esos dos, interesante, fíjense la comunalidad que tienen esos. ¿Se nota ahí? Estoy ejecutando UID gen -t. Tiene una comunalidad que es esta parte, este post fico. Y la primera parte que está generada en base a tiempo. El -r es el por default, que es totalmente random. ¿Y cuál es la idea entonces ahora? ¿Cómo generamos ese identificador único de registro? Yo como cliente de esa base de datos, quiero generar un registro. Entonces, fíjense cómo se mueve esto. No necesito una entidad central que me lo dé. ¿Por qué? Porque yo como cliente yo mismo genero mi ID. Es como que yo internamente, en vez de pedirle, che, dame el próximo disponible, genero esto y uso ese bajo la garantía prácticamente de 1 sobre 10 a la, no sé cuánto, mucho. 1 sobre 10 a la, cuánto era, era tipo 100 o algo por el estilo. De colisión, de probabilidad de colisión. Es decir, prácticamente imposible que otra cliente que en el mismo instante de tiempo esté generando esto, colisione con eso. Y uso eso como ID en la base de datos. Si tengo algún mecanismo de distribución, por ejemplo, por decir algo. Si tenemos 16, para simplificarlo, 16 nodos en la base de datos. Cada nodo se hace cargo del primer dígito de este hexadecimal. Como sabemos, hexa tiene 16 números, quiere decir que esto va a parar al nodo 1, eso va a parar al nodo 6, esto va a parar al nodo 5, eso va al 3 y tal cual. Sí, bueno, ahí está. Este es el 14, eso va a parar al nodo 14 y demás. Entonces, una de las, UID es un concepto muy poderoso porque justamente permite desacoplar ese tema de la autoridad central. ¿Qué tiene que ver esto con IPv6? Nada, excepto en este proyecto en el cual participamos con Diego, en el cual teníamos el problema de poder identificar a cada uno de los nodos que iban llegando a un determinado lugar a través de su UID, porque ya habíamos implementado UID. Y teníamos problemas que tenían que ser accesibles, de alguna manera alcanzables en una red que aterrizaba. Entonces, ¿qué es lo que pudimos hacer que fue genial porque nos desacopló el tema de tal nodo le corresponde a cada nodo a un determinado puerto? Parecido al problema este que hablábamos de mapear puertos. Sí, decime, ¿alguien estaba hablando recién? No, no hay problema. Tomamos un pedazo de UID y se lo pusimos a un prefijo IPv6. Y de pronto entonces, para estas entidades que aterrizaban en esta red, se auto asignaban un IPv6 que era parte de su UID, sin tener que tener una entidad central que les entregara IPv6 de acuerdo a algún otro tipo de secuencialidad. ¿A qué vamos con esto? Ya lo vamos a ver enseguida. Este abusivo espacio de direcciones nos permite hacer cosas como esto, nos permite hacer cosas como generar una identidad en la red que no depende, si se quiere hacer una asignación stateless del direccionamiento IPv6. Y eso permite pensar en la aplicación de una manera muy distinta. Puede hacer que pensar que la aplicación en sí, si se quiere, termine teniendo o termine aterrizando una dirección IPv6 para identificar. Vamos a seguir entonces y ver un poco más cómo se notan, cómo se ven. En nuestras máquinas vamos a ver qué direcciones IPv6 tenemos. Fíjense, si hacemos IPA, como hemos hecho hasta ahora, nos muestra tanto las direcciones a nivel de link, como puede ser esta, que sabemos que es la dirección MAC, y también la dirección que hasta ahora habíamos estado trabajando, que es la IPv4. Uno puede hacer IP -4a, por ejemplo, para solo ver la IPv4, y así también uno podría hacer IP -6a, como la vemos acá. Pero me voy a quedar con toda la vista de IPA. Y vamos a ir encarando esto de a poco. Les quería preguntar, ¿ustedes ven en algún otro lado de la pantalla acá, los que ya lo saben, no me spoileen, eh? La secuencia esta, 1bd804, ¿la pueden identificar ahí? Que no sé, obviamente la estamos viendo con lo que yo estoy haciendo highlight, ¿no? Pero, ¿se ven en algún otro lado? Digamos, se hacen grep visual en las direcciones ahí. ¿Pueden ver un d804 en otro lado? Y hay uno ahí un poquito más arriba donde está resaltado, pero no se siente la misma, o sea, es de la misma placa. Qué coincidencia, es el mismo dispositivo, la placa de Ethernet, ¿no? Lo pueden, por cierto, esto también lo pueden hacer con sus propias máquinas, todas estas máquinas son básicamente ganado que está armado igual. Fíjense que 1bd804, 1bd804, y acá hay un 16 3G, y acá hay un 16 3G, y acá incluso hay un, bueno, acá hay un FA que acá se ha cambiado por un F8, pero fíjense que es como si esta dirección IPv6 tuviera componentes de la MAC. Es más, ¿pueden ver en alguna otra dirección IPv6 algún patrón de comunalidad? ¿Tienen algo en común estas dos direcciones IPv6? El d804/64 ¿Y algo más en común? Sí, 3gff, fe1b, todo eso. ¿Algo más en común? Vamos avanzando, recién me dijeron acá, después me dijeron acá, y yo sí, en realidad, eso también. Si ustedes ven esto, no puedo hacer dos highlights juntos, pero fíjense que esto y esto coinciden. Y en realidad si ustedes ven, tienen todos bits que corresponden a la MAC. Estoy haciendo un poquito de avant-premier, vamos a ver cómo funciona este mecanismo, pero es como si la parte de host que yo decido en mi dirección IPv6, está definida por la MAC que yo tengo. Podríamos hacer eso con IPv4, por ejemplo, si yo les doy una barra 24, ¿cuál es el problema que tenemos con IPv4? Le digo 192, incluso una barra 16, hagámoslo mejor con una barra 16. 192, 10.1.0.0/16. ¿Ustedes pueden rellenar los últimos 16 bits con la MAC? Como para decir, sacamos la entidad esta del DHCP, que vimos en las clases pasadas, generador y que le decía vos sola .100, vos sola 101, vos sola 102, y le permitimos que cada máquina se autoconfigure poniendo bits de la MAC en la última parte de la dirección IPv4. ¿Eso sería posible en IPv4? ¿Qué les parece? Yo les estoy dejando 16 bits de host. ¿Cuánto mide una MAC? ¿Alguien? ¿Cuánto mide una MAC? ¿Alguna señal de vida? ¿Me escuchan todavía? Sí, sí, no me acuerdo, estoy pensando. 48 mide, 48 bits. La pregunta muy recontra, simple. ¿Entran 48 bits en 16 bits? No. Imagínense, no, no. Es como si yo pusiera un número de bits, ¿cómo lo haría? ¿Entran 48 bits en 16 bits? No. Imagínense, no, no. Es como si yo pusiera 10.1.0.0/16, 10.1 es el prefijo y el posfijo que identifica el host, yo intentara meter la MAC así, y ponerle todo y tirarle los bits en la última parte del host, y decir, mirá, esta red es el prefijo 10.1/16, ponete con tu MAC, ponete el número de host. Eso no es posible en IPv4, sencillamente porque no nos dan los bits. El /16, esos 16 que me, en realidad /16 son de la primera parte, como tiene 32, me quedan 16 libres y los 48 bits de la MAC no entran. Lo que vamos a ver que está ocurriendo acá, esta coincidencia que no es tal, sino que es por diseño, permite hacer estas cosas, permite que se acuerde un prefijo para toda esta red y las nodos de la red IPv6 se autoconfiguren pegándole bits de la MAC para terminar de formar la dirección IPv6. Es decir, hay un prefijo que está fijado por las condiciones de la red, que ya lo vamos a ver cómo se establecen, y después directamente las máquinas se autoconfiguran de una manera stateless. No necesitan ir a un DHCP que haga toda esta negociación, lo vimos, estos cuatro mensajes, ¿no? Request, ACK, perdón, Discover, Offer, Request, ACK, sino que sencillamente los nodos dicen, "Ah, mirá, está este prefijo, he escuchado que está este prefijo acá en esta red, le pongo como posfijo, lo completo con mi MAC y acá ya tengo una dirección IPv6 totalmente usable". Este mecanismo es fantástico, es así como están todas nuestras máquinas en la cloud actualmente configuradas, y de hecho esas son IPv6 públicas totalmente usables. Fíjense que se hacen en un mtr www.google.com, incluso defaultea porque esa es la idea de las nuevas, de las RFC de una parte de esta hoja hasta ahora, que primero intenten por IPv6 y después recién por IPv4. Bueno, vamos a ver cómo se le da. Yo voy a dejar corriendo esto, pero le voy a apretar P por una pausa para poder referir a eso. Y le voy a apretar un N para que no me muestre nombres. Bien, vamos a ver cómo, ahora tenemos 128 bits, ¿no? Con IPv4 era fácil cortarlo a nivel de 8 bits, de octeto, porque tenemos la notación que es súper recontraconocida, que son los cuatro números decimales separados por punto. Con IPv6 eso sería inusable, porque imagínense, tendríamos que multiplicar por cuatro esa notación, no terminaríamos nunca de decir esto. Sería una dirección 1.2.3.5.6.8.20.201 y no terminaríamos más. Entonces, en vez del punto separando 8 bits, en IPv6 se decidió usar dos puntos como separador. De vuelta, esto es por una cuestión, sencillamente como hacemos la notación para que sea usable para leerla. Dos puntos como separador, tal como ven acá en la diapo, y bloques de 16 bits. ¿Cuántos bloques de 16 bits? Entonces hay una dirección IPv6. ¿Cuántos bloques de 16 bits? Y los otros fíjense que están como comprimidos. ¿Qué notan en esa "compresión"? Por ejemplo, este. ¿Cuántos campos tiene? 1, 2, 3, 4, 5. 5. Bueno, estas son cuestiones de notación. ¿Cuál es la idea de la notación? Yo puedo poner doble dos puntos significa rellenarlo con cero quiere decir que hay adentro ¿Cuántos campos separados con cero? parecido a esto igual a esto, hay acá adentro esta 4 3 porque hay 5 y eran 8 en total Ah, sí, está bien, pensé que eran 4 Es decir, a qué voy me voy a traer esto esta dirección ¿Sí? Se me respondió, Pink Es exactamente la misma que... y díctenme, ¿qué tengo que poner ahí? cero 2.0 ¿Sigo o paro? Ahí estaría La misma Si pongo otra, acá me dará algún error de sintaxis o algún error como diciendo "Name Resolution" directamente se suele decir "esto no es IPv6, papi" Lo mismo que si le pongo menos Ah, ah ¿Por qué? porque tiene que tener exactamente 8 o yo tengo la posibilidad de comprimirlo que se auto-expanda a 8 asumiendo que hay todos ceros en el medio y le pongo 2.2 y una regla que ustedes imaginan que es obvia por una cuestión de evitar ambigüedad que eso se puede usar una sola vez en la dirección Yo tengo una dirección IPv6 que tiene muchos campos separados en cero solamente puedo usarlo una vez porque si no, no sabría cuál es el elástico de ese doble de dos puntos Entonces acá lo hemos puesto en las diapos obviamente estas diapos van a estar colgadas en el sitio Fíjense, acá está el caso Acá tenés esta dirección IPv6 Entonces para comprimirla fíjense dos tipos de compresiones es decir, si hay cuatro ceros directamente se puede usar y si hay cuatro ceros directamente se permite poner un solo cero, no hay que poner los cuatro ceros porque en Exa es lo mismo y se permite hacer la compresión una vez por ejemplo acá hay un caso donde hay todos ceros este sería el caso menos óptimo el que estoy ahí sobresaltando que he usado, me he quemado el doble de dos puntos ahí para este campo que es cero sin embargo sería mucho más conveniente usarlo para este, entonces expresamente en cero y lo uso justamente para que se expandan todos estos ceros Entonces, una de las partes más importantes o de aprendizaje si quieres empezar a tratar de meter en la cabeza esta nueva notación de IPv6 que de pronto nos empieza a resultar un poco más natural cuando veamos estas direcciones, ¿por qué? porque tenemos que switchar obviamente a decimal, estamos acostumbrados a los decimales en IPv4 vamos a switchar a exe y tenemos que empezar a pensar que ahora no se corta en un byte sino en dos bytes, 16 bits y esa es si quieres la parte que por ahí más cuesta cuando empiezas a ver cómo chocan estas direcciones y bueno la experiencia y un poco de entrenamiento te lo da. La idea de IPv6 y ahora enseguida vemos los tipos de direcciones. ¿Recuerdan cuando vimos scope de IPv4? Habíamos visto que había uno que era localhost si si quiere, otro que era link local direcciones esas que empiezan con 169.254.cualquier cosa en IPv4 que en realidad son robadas de la idea de IPv6 En IPv6 aparece un concepto de unique local que podría ocupar más o menos el espacio de direccionamiento privado de IPv4, los 192.168 los 10.algo los 172.12 hasta 16 si mal no recuerdo que eran direcciones IPv4 privadas, en el IPv6 se llaman unique local ya vamos a ver por qué se le llaman unique local ahí agrega un componente random interesante y le deciones globales quiere decir que si las vemos en scopes de ámbitos, estamos hablando que hay direcciones IPv6 que son node local el equivalente a localhost link local que son válidos solamente en la cacerola de mi capa de enlace unique local que son válidas dentro de mi organización más o menos como le decía recién, equivalente a lo que es direccionamiento privado de IPv4 y globales y vamos a ver que en el espacio de IPv6 y ahí es donde empezamos a desoptimizar estos 128 bits, donde invalida esto que yo les comentaba de los universos de IPv4 que se van, los 72 bits que se van abriendo porque los vamos recortando porque vamos preasignando prefijando prefijo, va a quedar redundancia para estos tiempos distintos de scopes, eso sí vamos a ver que tiene distinto IPv6 mucho más prolijo que IPv4 respecto de a cuál corresponde ese scope en destinos algo interesante que nos trae IPv6 es que está unicast, está multicast, está ncast y es básicamente mala palabra broadcast no es mala palabra, no existe en el diccionario de IPv6 broadcast yo no puedo hacer, así como yo podía enviar un broadcast por ejemplo con ARP preguntándole "che, ¿quién tiene la dirección IPv4 tal en este enlace?" no existe tal cosa en IPv6 directamente maneja por todas las cosas por las cuales hemos bardeado a broadcast en su momento cuando hablamos de esto así que una de las cosas interesantes que nos trae IPv6 es que tenemos que entender mucho mejor cómo es el funcionamiento de multicast vamos a ver algunos prefijos de direccionamiento y cómo se relacionan con con IPv6 este ya lo vamos a ver voy a voy a saltear el primero pero me interesa este en particular ¿cuál sería el equivalente de este? ¿cómo leemos esto? duele a la vista pero alguien que me lo traduzca al cristiano por favor, esto el equivalente 127.0.0.1 que en realidad vimos que en IPv4 era 127/8 127.0.0.0/8 hay un montón de direcciones de loopback ¿cuántas direcciones de loopback de loopback hay en IPv6? estamos hablando de, entonces estamos analizando esta ¿cómo se mastica eso? ¿cómo la escribirían en notación larga esta? en notación sin compresión siete ceros y el uno ajá, muy bien van a ser laburas estuvo bien la cantidad de ceros no, está bien, siete ceros y un uno eso es igual a eso ¿y eso qué es en bits? cada uno de estos espacios son hexa ¿no? si, en bits son todos ceros igual ¿todos ceros? bueno, el último que tiene un "ping" uno, ¿sí? y esa es la dirección de loopback ¿/128 qué significa? ¿cuál es el equivalente? por ahora nos vamos a permitir hacer las equivalencias con IPv4 porque es conceptualmente más fácil ¿cuál es el equivalente a /128 en IPv6? ¿cuál sería la máscara equivalente en IPv4? /32 sí, sí, sí, es correcto, /32 es la máxima máscara posible ¿y qué pasaba cuando en IPv4 poníamos una dirección con la máxima máscara posible, con /32? ¿a qué identificaba? ¿identificaba un prefijo de red? ¿a qué identificaba cuando decía "ah, esto es /32"? al dispositivo solo a un único destino, ¿sí? es decir, 192, 168, .1, .10, /32 es unívocamente un único dispositivo e incluso 192, 168, no sé, 00, /32 es una única dirección IP en este caso esta es una única dirección IPv6 no hay, fíjense que hay no hay un /8 como teníamos en ¿a qué me refiero con /8? en IPv4 yo puedo hacer esto, lo habíamos visto pero yo también puedo hacer esto .54, .123, .1 y me responde a mí mismo, ¿por qué? porque 127, /8 era lo que estaba dedicado a node local, o lo que sería el local host en el caso de IPv4 es más estricto si quiere, y hay una sola, o hay una única dirección dedicada a referirme a mí mismo que es la 2.21 ¿sí? pero ya empecemos a tratar de mapearla, leerla como la vemos abajo, son es la dirección que tiene todos los bits en cero y el último bit prendido, ¿sí? eso identifica al local host al loopback ya volvemos sobre estas y sobre estas que son un poquito más complicadas de entender interesante lo que aparece con la dirección IPv6 que IPv6 define el prefijo 2000 que está mal dicho porque en realidad no es 2000 decimal, cuando yo digo 2000 debería ser 20000 2.2./3 como todo el prefijo de las direcciones IP públicas, quiere decir que si yo a ustedes les tiro una dirección IPv6 inmediatamente es posible confirmarse una dirección pública o no no hace falta mapearla como en IPv4 que decíamos "ah es una 192.168 o una 10.algo o una no" acá hay una sola condición, si está adentro o no está adentro de esa entonces obviamente ustedes saben cuál es la próxima maldad que voy a pedirles ustedes ya nos conocen conocen nuestras maldades ¿cuál es la próxima maldad que les voy a pedir? ese 2000/3 ¿cuántos dispositivos tienes? bueno no, no tan malo, medianamente mal mediana maldad la mediana maldad sería por favor díganme cuál es la primera y la última dirección que entra en ese 2000/3 ¿lo 2000 cuenta como un asignable? si señor, claro que si, esa es la primera quiere decir que esta va desde la 2000 ¿cómo lo pondría la primera dirección IP? ¿cómo es? ¿con todos en ceros te estás refiriendo? claro significa que tengo que ponerla así ¿cierto? o así, bueno 2000/3 así, ¿barra cuánto sería la primera IP única? barra 3 es todo un prefijo ¿no? 128 muy bien, perfecto desde la 128 ahora, muy vivo lo suyo colega, porque se agarró la más fácil, quiero que me digan ahora la última barra 3, que feo ¿no? impar, horrible pero bueno, vamos a tener que ver, a ver vamos a elaborarla por pedacitos ¿qué pasaría si fuera barra 8 por ejemplo? que no lo es, pero yo quiero que me digan, ¿cuál sería ahí? barra 8 2000 y f ¿o no? pues decir que sería algo así de acá en realidad no puedo poner dos puntos, sino f, f, f repetido ¿no? esto no es una anotación válida no es una anotación válida para nada pero es como para que yo no esté acá piteando f como un freaking loser hasta el final de los tiempos barra 128, bien ok no ¿ese qué sería? para que eso fuera cierto ¿cuánto tendría que ser el prefijo? ah, 16 ok, eso es cierto lo que está escrito ahí ahora sí es cierto pero si pongo un barra 8, entonces ¿cómo evolucionaría esto? ¿dónde tendría que empezar con los f? ahí vamos, bien muy bien ok nos vamos acercando ¿qué pasa si pongo barra 4? 2f muy bien hasta acá vamos bien ¿qué pasa ahora que pongo barra 3? 3f 3f, bien hasta 3f, f, f correcto, esto es sencillamente porque si ustedes lo ven en modo en bits lo que están fijando es tengan presente que este es un valor hexa ¿no? cada uno de estos es un dígito hexa y estos son recordemos, los dígitos hexa ¿qué anchos tienen en bits? un dígito hexa de 0 a 15 09 absdf ¿cuántos bits tiene? 4 y habíamos dicho que entre los dos puntos había 16 bits así que hay 4 de estos cada uno de ellos carga 4 bits entonces, si nos enfocamos en este primero lo que tenemos que ver es cuál es el número en el cual si yo les fijo los primeros 3 bits cuál es el mayor número que puedo representar con eso llego atrás bien entonces, básicamente si yo les tiro a ustedes una dirección ipv6 automáticamente, nomás para ver el prefijo, de hecho ustedes pueden ver que si empieza ¿qué podríamos concluir así rápidamente? si empieza con 2 o con 3 ya sabemos que es una dirección ipv6 pública yo le digo, muchachos 2 3, 4, ya está la dirección 3, 1 sí, ya está, la dirección 4 bla bla bla en ipv6 es pública o no? la dirección 4, no ya sabemos, si empieza con 2 o con 3 es una dirección ipv6 pública tiene un determinado una determinada forma de recortar esta dirección esto está todo hecho por RFC como ustedes pueden imaginar y la idea es que se ha terminado construyendo este modo de identificarlos, vamos a ver que a menos que se indique otra cosa curiosamente y con un desaprovechamiento muy muy excesivo del direccionamiento IP, los últimos 64 bits se están reservando para host, ¿cuál es el equivalente típico en ipv4? ¿cuántos bits reservamos para host? en una barra 24 por ejemplo los últimos 8 los últimos 8, si hacemos 192, 168 10/24 estamos permitiendo que después del 1. cualquier cosa, si cualquier cosa tiene nada más que 8 bits que me da de 0 a 256 de 255, perdón, posibilidades yo lo puedo usar para el direccionamiento de host menos el broadcast, menos el direccionamiento de red y demás, todo eso se rompe en ipv6 ¿qué significa que tengo 64 bits de host? fíjense que de pronto, la internet que conocemos hoy, la ipv4 tiene 32 bits y nos hemos dado la panzada, así pero panzada panzada, de decir "eh muchacho, tenemos tantas direcciones que tenemos que... fija" fíjense que hemos reservado para la parte host 64 bits ¿cuál les parece a ustedes que es el racional de eso, la razón de eso? en realidad yo la mencioné en este rato que hemos estado hablando de que sea tan grande 64 bits para lo que usted dijo de que en cada ip pública se pueda generar como una internet dentro no, no, no, tenén pensado que si estamos hablando de que esos 64 bits es la parte de host significa que ¿cuánto es la parte de red? una dirección sea ipv4 o sea ipv6 tiene un prefijo de red y una parte de host, sumando todos estos bits me da la dirección el tamaño de dirección completa en ipv4 por ejemplo, una barra 24 tiene 24 bits de prefijo de red y tiene 8 bits de host si en ipv6 el default tiene 64 bits de la parte de host, ¿cuánto le queda de prefijo de red? 64 nada más que porque está justo en la mitad de 128 pero entonces fíjate que hemos achicado si se quiere estos dos a la 128 que recién veníamos festejando y tirando manteca al techo lo hemos achicado en 2 a la 64 prefijos de dirección de red que en realidad si le robamos los 3 bits que están ahí en la pantalla de las direcciones públicas estamos teniendo 2 a la 61 más o menos cantidades de de prefijos disponibles que también es prácticamente lo que yo les decía de un internet dentro de otro es casi son 61 bits comparado con los 32 que tenemos hoy entonces prácticamente como si lo hubiéramos hecho una vez un poco menos de una vez a este proceso que yo les decía, este proceso exponencial de aumento de direcciones pero bueno, volviendo a la pregunta, en realidad no es por eso ¿por qué les parece ser tan generoso? extremadamente ¿por qué no dejaron que sea variable como hacíamos con ipv4 o que fueran 32 bits? ¿por qué 64 bits? ¿para usar la mac? ajá, ¿cuánto dijimos que me dio una mac? 64 vamos con la memoria 48 48, entra perfecto en 64 y en realidad ese es justamente el mecanismo que recién veíamos que era lo que yo les decía que le hacía un avant premier en el cual vemos que pedazos de los bits de la mac están componiendo el post fijo que vendría a ser la dirección de la parte de host de este /64 ahora que ya sabemos un poco más ¿hasta dónde tengo que hacer highlight para indicar el prefijo de red? esto es un /64, ¿dónde me paro? si yo le digo muchachos, ¿cuál es esta red? las primeras cuatro conjuntas perfecto, ¿por qué? porque es justamente esta, acá salió fácil no como el /3 que salió más atormentado 128 dijimos que tenía 8 conjuntos de 16, los primeros 4 son justo /64 así que ese es prefijo de red eso identifica mi vecindad en IPv6 muy análogo al 192, 168, 10/24, en este caso mi vecindad de red es la 11470 dba9 0/64 ¿cómo haría para confirmar eso? ¿qué comando tengo que hacer para encontrar cuál es mi vecindad de red? route bien, perfecto fíjense que a diferencia del IPA, no me da por default 16 así que tengo que pedirselo al comando y ahí lo pueden ver está bien lo que dice ahí, confirma lo que yo les había dicho recién fíjense esta en realidad acá está dos veces vamos a ignorar lo que dice RA por el momento vamos a tomar esta, pero fíjense entonces que acá hay un prefijo esta vecindad /64 fíjense que acá se tomó la licencia de que como ya habíamos aprendido que si tengo todos ceros puedo comprimirlo con doble dos puntos y al igual que en IPB4 la dirección de red es aquella dirección que tiene todo en cero, si yo quisiera esta /64 todo en cero tendría que escribir todos ceros acá, con lo cual lo puedo comprimir a doble dos puntos que es lo que estamos viendo acá entonces esta es la dirección de red de mi vecindad ¿cuántas /64 distintas ven ustedes ahí que tenemos? como direcciones de vecindad dos ajá una es la 2001, ¿esta es una elección IP pública? sí ¿por qué tiene dos o por qué empieza con dos o con tres? listo, no hay más que preguntarse, ¿esta es una elección IP pública? no, no, con seguridad y vamos a verla está por muchos lados, es más si yo me voy a cambiar acá momentáneamente, acá estoy en la uuh, esto es mac bueno, sí, bueno estoy en una mac, pero me instalé un paquete que trae los comandos hyper-root a los linux esto no existe en mac, si ustedes lo quisieran hacer en mac creo que es /menos-in o algo por el estilo, sí a mí me gusta fíjense que me voy a ir a una, para que sea más fácil sin confundir tanto, me voy a ir a una máquina linux que tengo acá en mi red en realidad la que me conecta vía 0 tier a la uni a 6 root fíjense que fíjense que es loco, ¿no? porque la feo 80 está como muchas veces, ¿no? está contra este dispositivo, contra este por cada dispositivo que tengo tengo una feo 80 /64 en particular, fíjense que la que, les cuento que esta es la placa wifi todas estas son cosas virtuales desde la 0 tier hasta que no esta sería lo más equival es lo más parecido a la que teníamos acá, a esta que me dice, la feo 80 /64 está a través del dispositivo ENDS3 en la cloud la feo 80 /64 está a través de el dispositivo este wifi que identifica esta vecindad ahora, tengo muchas feo 80 ahí, ¿no? ¿qué será eso? ¿qué se les ocurre que es ese prefijo en particular? feo 80 /64 ¿serán como la 192 de IPv4? no es como la 192, es como la 169.254 en realidad no son muy entendidas o usadas es una es un prefijo de vecindad pero yo tengo tantas vecindades como dispositivos tengo, porque yo estoy conectado a todas estas vecindades, más allá de que más arriba lo que está ahí sobresaltado sean todas virtuales, yo tengo cada una de estas vecindades, entonces, acá parece algo extraño, que si yo quiero agresar a esa vecindad, no me alcanza con poner una dirección que sea feo 80 sería ambiguo, tengo que decirle a través de este dispositivo porque es como que yo tengo una pata que va a depender de la Mac fíjense que si hago -6a esto va a quedar agresionar ¿qué podemos hacer acá? parece no -6a y solamente el dispositivo este parece un poquito este es el mismo caso que veíamos recién, fíjense que esta es mi placa wifi, esta es la Mac de mi wifi, acá se ve un pedazo de los bits esto fíjense que hay 5791 ah maldición esta versión de Linux tiene unos aditivos de privacidad que en realidad no están respetando ese de poner los bits de Mac en la IPv6 así que no se los voy a poder mostrar pero bueno, pregunta rápida ¿tengo una en mi placa wifi, tengo una dirección IPv6 pública? no esta la es feo 80 feo 80, solamente feo 80 y feo 80 es ahora si volvemos a la cloud feo 80 es justamente el prefijo que identifica lo tenemos acá, que identifica link local unicas quiere decir que fíjense alguien se anima alguien me copia por favor acá en el chat su dirección feo 80 si, en el caso mío la mía, si yo tuviera que copiar acá en el chat, lo voy a hacer sería esta ah bien, gracias, ahí alguien copió bien entonces vamos a ver si esto es cierto te voy a hacer un ping, Lucas vamos a ver, esta es tu dirección vamos a hacer un ping me dice argumento invalido que estará pasando porque ese ping no anda? y porque este ping si anda? más, para demostrarlo esta dirección, la dirección que se resuelve acá, es pública o no es pública? es pública porque empieza con 2, listo fíjense, este anda y este como que me da una cosa rara me dice, invalido argumento porque no puedo pinguearte? así como pingueaba la 192 168 de mi vecindad fíjense que es, si se quiere está bien que hay otra ruta a la vecindad, pero si se quiere en cuanto a rutas que no tienen un componente de IP público, porque bien sabemos que que esto, esta es una IP pública esta 2000, ya sabemos, eso es pública las que no son públicas pero fíjense que tampoco tengo una privada, tengo esta feo 80 que son link local, porque me estará fallando esto, que les parece? no anda voy a poner el ejemplo con mi máquina acá, el notebook que tengo al lado con Linux que pasa si yo hago un ping a una feo 80, cualquier cosa, como estoy haciendo acá, yo voy a ir switchando entre estas dos consolas, la que dice ubuntu@ es la de la cloud, la que dice jojo@ jojox270 es la laptop que tengo acá al lado que pasa si yo acá en mi laptop hago le pido ping a la feo 80 dos puntos, imaginemos que con el mismo criterio tengo alguna dirección acá de algún vecino de mi red acá le pongo, no sé acá le pongo una cosa así, obviamente no va a ser así porque va a tener los pedazos en la mano cuál es el problema de ese comando cuando se lo tiro al kernel que problema tiene cuál de esas cuántas entradas en la tabla de ruteo machean con feo 80 con esa dirección que estoy poniendo ahí claro, hay varias que van a machear, varias que van a machear porque es /64 fíjense que yo he establecido los cuatro componentes últimos, quiere decir que acá hay, para que sea un poquito más claro, que aún estamos aprendiendo cómo es esto de la compresión de direcciones esto sería el equivalente a esto, sí que esto es lo mismo que feo 80 doble punto, uno, dos, tres, cuatro temas que macheo contra varias y qué necesito yo para poder romper esa ambigüedad porque, a ver, qué es lo que estoy haciendo con ese ping, estoy haciendo un ping a una dirección de un vecino el problema es que no le estoy diciendo qué vecindad y el problema es que IPv6 tiene un solo prefijo para todas las vecindades, porque asume que al no haber repetición de MAC, no va a haber colisión sin embargo, si yo quiero que, ahora vuelvo a la clave que este ping tenga éxito qué me falta decirle entonces, más allá de que acá en principio, yo viéndolo yo humano, nosotros vemos que no hay ambigüedad pero podría haber, porque la feo 80 está siempre dedicada a direcciones de enlace qué me estaría faltando en ese ping? El dispositivo la interfase la manera de hacerlo, de una manera estándar, y acá vamos con las notaciones, es poniéndole por ciento el nombre de la interfase y ahí estoy pingueando a mi vecino que no está con ganas de mandarme el ping lamentablemente a la gente, qué estará pasando ahí? vamos con esta me encanta, pregunta yo lo estoy pingueando, fíjense que ahora no falló el comando, sin embargo no me responde el ping veamos si lo encontró en el enlace habrá descubierto, para eso voy a hacer el comando ip neighbor que sería equivalente a arp no existe arp en el pvc, es solamente equivalente conceptualmente qué les parece? lo ha resuelto en enlace ha podido mapear la ipv6 que yo le puse acá en la ens3 la ha podido encontrar en base a lo que ven como la salida de ipn sí, ahí está la vaca acá está, dice reachable quiere decir que la está encontrándole pero don lucas no me está respondiendo el ping qué estará pasando a don lucas? que no está con ganas de responder ismp en ipv6 qué pasará? y si ismp en ipv4 con su maquinita en la cloud qué estará pasando? alguien se imagina? puede estar pasando? nosotros habíamos dado permiso por el ipv4 qué permiso? qué eran permisos? traducido a firewall traducido a cloud cómo se llamaban estas cosas? habilitar los puertos? no security groups entonces si ustedes entran a la consola de cloud en particular, si vos la tenés a mano lucas si no, lo podemos hacer a redes entremos a lo que tenés a mano es genial entremos acá a manage rules en realidad van a ver que para que eso funcione vamos a necesitar poder hacer permitir ping hacia cualquier ipv6 como lo hacemos eso vamos a agregar una rula le vamos a poner entonces ismp all ismp en ingres cidr y cuál sería el cidr entonces para todo cuál sería el equivalente al 00/0 en ipv6 lo voy a dejar ahí pero voy a tipearlo más para que lo veamos díganme cuál sería el equivalente a todo el mundo ipv6 2.2.0 ajá porque sería recuerden estamos tratando de poner el prefijo más pequeño matemáticamente sabemos que es un barra cero y sabemos que por ser barra cero todos los bisos tienen que estar en cero así que yo tendría que acá hacer algo así o más o menos no sé si hay 8 ahí pero debería haber 8 pero como bien sabemos eso se puede comprimir por lo tanto para que don lucas me pueda recibir mi ping él debería permitir todo el ismp obviamente esta regla es muy amplia podría achicarlo a solamente 80 por ejemplo pero por ahora para simplificarlo esto sería el equivalente al 00/0 que veíamos en ipv4 hacelo por favor lucas si creo que ahí lo hice genial árbol quiere decir que también te puedo hacer ssh conecta por ssh pero te puedo hacer ping ¿qué está pasando? no está el tcp puesto claro no está en 22 que es esta regla que yo se la había agregado acá que sería exactamente lo mismo acá sería nssh yo permito ssh y lo mismo el cder la realidad es 22.0 no me haga error porque ya lo tengo agregado eso permitiría que yo pudiera hacer ssh vía ipv6 contra tu máquina ahí lo hiciste más allá de que obviamente no tengo credenciales y no hace falta que me las des mejor dicho no hace falta que agregues mi clave pública o punto @ tampoco bien perfecto entonces esta fue una pequeña divergencia de lo que veníamos veníamos viendo porque no estaba relacionado con ipv6 sencillamente era el security groups firewall as a service que nos brinda la cloud para proteger nuestras instancias por default que al igual que lo hicimos en ipv4 tenemos que permitir protocolos porque esto es básicamente otro protocolo de red comparten mucho con ipv 4 ipv6 pero es como estamos desplegando directamente otra capa de red que tiene el mismo comportamiento vamos a que tiene icmp y demás pero básicamente es otro dialecto de red dentro del mundo tcp ip que en principio no tiene punto de conexión con ipv4 eso es importante entenderlo y aparecen estos conceptos extraños como este que les comentaba recién fíjense que si yo con el mismo criterio si intento hacer ssh a la dirección de lucas me dice no no invalid argument por qué y bueno porque estoy usando una f80 que es un prefijo de enlace y no estoy diciendo cuál de mis enlaces a cuál me refiero dónde está este vecino no le estoy diciendo porque ipv6 tiene eso para describir cualquiera de mis posibles vecindades f80 bien ¿se entendió eso? es importante ir cachando estos conceptos nuevos que aparecen en ipv6 porque son claves y entonces ahora vamos a backpedalear un poco y yo les pregunto en la cloud yo voy a grepear a ver que puedo grepear ip -6 alidev en 3 creo que acá podía decirle que existe determinados tipos de direcciones un segundito que no me acuerdo las entradas hay una manera que ahora ya no me acuerdo ah scope scope link oh genial anduvo scope link scope global bien bueno fíjense ahí le he pedido he aumentado un poquito la línea de comando de ip para que me muestre dirección con scope link dirección con scope global vamos a detener un momento en la dirección con scope link voy a hacer lo siguiente vamos a hacer ip ali dev en 3 en todas las direcciones y voy a hacer en particular un cuando vamos a detener la dirección del link pregunta ¿ustedes que les parece? ¿esta máquina necesito de la ayuda de alguien más para poder entre comillas obtener esta dirección ipv6? no ¿por qué? porque se la asignó con la mac pero son 128 bits ¿cómo hizo para asignarla con la mac sola? fe80 0 hasta la mac exactamente hasta la mac en realidad vemos que acá hay nos permitimos una pequeña divergencia fíjense que acá no es exactamente la mac acá llega hasta 3g y tiene adentro un ffe que no está en la mac presente es como que agarro la mac y en el medio la rompo en 2 le pongo ffe le pongo los bits de un lado y del otro acá vemos que hay flipado un bit que dice fa16 acá está en focho 16 son detalles de sintaxis pero lo importante es que es determinístico estos 48 bits de la mac se transforman de una manera determinística en el posfijo de host en los últimos /64 y los primeros /64 no necesité de una entidad central que me los dé porque el protocolo dice loco tomá fe80 y en cada uno de los cacerolas de enlace que tenés ponés fe80 dos puntos y el mapeo es el de mac y ya tenés dirección ipv6 con lo cual yo ya puedo fíjense sin ningún tipo de coordinación central yo ya puedo si tuviera las claves ya me puedo comunicar ya podría entrar a la máquina de Lucas o cualquier de las máquinas de ustedes podríamos ya coordinar sin tener un DHCP central ni nada quiere decir que uno de los y es un concepto super importante que trae ipv6 ipv6 viene listo apenas te conectás otra cosa por supuesto es un ipv6 publica global donde obviamente con el mismo criterio que estuvimos hablando estuvo justamente presentando Diego la semana pasada que para que mi ip 4 publica sea válida obviamente el resto del mundo tiene que saber como rutear hacia mi, este tema de publicar los prefijos de este ipv4 a través de los autonome system para que después la internet vuelva si este ipv4 lo mismo pasa en ipv6 puedo poner acá cualquier cosa como ipv6 publica pero como ipv6 de enlace, fíjense que ni siquiera acá tuvo que haber un administrador que diga no, esta red tiene el 192.168.1 este es el 192.168.2/24 este es el .3/24 esto es una dirección de link se prendió un link y ya vino el entrometido de la capa ipv6 y digo, ya tenés una dirección ipv6 Fio 80, dos puntos la MAC o una representación muy parecida a la MAC, determinística a la MAC, se entiende eso? Si? Si, si, si bien, Marlon, buenísimo concepto súper importante y algo que parece como consecuencia de eso es que una máquina, lo vamos a ver en realidad en mi notebook fíjense que ya ahora direcciones ipv6 a diferencia, si ustedes ven por decir el tamaño de eso con el tamaño de esto bueno, esta máquina es un engendro, pobre laptop pero básicamente la idea es que ya nomás por tener link ya tenés Fio 80, dos puntos la MAC, si? y después vemos que otras direcciones, porque eso ya me permite comunicarme con mi vecindad vamos a seguir, entonces con esto cubre cubre esto el equivalente a las direcciones ip privadas que tendrían un alcance más allá del enlace, pregunta ¿puedo rutear más allá del enlace la Fio 80? ¿puedo decir IP route a Fio 80 barra un prefijo más corto a través de un vecino de enlace? ¿qué les parece? ¿cómo? ¿puedo rutear una Fio 80 remota? recordemos Fio 80 entonces el prefijo que identifica a una ruta que siempre ruta de enlace es el scope link imaginemos que yo tengo dos tengo un router acá en el medio y tengo dos links dos cacerolas y yo estoy conectado a esta ¿puedo de alguna manera rutear la Fio 80 de esta de esta segunda cacerola a través del router que me conecta a ella y decir Fio 80 barra algo a través del router este y no es correcto que no, pero por qué? y porque no podemos salir de la vecindad bien, estoy diciendo un contrasentido, es como que yo quisiera rutear el localhost ¿sí? 127.0.0.1 está atrás de, de qué me está hablando 127.0.0.1 soy yo con el mismo criterio Fio 80 es nada más que el globito al cual yo estoy conectado en esta interfase entonces yo no puedo hacer, porque no tiene sentido sobre todo porque Fio 80 es siempre el prefijo Fio 80 barra 64 y después vienen los bits de MAC, no habría manera de generar un espacio ordenado donde este prefijo de IPv6 corresponde a esta vecindad, a esta red, a esta LAN este prefijo, este otro prefijo de IPv6 corresponde a esta otra sencillamente porque hay un solo prefijo que es link local y eso está escrito directamente en el stack, chau si es Fio 80 te encuentro en el enlace no se juega más, no hay gateway no hay nada porque es scope link como siquiera el lugar intermedio de alguna manera entre el scope link y el scope global, están estas direcciones que vienen a ocupar el, como habíamos dicho hace un rato, el lugar de elecciones IP privadas que son las que la FC 00 barra 7 y acá vamos a torturarnos un poco nuevamente cuál es la pregunta de maldad que voy a hacer ahora, ustedes ya la conocen diganme entonces qué cosa cuál es la primera dirección de FC 00 barra 7 FC 00 y listo todo cero bien, perfecto, y cuál es la última qué lindo, si fuera barra, hagámosla de la misma manera que recién si fuera barra 8 FC sería FC y FF 00 claro, FF barra 128 si fuera barra 8, pero lamentablemente no lo es le robo a un FD más FD, ok quiere decir que todas las direcciones que empiezan con FC y con FC cualquier cosa FD cualquier cosa identifican este grupo de direcciones que se llaman unic, local y pv6 que ocupan más o menos el lugar de la 192, 168, etc. vamos, creo que más adelante está por qué se llaman unic, si no damos un pequeño avant premier vieron, vieron que estamos usando nosotros 0 tier para poder conectarnos cambio el contexto un momentito cuántas 0 tier que tengo cuál de todas estas es la 0 tier de la universidad son las 10, 200 algo, no estas vieron que cuando ustedes se conectan, creo que ustedes reciben esta, no en IPv4, 10, 203, 00 barra 16 cómo le habría ido si a alguno de sus compañeros justo le hubiera usado la 10, 203, 00 barra 24 por ejemplo en la red local en el router en el AP, en el router acá habría habido algún problema o no de que hubiera esa colisión o déjenme ponerlo desde otro ángulo qué hubiera ocurrido si nosotros cuando configuramos el 0 tier que tuvimos que hacer esta configuración hubiéramos dicho, ah no, directamente usemos miren, usemos para la red 0 tier virtual este prefijo de red qué les parece, habría sido una buena idea o una mala idea y es probable que ya tengamos una IP de esas asignadas en nuestra red en la red local tuya y por lo tanto si esa fuera el prefijo de la red virtual no funcionaría porque alguno de los dos ganaría, dependería del tamaño del prefijo, del orden pero en definitiva habría una ambigüedad porque cuál sería el problema que su máquina real con su dispositivo real, su wifi ya tendría, imaginando que justo le pegaramos al mismo prefijo, 192.168.1.20 y resulta que nosotros a través de 0 tier con toda la virtualidad y qué se yo justo tuvimos la mala suerte o el mal criterio de ingeniería de elegir uno de los prefijos más usados como son este o como son el 00/24 los prefijos más usados, sencillamente no hay ninguna ley ni coordinación de eso sencillamente que ocurre que los fabricantes típicamente en sus APs o los ISPs cuando entregan ustedes el dispositivo para conectarse que es AP, router y todo lo que ya sabemos típicamente tienen estos prefijos entonces, por eso nosotros dijimos che, busquemos, entre comillas, algo raro, también habría sido mala idea usar el 00/24 porque es demasiado al principio y bueno, busquemos los 200 ahí al medio porque a veces algunos locos usan el último justamente para algo distinto, entonces bueno nosotros con un poco de suerte con un poco de bola de cristal dijimos, bueno, usemos 200 algo para identificar estas redes pero hay una posibilidad no nula de que algún otro cerebro apareció y elegió lo mismo, en definitiva habría una posibilidad de colisión ¿qué es? ¿cómo se? ¿en qué difiere esto con IPv6? que ahora tenemos tantos bits que ahora si volviendo a esto que estamos componiendo esto, fíjense que tenemos un /7 ¿en cuántos bits libres? ¿cuántas? en bits, dígamelo ¿cuántas redes libres /64 nos quedan? ¡ay! qué pregunta difícil yo fijo los primeros 7 bits y dejo ya sé que los últimos /64 es lo que yo estoy comentando, ya se ha definido como el estándar de convención que van a ser ocupados como la dirección de host porque ahí me entra muy cómodamente una MAC 802 por lo tanto tengo los últimos /64 son dirección de host ese prefijo /7 como lo estamos viendo ahí es lo que define el prefijo de todas las direcciones unique, local ¿cuántos bits para jugar con redes me quedan? 57 bien 57, muy bien 57 ¿por qué? porque sencillamente 128 menos los 7 que vemos arriba menos los /64 obviamente eso es 57 ¿y cuánto es entonces eso en cantidad de redes? ¿son 57 redes? 2 a las 57 2 a las 57 es decir, tenemos para jugar con no me sale leer cuánto, cantidades de trillonesimos de redes, ¿qué ocurre? ¿cómo podemos usar eso para nuestro bien? lo que hacemos es hacer una administración como hay un /7 yo puedo fijar por ejemplo tomar, no sé, tengo 57 bits y lo que se hace es los primeros 48 bits de esos tiro los dados directamente, ¿sí? por eso es unique, local con un criterio parecido al de UUID esos de los 57 que tengo libres que son un montón, una barbaridad, nunca voy a tener un sistema que tenga tantas redes distintas por más virtual que sea voy a tomar los primeros 48 bits y los voy a rellenar con lo que me digan con lo que me digan los dados tiro la moneda, tiro los dados y genero todo ese prefijo vitiano, randómico los primeros 48 si usé los primeros 48 los 57, ¿cuántos bits libres me quedan? 57, le resté 48 9 ¿sí? 48 más 9 57, me quedan 9 bits y eso ya los empiezo a administrar son 9 bits, todas las 9 redes son 512 redes distintas en principio y eso ya los puedo empezar a administrar para distribuirlos en mi potenciales 512 me puedo robar más bits de la parte random ¿para qué es eso? justamente para evitar exactamente el problema que yo les decía recién, este problema de colisiones, nosotros así dijimos uy, estimamos que esta no va a estar usada o sea, si hay alguno de los flacos que está usando esta estamos en problema, lo siento va a haber colisión, no les va a andar va a tener que ir flaco, porque justo tuvo la mala suerte de poner el mismo prefijo en su red que nosotros elegimos para la red virtual va a tener que cambiarlos la idea de este proceso de usar todo un pedazo de las direcciones unique, local y rellenarlo, si se quiere yo lo estoy acá sobresaltando rellenar esta parte acá habíamos dicho que era desde la FC hasta la F, rellenar toda esta parte más o menos con una parte random es tal que si alguna vez yo necesito conectar estas dos redes a través de algún mecanismo virtual, lo puedo hacer sin tener que hacer un redireccionamiento ¿no? es como si el equivalente de IPv4 es como si yo me hubiera autoforzado a que, no sé bien sabemos que este es un prefijo de redes de redes privadas es como si yo me hubiera forzado a que estos dos octetos a generar una barra 24 que voy a usar tengan que ser totalmente random es como si yo hiciera algo así como random por 155 155 y en vez de yo hacerlo a mano le pido a mi generador random que me diga cuál va a ser la red ¿no? ese sería el equivalente en vez de nosotros haber dicho con Diego y 203, haber dicho bueno tiro los dados y bueno acá tengo 16 bits de potencial de colisión en el caso de IPv6 tengo 1 sobre 2 a la 48 de colisión que obviamente es un espacio mucho más grande nuevamente la idea es que ese prefijo por eso se llama por eso se llama unique local el unique es muy optimista pero con certeza optimista de que cuando tiré los dados para rellenar ese prefijo de 48 cada uno del mundo que tiene los dados le va a dar un resultado distinto de tal manera que si potencialmente hay que hacer algún tipo de conectividad virtual entre esos espacios y reaccionamientos no se repitan ¿se entendió un poco la idea? ¿sí? ¿sí? ¿más o menos? es como esto pero aplicado esto acá pero aplicado para IPv6 bien y ya cortamos ya terminamos, ya nos vamos a recrear ya volvemos y seguimos viendo ya vamos a comparar las cabeceras de IPv6 cuando volvamos y hacer un poquito más entonces ¿qué estamos entendiendo hasta ahora? que los prefijos correctamente identifican qué tipo de reacción estamos ya hemos visto si empiezan con 2 o 3 son públicas, si empiezan con feo 80 listo, son link local, no hay que pensarlo más si empiezan con fc o fd son unique local son routeables ahora sí puedo routear, puedo decir que la fd todo este prefijo /64 está atrás de aquel router porque ya no son link local identifican a redes completas y dentro de ese mismo ámbito de problema vemos las unicas, las unicas son todas, son las ff 00 /8, quiere decir, dígame cuál es la primera y la última de estas la primera es la es fácil muchachos ff 00 00 00 00 00 /128 porque estamos diciendo hasta la, cuál es la última? todas f y ahí como son /8 le dejo libre todo el resto, ff y acá siguen ff y se repite realmente yo no lo voy a tipear /128 esas siempre que huelen como una mac absolutamente nada que ver con una mac de broadcast esas son todas las direcciones multicast y vamos a ver, ustedes ya la tienen en su etc hosts van a ver algunos ejemplos de direcciones de multicast que ya tienen, fíjense em eee ff /8 localnet sí, éstas sí, acá lo, multicast prefix all nodes acá yo podría hacer un vamos a ver si me anda, pero va a depender de que de que, acá no sé si la cloud me va a dejar, voy a intentarlo ff 02 voy a intentar hacer un ping a todos los nodos estoy seguro que me ande oh, se vuelta el invalor, qué está pasando esto por qué no anda el dispositivo de la interfaz perfecto, muy bien esta belleza mirá esa belleza qué me respondió ahí ese fue un ping, fue un multicast, no un broadcast descuélguemos, mala palabra broadcast en IPv6 se dice broadcast, se sale de la puerta y nos vemos en la próxima, en el próximo turno no, mentira o no, pero bueno, más o menos ese fue un ping a todos los que, veamos, no tienen por qué saberlo veamos, yo elegí eso del etc host que ya viene precargado en Linux, donde el ff ff 02 son IPv6 all nodes entonces todos los nodos a los cuales llegue este datagrama a través de multicast lo responden y por eso es que obtengo un ping duplicado porque responden todos vamos a ver rápidamente para descubrir todos los routers a qué debería pingear al 2.2 lo ven arriba, all routers bien, en esta red interesantemente vemos que me han respondido dos routers fíjense este y este en realidad hay uno solo pero no sé por qué me está respondiendo otro alguna de las máquinas está configurada como router también, debemos tener alguna máquina ahí ¿cómo va para pingear solamente los hosts? no todos los nodos fíjense que interesante acá el conjunto all nodes es todo todo lo que tenga IPv6 en mi multicast en este caso este prefijo es para multicast en capa de enlace, todos los nodos estos son los que son solo routers y estos son los que son solo hosts quiere decir que acá van a aparecer todos ¿está bien? ah mira que interesante, no me respondió ninguno a los que no lo implementan están respondiendo todos los nodos, me están respondiendo todos los hosts y no tengo no sé por qué no me está respondiendo todos los hosts bien ¿debería responder el mío ahí? ¿dónde? en el de los hosts sí debería, no sé por qué honestamente no sé por qué, debería ¿usted, vos reconoces el tuyo? lo podés ver por acá cuando pingeo todos los nodos creo que es el antepenúltimo, el 7f a ver ahí me fijo F5 o E7F debería terminar tu MAC F5 o tu IPv6 E7F sí ah perfecto, este sos vos, correcto debería, debería, no sé por qué, habría que buscar, capaz que es algo que ha cambiado en los últimos kernel en la última RFC, desconozco no me esperaba esto, me esperaba que aquí respondían todas las cosas IPv6 routers y hosts, es decir todos los nodos acá solamente aquellos que están configurados como routers en esta capa de enlace y acá solamente aquellos hosts, fíjense que fácil es descubrir quiénes son los routers en esta red cuestión de enviar un datagrama adecuado a esa dirección multicast, con eso ya descubro quiénes son los routers es más, si tengo que mandar un mensaje a los routers, como por ejemplo alguna solicitud de algo no molesto al resto de mi vecindad al resto de mis pares hosts sino solamente molesto entre comillas o hago un datagrama con destino a solamente aquellos que sean routers en esta red fíjense esto es muy muy rico el hecho de que la dirección IP ya identifica grupos bien conocidos todos aquellos que son routers en esta red todos aquellos que son hosts todos aquellos que son cualquier cosa IPv6 en esta red ¿Se entendió esto? ¿Sí? Esto está dentro siempre del ámbito de multicast que sería la versión de broadcast prohibido decirlo en IPv6 que siempre hace un grupo no hace el todo de mi enlace ¿Alguna duda hasta acá muchachos? Ya sé que todo esto es nuevo, por ahí si no lo han visto nunca se ven horribles las direcciones IPv6 pero bueno, tenemos que empezar de alguna manera a atornillarlas empezar a poder parciarlas sobre todo, poder separarlas encontrar los dos puntos que tienen 16 bits adentro son como máximo cuatro dígitos hexa y toda esta cosa, si son todos ceros separadas por dos puntos sirve para comprimir todo ese conjunto de ceros ¿Vale? Bueno, vamos a hacer un recreo son las 19.38 yo creo que sí, volvemos a las 8 está bien, y ahí le daremos un horito un horito y cuarto más para completar un poco esto y quizás hacer alguna otra práctica Entre paréntesis me gustaría ¿Hay alguno de ustedes que tenga un IPv6 en su máquina? No en el router, recuerden que la clase pasada hicimos este ejercicio fuimos a WhatsMyIP WhatsMyIP address y algunos les había dado muy interesantemente les había dado acá IPv6 les había dado, yo no tengo IPv6 algunos de ustedes les había dado pero el tema sería si el proveedor de ustedes ya les ha configurado para que no sólo la pata externa sino que también en su máquina tengan un IPv6 Si alguno, la clase pasada es decir, de su conjunto, nuestros compañeros que están acá aquellos que observaron un IPv6, la pregunta sería ¿También tienen acá si hacen un IPv6 a ¿Observan alguna dirección IPv6 que tengan pública? Así que empiezo con 2 o con 3 Ahí me fijo La pregunta es para aquellos que observaron que sí tenían un IPv6 público No, profes, yo tengo solo IPv4 Ah, en tu máquina Yo también, profes Yo, profes, creo que tengo IPv6 Ah, mira, Franco, bien Es decir, en tu máquina tenés un IPv6 real, en tu nodo ¿Habrá algún inconveniente para que vos le puedas hacer ping a mi máquina acá de la Clouds? Voy a copiar acá en la dirección No, no la había copiado nunca Ahí la pego Esa es mi dirección IPv6 pública ¿Qué onda si intentas un ping a esa? A ver, ahí intento Dale Acordate de meterle la interfaz No No, buen punto Bien, bien, pero no porque es una 2000 algo, es una pública Ahí está la IPv6, yo también, profes ¿Están pudiendo? Sí, está bien Hay que bancarse ya vamos a ver por qué Pero fíjense lo que voy a hacer ahora -i -i ens3 ip6 ansmp6 Ahí están Alguien me está haciendo un ping Un tal 2803908 me está haciendo ping Vamos a ver si también se la banque y yo le puedo hacer ping También, es más, si tuviera el SSH abierto Ahora Alguno de ustedes no tiene SSH abierto déjame ver si tiene algún web server Probémosle un puerto 80 No, tampoco, a ver algo que tenga abierto ¿Qué está ocurriendo acá? ¿Ustedes pueden hacer ping a la máquina que recién me hizo ping? De hecho Así como me hicieron ping podría hacerme SSH a la máquina que está dentro de la cloud ¿Se entiende cómo cambia drásticamente el mundo? Fíjense, ¿ustedes podían hacer SSH sin levantar 0 tier a sus instancias de la cloud? ¿Pueden hacerlo? Si no están conectados a las VPN si no le hubiéramos dado credencial si no hubieran hecho todo ese proceso todo el onboarding No, porque no tienen la VPN no tienen esta red virtual armada Acá estamos usando todas las direcciones IPv6 públicas, de hecho yo estoy pingueando algunos de los que me pingueó en su IPv6 pública Si esa persona levantara un servidor SSH a las reglas adecuadas yo podría entrar a su máquina Cualquiera de ellos podría entrar a mi instancia de la cloud sin ningún tipo de NATEO sin ningún tipo de VPN en el medio de IPv6 pública a IPv6 pública Y esto es una muestra un poco de cómo arrancamos todo esto Fíjense, ahora de pronto al desaparecer NAT estamos pudiendo adresar, direccionar directamente cada dispositivo Después será una cuestión de seguridad si yo lo permito o no, si pongo una valla para decir no quiero que cualquiera cualquiera de la IPv6 pública entre a mi máquina, le pongo configure firewall parecido a lo que hacemos con los security groups en la cloud Pero es una cuestión de seguridad, pero el tema del adresamiento es que ya tenemos adresamiento punta a punta Eso es súper importante, se ve, ¿no? Es más, para aquellos que ¿Hay algunos de los que recién me hicieron ping que tengan Linux? Es decir ¿Algunos de los que me estaban pingueando recién acá? ¿Alguno de estos? Yo, sí ¿Sí? Entonces, te dejo como, te dejo, les dejo a esos, estamos subconjunteando ¿no? Porque son subconjuntos a aquellos que tienen la suerte de tener IPv6 en sus en sus casas, subconjunto de ese subconjunto otro que tienen IPv6 en su máquina, entonces lo que les dejo como tarea es que ingresen a su instancia de la cloud directamente por IPv6 Con lo cual pueden tener caído el SIRTIR, podemos tirar abajo nuestra punta de VPN, pero que entren directamente por IPv6 Se los dejo como tarea Nos vemos a las 8 (Corto la grabación) Y aquel que lo pueda hacer si no tiene problemas, estaría bueno si puede presentar para mostrar mostrar lo que se ve y como para completar la idea. Me encantaría yo poder hacerlo, pero yo no tengo IPv6 acá, así que no puedo (Corto la grabación) pero yo no tengo mi PVC de acá así que no puedo. [AUDIO_EN_BLANCO]Todavía no. Estamos en la segunda parte de nuestra primera clase de IPv6. Bien, vamos a hacer... a ver en qué secuencia... Sí, vamos a ir a la cabecera porque es bastante rápido y después, antes de terminar, les voy a mostrar más o menos cómo es que tenemos configurado esto. Lamentablemente no tenemos un proveedor que nos dé IPv6 en la pata externa donde tenemos la IPv4 pública, no tenemos una IPv6 pública y hemos tenido que usar algún servicio extra para hacerlo, servicio de tunneling, y vamos a describirlo un poquito eso. Vamos a la cabecera, les muestro ambas cabeceras. Les cuento que... van ahí lamentablemente no se ven la cantidad de renglones, pero si IPv4 tiene 32 bits, y con 32 bits o 4 bytes de origen y destino, y en total mide 20, uff, ¿cuánto medirá una cabecera IPv6? ¿Cuánto es el mínimo que tiene que medir una cabecera IPv6? ¿Qué les parece? ¿Cuánto mide en bytes una dirección IPv6? Una dirección IPv4 mide 4 bytes. ¿Cuánto es la relación de tamaño en bits? ¿Qué también es la relación de tamaño en bytes entre ambos? ¿Entre 6 y 4? 4 veces más grande. Ah, bien, por lo tanto, ¿cuánto es el tamaño mínimo? 16. 16 por 2, por lo tanto, ¿se entiende a dónde estoy yendo? Sí, sí. Bien. 16 por 2, por lo tanto, quiere decir que la cabecera IPv6 no puede medir menos de 32 bytes. ¿Sí? Que serían estas dos direcciones, esta y esta. Bueno, la cabecera IPv6 está tan optimizada que mide nada más que 40 bytes. Así como en IPv4 medía 20, siendo que las direcciones solamente ocupaban 8 bytes, 2 veces 4 bytes, y el resto de los 12 bytes eran estos 3 renglones de 4. Curiosamente IPv6 está tan bien diseñado que nada más mide el doble, siendo que las direcciones son el cuádruple. ¿Se entiende lo que dije? Sí, tenemos 2 por 8 en direcciones, 16 bytes, y solamente se han ocupado 32, es decir, 2 veces 32 bytes, y solamente se han ocupado 8 bytes, es decir, 2 renglones de esto que estamos acostumbrados a leer en 32 bits, para la cabecera. Y hay algunas cosas que se han mantenido y otras cosas que no. Hagamos un poquito de análisis. ¿Cuáles ven ustedes? Bueno, en realidad acá están pintadas, fíjense que están pintadas aquellas que se han mantenido conceptualmente, ¿no? Exactamente, por ejemplo, el "time to live" de IPv4, ¿qué es en IPv6? El "hop limit". "Hop limit". Ahora lo llamamos bien, como bien sabemos, "time to live" no tiene nada que ver con tiempo, no hay segundos ahí, sino es cantidad de hops, justamente, "hop limit". El protocol, ¿cuál sería en IPv6? Que son nada más que las que están en celeste, las que se han mantenido conceptualmente. No son exactamente, pero están muy cerca. "hop limit", "time to live" son exactamente iguales. ¿Cuál sería el protocol de IPv4? Es "next header". "Next header" en realidad apunta a qué diablo estoy cargando acá, lo que estoy ahora señalizando con el mouse. En el caso de IPv4, decía, lo próximo que viene acá es un protocolo. ¿Cuál es el protocolo? De capa de transporte. IPv6 lo generaliza porque IPv6, "next header" puede ser otro pedazo de IPv6 mismo. Entonces directamente dice, ¿qué es lo que yo traigo? ¿Qué es mi payload? Y por eso le llama "next header", no "protocol", para evitar esto de que es un protocolo más alto, más bajo, lo que fuera. El "next header", ¿qué traigo atrás? Que viene en el acoplado, eso es "next header". ¿Cómo sería un IPv6? Y como "next header" tendría un identificador que también tiene 8 bits, que dice que lo que cargo es IPv6 y en realidad que puede ser un encapsulamiento, y acá viene una desmentira. Ya te termino de responder la pregunta, se va a responder un poco con lo que voy a hablar enseguida, para evitar enroscarme hacia adelante, pero ahí volvemos sobre eso. ¿De dónde ven el "total length"? ¿Cuál sería el "total length" representado en IPv6? "Payload length". ¿Cuál es la diferencia? Le estoy diciendo la misma palabra. ¿Recuerda el "total length" de dónde se medía? ¿Dónde arrancaba la medición del "total length"? Ahí hemos hecho un dibujito. Arrancaba acá, donde esté con el mouse ahí. E incluía toda la cabecera y después medía todo lo que venía. ¿Qué será "payload length"? El acoplado. Exacto, el largo del acoplado, no el largo mío. Entonces fíjense que hay una cuestión como mucho más prolígena en IPv6, donde dice "next header", esto es lo que llevo de carga, estoy llevando carbono, estoy llevando heladeras atrás, "next header" y esto es lo que mide lo que yo cargo. Como una cuestión mucho más encapsulada. En vez de IPv6 era un poco más confuso, porque la capa de arriba tenía que restarle al "total length", al largo de la cabecera, el "ihl". Fíjense que interesantemente, acá ya te empiezo a responder lo del "next header", fíjense que no está "ihl", voló "ihl". "Ihl" era "internet header length", identificaba el largo de esto, porque estaban las opciones y el padding, que también voló, por eso están rojos. ¿Por qué? Porque las opciones, las posibles extensiones de IPv6 se representan con el "next header". Yo necesito decir algo más de la cabecera de IPv6, como por ejemplo fragmentación en origen, y ahí es donde me desmiento, yo les venía diciendo "en IPv6 no hay fragmentación, no hay fragmentación", que era una súper simplificación en realidad. La red no tiene permitido fragmentar, eso es cierto, no hay fragmentación, es como que IPv6 arranca con "df = 1", "don't fragment = 1", y es por deforme, manera de que un router IPv6 fragmente, no está permitido. Sin embargo, está permitido que el origen fragmente. Y para representar esa fragmentación o para representar otras opciones similares en la IPv4, en realidad se usa este mecanismo, en donde "next header" será otra cabecera, por ejemplo podría ser una cabecera de fragmentación IPv6, diciendo las cosas que no se traen por default. ¿Qué prefirieron los ingenieros de IETF cuando diseñaron esto? "No gastemos un renglón en algo que sabemos que está mal". De última, si alguien necesita fragmentar en origen, no en camino, no está permitido, como decía recién, bueno, creamos un "que pague", entre comillas "que pague", con una cabecera dedicada, cabecera de fragmentación de IPv6, que tenga una información similar a la que tenía IPv4, siempre, porque esto no era opcional, y bueno, y que después recién venga el payload. Entonces es como que, es como si fuera una cadena de Legos, ¿no? Es como que IPv6, por default te viene esta cabecera y no es cambiable, es siempre 40, lo cual simplifica terriblemente las cosas también, porque antes, los routers, imagínense, ustedes están implementando acá la función que extrae la cabecera IPv6, tienen que empezar a levantar esto, ver el IHL, que generalmente es 20, pero si viene con opciones viene más, este IHL sería 5, 5 renglones, o podría ser, este IHL tenía 4 bits, pero estaba representado en renglones, así que puede llegar hasta 15, si dice 15 significa la cabecera es de 60, entonces yo tengo que leer estos bits para recién ver hasta dónde corto la cabecera. Acá en IPv6 va el tajante, dice, no es largo de cabecera porque, chicos, la cabecera es 40, listo. Si necesitan decir algo más, exprésenlo con un next header. Y de hecho hay varios, como next header, el acoplado, puede ser, aumentar lo que digo yo con mi IPv6, es decir, por ejemplo, que llevo fragmentos atrás, o directamente que yo estoy cargando TCP. Y eso, por eso se llama next header, porque a veces es directamente una carga de un protocolo de más arriba, o puede ser algo que aumenta, que ocupa el lugar conceptual de las opciones, que ocupaban las opciones en IPv4, más la fragmentación. Type of service, no lo vimos en IPv4, esto acá se llama traffic class, son bits que les indica, que uno le puede indicar a la red, si prefiere para este datagrama, si prefiere un servicio de baja latencia, de alta velocidad, de alta confiabilidad, por ejemplo. Yo le puedo pedir, eso era en IPv4, en IPv6 traffic class se puede clasificar de algunas maneras más específicas, no lo vemos porque requeriría casi media clase hablar de traffic class, y hemos preferido en el balance de cosas que queremos dar, no verlo en profundidad. Nos queda conceptualmente la idea de que ahí yo, si tengo control sobre los routers, puedo establecer caminos que son de menos costo, de menos latencia, o de más velocidad, o de más confiabilidad, y yo con traffic class, en mi datagrama puedo elegir uno u otro camino, poniendo bits distintos ahí. Bueno, entonces, fíjense que se destruyó totalmente este renglón, el segundo renglón de IPv4, estaba dedicado a fragmentación, les vengo diciendo, no hay fragmentación IPv6 en camino, no hace falta que esté por el front, si alguien tiene que fragmentar, tendría que pagar por una cabecera extra acá abajo de fragmentación IPv6. ¿Qué había de checksum? Fíjense que voló, ¿ven algún checksum en la cabecera IPv6? ¿Algo que diga checksum? No. No, no hay checksum. Estamos en un punto de la tecnología que se gastaba demasiado espacio en la cabecera en checksum para algo que ocurre raramente. Las tecnologías que tenemos hoy, o que algunas directamente descartan a nivel de enlace, como es Wi-Fi, que tiene su propio checksumeo. Entonces se dijo, ¿para qué hacer checksum? Eso nos vino súper bien en los años 80, 70, 80, cuando empezamos con la Internet y ARPA y aquellos protocolos originarios, que nuestras capas de enlace eran menos confiables, hoy no tienen sentido. Fíjense cómo hay varias decisiones de diseño. Hay versiones interesantes porque versión, más allá de que acá no es muy alegre los tamaños, mi TOC, cuando digo TOC, digo TOC real, como es trastorno obsesivo compulsivo. Si yo hubiera tenido que dibujar esto, lo hubiera dibujado exactamente el mismo tamaño de renglón y exactamente el mismo ancho para poder compararlo. Esta versión acá, estos 4 bits, tan justo, entonces, cuando yo recibo esta cabecera, ¿qué leería acá? ¿Qué leía ahí en IPv4? ¿4 bits para IPv4? ¿Cuál era la secuencia de bits que leía? ¿4 representaban bits? 0, 0, 0, 1, 0. ¿0, 1? 0, 1, 0, 0. 0, 1, 0, 0, sí, eso es 4. ¿Y cómo sería 6? 0, 1, 1, 0. 0, 1, 1, 0. De hecho, acá dice 0, 1, 1, 0. Y acá 0, 1, 0, 0. Tiene que indicar 4 o 6. Esa parte se mantiene de tal manera que cuando se recibe esto, rápidamente se puede leer la cabecera y saber si tengo que "prender el deco", entre comillas, interpretar a esto como un IPv4 o interpretarlo como un IPv6. Hay otro... Hay un interesante, tiene un color distinto ahí, se lo reconoce una especie de verde raro, que es un "flow label", a lo cual se le han dedicado nada más y nada menos que 16 bits y no está en IPv4. La idea de un "flow label", y esto es extraño, permite... tiene un sabor orientado a conexión, y por favor, dioses de la capa 3 de Internet, no me maten acá con un rayo, porque sabemos muy bien que IPv4 y IPv6 también no es orientado a conexión, son datagramas que van. Pero "flow label" permite, si yo tengo control sobre la cadena de routers entre un punto y otro, identificar "flows" como si estuvieran dentro del mismo tubo, varias conexiones dentro del mismo tubo. Ejemplo, imagínense una videoconferencia, donde tengo, por cómo están implementados los protocolos, yo solo tengo, no sé, una conexión para el canal de video, otra conexión para el canal de audio, como bien sabemos, el audio no se toca, el video sí, si la conexión está más o menos, yo me podría permitir que el video se corte un poco, pero es súper molesto si se corta el audio, ¿cierto? coinciden conmigo en eso, es una cuestión de percepción, pero no hay problema si se habla, si el audio va estable y esto se va moviendo así, es mucho más percibible. Entonces bien podría ser un protocolo, no sé, que implemente a través de conexiones distintas los canales de audio y de video, pero yo no quiero meter como dentro de la misma bolsa, por decir, esto representa una sola comunicación de audio-video entre estas partes, como que una sola manguerita dentro de las cuales están yendo varias conexiones distintas. La idea de Flow Label es esa, son 16 bits que a mí me permiten hacer que la red reconozca que conexiones distintas entre los mismos origen y destino, puede ser, no sé, entre este IP y este IP, contra distintos puertos, pero ¿sabés qué routers del medio? Todas son partes de la misma. Entonces yo le pongo el mismo Flow Label y yo puedo establecer condiciones de tráfico tales como, por ejemplo, que cada flow no me gaste más de, no sé, no me consuma en la red o le dedico en la red no más de 2 megabits por segundo. Porque yo tengo, por decir algo, no quiero que ninguno consuma más porque yo quiero, tengo un enlace entre estos dos puntos y he conseguido, no sé, 20, estoy armando números al vuelo, ¿no? 20 megabits entre estos dos puntos tengo. Y dedico 10 megabits para todo lo que es tráfico normal de internet y dedico otros 10 solo para audio y video. Como tengo audio y video de alta resolución, uso 2 megabits para cada uno, puedo soportar hasta 5 conexiones. Esas 5 conexiones, esos 5 flows, yo puedo armar la red para obligar a que ninguno de estos 5 flows haga un sobreuso y puedo decirle a los routers de medios, si es que yo los controlo, decirle "Mirá, acá van a ir 5 flows identificados de tal manera y vos tenés que garantizarme que no le vas a dar más de 2 megabits por segundo a cada uno". Entonces tiene un sabor de conexión, no es orientada a conexión, pero es una manera nuevamente de darle hints a la red que yo quiero que me trates todo este grupo de conexiones entre estos dos hosts como si fueran, que aparentemente se ven distintas porque los portes involucrados son distintos, pero son parte del mismo flow. Flow 1, flow 2, flow 3. Y esa flow label es la que me permite identificar esos distintos flows. ¿Se entiende? Un concepto extraño, ¿no? Porque no está en IPv4 y si está, fíjense que ocupa nada más y nada menos que 16 bits en IPv6. Bueno, a ver ICMP, lo vemos acá en detalle. Una cosa interesante que tiene IPv6 es que no tiene ARP. ¿Recordemos qué era ARP? ¿Cuál era? Lo vimos en la clase anterior, creo. ¿Cuál era la misión de ARP? Descubrir MACs. Hacer el mapeo de dirección lógica, de dirección IPv4 a dirección física. Y eso ahora se hace con ICMP. Recordemos que ICMP era un protocolo que estaba ahí de ayuda a IPv4. Acá es exactamente lo mismo, el rol es de ayuda, pero esa ayuda es un poco más amplia que la que existía en IPv4. En IPv6, no solo ayuda para cuestiones de red, sino también para cuestiones relacionadas con enlace. Ocupa el lugar semántico, el lugar de funcionamiento de ARP. ¿Entonces, qué les parece? Tráiganme el concepto de ARP, pero úsenmelo en IPv6 con ICMP. ¿Cómo sería esa? ¿Cómo se implementaría? ¿Cómo lo implementarían ustedes? Porque han cambiado algunas cositas de ARP. ¿Qué usábamos en ARP para descubrir quién tiene...? El broadcast. Y acá estamos fritos porque acá no hay broadcast. ¿Cuál sería la edición de Multicast? ¡Uf, puta! Me quemé. Yo quería no quemarme. La FC. No la FC, la FC, ¿recuerdan la FC federa para Unique Local? Es esta que tenemos en el ETC host, esta que yo le hice ping. Esta, ¿no? Esa me identifica... No, esas son los routers, perdón. Esa. Esa me identifica a todos. Entonces, yo podría tirar ese datagrama a todos mis vecinos que tienen IPv6, que son parte de ese grupo Multicast, preguntándole quién tiene esta dirección. Pero no solo pregunto con OAT, no me traigo de la... Repisa otro protocolo, uso el mismo ICMP, que me va a ayudar para todas las cosas que ya vimos que ayudaba en v4. En v6 también ayuda para el descubrimiento de enlaces. Eso se llama Neighbor Discovery. Y fíjense, vamos a hacer... Yo voy a dejar corriendo ese pedámeno. Y en 3, 6... Vamos a poner ahí que antes era 3, 6. Bien, no está tan ruidoso. Ahí está. Lo pueden ver ahí. Neighbor Solicitation. A ver si lo podemos cazar. Sí, se ve ahí. Neighbor Solicitation. Con un pequeño detalle, no hace... Fíjense que ese es el pin que yo había hecho, era FF2 2.1. Sin embargo, acá es 2.1 más algo más. En realidad eso es algo más, son pedacitos de la dirección que estoy tratando de descubrir. Fíjense que estoy tratando... Quizás esto es muy complicado para este momento, pero se los dejo para cuando realigan esto. Pero yo, yo acá... Fíjense que yo en F80, ¿no? Porque yo como parte de enlace, no hace falta que ponga la dirección IP pública. Yo quiero descubrir mi vecindad, así que ¿qué uso? La dirección que sea más compatible con eso, que son las F80. ¿Cuál es mi F80 en esta red? Entonces, yo voy a mandar Multicast. Hemos visto que lo que empezaba con FF era Multicast. 0.2.0.1, pero fíjense que le pongo un pedacito de la dirección que estoy tratando de descubrir. Unos bits ahí. ¿Para qué? Porque la máquina que tiene esta dirección, la pregunta es la misma. "Jujas, ¿quién tiene esta?" La máquina que tiene esta dirección se asoció a este grupo Multicast, y no a cualquiera. De tal manera que a su vez es como un subconjunto entre grupos Multicast para no molestar a las otras máquinas con esta pregunta. Es como que yo le agrego una dirección Multicast a mi máquina. Esta, yo cuando obtengo una... Hacerlo en 6MA. Fíjense. Me vuelvo a mi máquina ahora. 6MA. Entonces, MA es por Multicast adreces. También lo puedo hacer para 4, que está en las dos 24 que habíamos visto. Pero quedemos en IPv6. Fíjense que si vemos los adreces acá que yo tengo. En IPv6 van a ver... ¿Qué ven acá de coincidencia? Ven que mi máquina ha prendido como grupos Multicast adicionales en IPv6 este. Que es el prefijo Multicast, y le ha puesto los últimos bits de mi dirección IPv6. Y si ustedes hacen IP-6MA en sus máquinas van a ver esto distinto. Como que pertenece a distintos grupos Multicast. De tal manera que cuando alguien pregunte ¿Quién tiene la... esta dirección completa? Solamente atiendan todas aquellas máquinas que están dentro de este grupo Multicast. Que muy probablemente sea solamente yo. Es una sobre-optimización del protocolo. El lugar que ocupaba ARP, entonces lo ocupa ICMP. Esto se llama Neighbor Discovery. Era lo que estábamos viendo recién cuando se pedampeamos y se me pese a eso. ¿Alguien que me haga un ping? Estaba la dirección acá, era lo que dice luego de Lucas, la F80 y la penúltima línea. Si alguien me hace un ping. ¿Un ping a la F80 termina con D804? ¿Alguien? Por favor. Ahí está. Bien. Acá entonces hay un Able Solicitation. ¿Quién tiene... no, es un ping a la 2001. No, no es ese. ¿Alguien que me haga un ping? ¿Alguien hizo un ping? Yo no tengo IPv6. No, pero si tenés, si tenés en la F80. Ahí estoy haciendo. Recuerden, para hacer ese ping es por ciento en 3, ¿no? ¿Por ciento en 3? Sí. ¿Por ciento en 3? Sí. ¿Por ciento en 3? Sí. Recuerden, para hacer ese ping es por ciento en 3, ¿no? Sí. Ahí lo tienen. Gracias. Fíjense acá, esta F80, porque alguien hizo, alguien acaba de hacer un ping a la F80, a esta, a la D804 por ciento en 3. ¿Sí? Entonces, preguntando, en realidad debe ser yo respondiendo por lo que veo. Bueno, en definitiva la pregunta es ¿Quién tiene esta? La F80 y esta respondió. Uno preguntó por Network Solicitation, que se vendría a ser el equivalente al AppRequest. Y el Network Advertisement, que es el equivalente al AppReply. De V4. ¿Por qué promociona? ¿Por qué dice promociona? ¿Promociona? Como Advertisement. Advertisement, sí es. No, Advertisement. Raro. Quizás sea una cuestión de inglés nativo, que nosotros obviamente no tenemos que es. Advertisement es hacer conocer, en realidad. Esa sería la traducción en este contexto. Darme a conocer. Me doy a conocer. Ahí hay algo interesante que... Hay otros Advertisement que podemos ver ahí, ¿no? Ya que estamos. Pienso que hay otros que es Router Advertisement. Lo envía alguien, que vendrá a ser un router, ¿a qué dirección lo envía? ¿Qué dirección era esta, recuerdan? Estuvimos jugando con esta. El multicast de los nodos. Multicast de todos los nodos, perfecto. Si le agregue "peonet" es "host", es "all nodes". Le está diciendo a todos los nodes. El router se está dando a conocer. A ver si podemos ver un poquitito más el... Bien. Déjenme ver. "Lifetime", "hop limit" 64, "maximum" "unary node" Ufa, pero no veo lo que me interesa. "prefijo", ¿por qué no está? Ah, es que otro... Voy a dejarlo correr un poco, a ver si caso. ¿Atrás de qué estoy? ¿Qué es lo que... atrás de qué estoy? ¿De dónde se les ocurre a ustedes que habrá salido mi reacción IP pública esta? Les pre-respondo, no es en DHCP. Es decir, acá esto no se negoció cuando negoció, como hacía él cuando se hizo la IP de 4, cuando arrancaba la máquina, sino que se usó algún mecanismo como esto. Entonces, ¿qué es lo que habrá ocurrido ahí? ¿Qué les parece? Voy a hacerlo más largo esto. Ahí está, sí, me faltaba la longitud nada más. Miren, estoy dampeando ahí y le voy a poner que me dampee, nomás para que sea más rápido. Le voy a pedir que me dampee un paquete nada más. Le dice "mp6" y lo voy a comparar con esto. Y quiero que ustedes me encuentren alguna similitud en lo que leen arriba con lo que leen abajo. ¿Qué es lo que está gritando el router? ¿Por qué digo gritando el router? Porque este es un router advertisement. El router se está diciendo "acá estoy" y compañeros de red tengan la gentileza de recibir esta info. ¿Qué ven ahí de composición o de similitud entre este router advertisement con las direcciones IP que tengo abajo? IP6, obviamente. La red. Ajá, el prefijo, fíjense que piola, ¿no? ¿Y cómo hago yo para completar mi dirección IP6? Si yo hago "ip leader en 3" ¿Cómo construyo todo esto? Fíjense, fíjense qué está ocurriendo. Yo como nodo, sin tener nada, sencillamente por escuchar ahí como vecino, levanto el advertisement del router y digo "eh, buenísimo, acá hay alguien que me está publicando el prefijo este/64" y lo tomo para construir la primera parte de la dirección, este/64 que está acá. La mitad de la dirección IPv6. ¿Y la otra mitad con qué la completo? ¿Cómo la completo yo esto? Con la Mac. Con la Mac, exacto. Y fíjense, esto es fascinante, acá tengo determinístico, determinístico, ya tengo dirección IPv6, sencillamente porque hay un router que está haciendo advertisement, está diciendo "muchachos, compañeros de red, pueden usar este prefijo/64" fíjense que es un prefijo, obviamente, de público, porque empieza con 2. Y no hace falta ninguna otra coordinación porque todos saben, las RFC dicen, que para poner la dirección de host, entonces directamente ponele la dirección de host derivada de tu Mac. Y listo, ya tenés IPv6 pública. Sin más protocolo. Fíjense que además, ¿qué otro tipo de datos hay de interesante acá? Que es como que el router le preconfigura a estos vecinos, le dice a la vecindad "muchachos, acá hay un prefijo que pueden usar, es 2001.470.dba.9/64" Y además que otras cosas. El hop limit. Hop limit, ¿se recuerdan cuando hablábamos del default de 64 para el TTL? Ahí lo tienen. Bien, podría este router decir otro, autoconfigurar a todos los nodos de esta vecindad en otro hop limit. 64, que es el default que como les contaba ya habíamos visto. ¿Qué validez tiene este advertisement? Ahí lo dice, 86.400 segundos, que esto se me han recuerdo es un día. Si, es 3.600 por 24, creo que es. Creo, pero puede estar mal. Es el value time, el prefix time, el tiempo de validez del prefijo. M2Option. Fíjense otra cosa interesante, el router mismo me está diciendo "che, muchachos" Oh, fuck. No solo eso, sino que por si no lo tienen bien configurado, configuren su M2Option 1458, porque eso es lo que yo sé como router que deberían usar cuando usen datagramas con este prefijo. Y de paso, ¿hay algún otro dato ahí importante? ¿Dónde está esto? ¿Lo ven ahí escrito en algún lado? En el default, la ruta por default. Ahí está. Entonces ahí tienen la MAC, aprendieron la MAC, fíjense que de hecho acá está completo, ¿no? Fíjense que es interesante porque es como que el default router, acá empezamos a ver dos entradas, pero el default router es suficiente con decir que el default router es a través de la dirección de enlaces con la cual yo tengo relación con este router, de la cual soy vecino. Que es eso igual a eso. Bien, esto era como un pequeño picoteo de cuál es el rol de ICMP6 en el stack cuando hacemos IPv6. Y básicamente no hay otro protocolo de ayuda, está todo en ICMP. Como que directamente, ¿para qué crear más protocolos? Todos los protocolos adicionales que necesite IPv6 para funcionar están en ICMP. Acá esto es para contarles cómo es que tenemos IPv6 acá en la cloud. En realidad, como les contaba, no tenemos nuestro router de internet, que es este que está aquí, con esta dirección IP pública. Acá no tenemos nosotros en realidad un proveedor de IPv6, tenemos solamente IPv4. Pero hay, y no muchos, creo que queda un manojo o uno o dos, proveedores de IPv6 que te permiten construir un túnel y a través de ese túnel te delegan un prefijo de IPv6. El que está nosotros, usamos nosotros, se llama he.net, que en realidad también, que es por Hurricane Electric. Cualquiera se puede crear una cuenta acá y ustedes podrían configurar IPv6 incluso sin tener, no a nivel de router, sino a nivel de nodo, con lo cual tener ustedes una IPv6 pública, creándose una cuenta en este proveedor, es tunnelbroker.net. Fíjense, acá estoy dentro de la cuenta que creó Diego, y acá hay algunos datos interesantes, fíjense, un tunnel ID, que obviamente es un muy identificador de túnel, fíjense la cantidad de túneles que estos flacos tienen creados. Estos son los tunnel endpoints, en IPv4, estos son ellos, y estos somos nosotros, es lo que veía recién en el dibujito, la 251.41.176, la dirección pública de nuestro router hacia la internet. Y esta es la dirección IPv6 del lado server y del lado cliente. Entonces, es como que... Y acá me voy a permitir una disgresión. Siempre que ustedes vean tuneleo, hay básicamente una blasfemia al esquema de capas de protocolo, porque cuando hay tunneling, ustedes vieron que nosotros tenemos capa de enlace, capa de red, o si quieren, capa 2, capa 3, 4, 5, etc. Cuando hay tunneling, en realidad estoy haciendo, por ejemplo, capa 3 sobre capa 3. Este túnel de IPv6 que cruza toda la internet, es como si su capa de enlace fuera la internet misma, la IPv4. Es un túnel IPv6 sobre IPv4. Entonces, para IPv6, lo que tiene abajo, como IPv4, al estar tuneleado, es el equivalente a que fuera max. Pero en sí mismo es todo una capa de red. Por eso es que le digo que cuando hay tunneling, hay violación de esto de que la 3 va sobre una 2, que va sobre una capa física. Bueno, cuando hay tunneling, es o 3 sobre 3, IPv6 sobre IPv4, o incluso hay tunneling sobre TCP, o incluso mucho, mucho, mucho más arriba. Lo de OpenVPN, por ejemplo, es sobre UDP. Así que eso en realidad es una capa 3 sobre una capa 7. Bien, bien, bien ahí arriba. Y eso es tuneleo. Siempre que ustedes se enfrenten con un túnel, van a ver esta cosa. Es como que hay toda una capa, típicamente de capa 3 hacia arriba, montada sobre al menos otra capa 3 hacia abajo. Entonces, lo que ocurre efectivamente es que HURICAN Electric nos ha delegado una barra 48. ¿Qué onda una barra 48? ¿Cuántas redes nos permite crear? ¿Cuántas barras 64 podemos crear con una barra 48? ¿Es generoso, no es generoso? ¿Qué les parece? Estamos asumiendo que barra 64 es el default. ¿Cómo llegaste a esa cuenta? 64 menos 48. ¿Eso 16 qué? ¿16 en decimal o en bits? En bits. 16 bits que podemos multiplicar. Entonces, la 16 sería la cantidad de redes. 65 mil y pico de redes. Fíjense las posibilidades que nos está dando el direccionalmente IPv6. Por haber creado este túnel, en realidad, por default, y acá es una cuestión meramente de operación de este servicio, por default te dan un barra 64 nada más, que es este que está acá. Es decir, te dicen, bueno, sí, ok, yo te conecto a estas dos puntas, te doy para cada punta de la conexión esta dirección, es decir, que este router que está tuneleando en IPv4 para cruzar todo el IPv4, recuerden, pongámonos por un momento el casco IPv6, y pensemos que yo con casco IPv6, todo lo que está abajo es enlace, y permítanme la blasfemia, ¿no? Quiere decir que si yo tengo una punta IPv6 y otra punta IPv6, abajo yo tengo enlace, quiere decir que es como si toda la Internet, la IPv4 fuera mi capa de enlace, en donde las MACs son las direcciones IP públicas, mías y tuyas. ¿Sí? ¿Vale la analogía? ¿Se entiende? Yo con lentes de IPv6 de capa de red, yo veo hacia abajo, y las direcciones que yo identifico abajo son las MAC de mi capa de enlace. Pero como esto es un túnel, mi capa de enlace es toda la Internet, y las MAC son las IP públicas. Entonces yo encapsulo de origen a destino, cuando tengo que cruzar con este túnel, uso como direcciones más abajo de mi capa 6, de mis direcciones IP6, las encapsulo dentro de direcciones IP4. Para mí es como si fuera mi capa de enlace, que obviamente es en sí misma una capa de red. Y de esa manera logro que atraviesen toda la Internet, igual, entre comillas, que yo logro que una trama de Internet pase a través de un switch y llegue a otro, ¿no? A través de la identificación de estos nodos. En este caso estoy usando como identificación la propia IPv4, para montarle arriba un pedazo de IPv6. Entonces, volviendo. Por default te dan una barra 64, pero si lo pedí específicamente, tenés que hacer alguna trucuñela más, te delegan un barra 48. Y al delegarte un barra 48, te permiten que a través de este túnel, todo el resto de la IPv6, de una manera parecida, ¿recuerdan cuando ayer en una clase pasada que el resto de la IP sabe que vos tenés este prefijo? Por eso es que el ruteo viene hacia acá. En realidad todo HEE tiene un prefijo específico, barra 32. Fíjense, todo HEE es 2001.4.70/32. ¿Está bien esta dirección? ¿Por qué es barra 32? ¿Qué significa barra 32? No confundíse con barra 32 IPv4, esa era IPv4. Estamos ahora con ya cabeza IPv6. ¿Qué es barra 32 en IPv6? ¿Cuántos pedazos entre dos puntos son un barra 32 en IPv6? Es un cuarto del IPv6. Bien, pero recordemos que cada pedacito entre dos puntos eran 16 bits. Sí, el doble de IP, los pedazos entre dos puntos. ¿Quiere decir que un barra 32 son dos pedazos? Quiere decir que esto está bien, ¿no? El prefijo este 2001.4.70/32 es todo este proveedor. HEE, Curry Connected tiene un barra 32. Y después a su vez lo rompen pedacitos para ir prestándolos a quienes usan su servicio. Fíjense que nosotros nos ha delegado dentro de ese prefijo, dentro de ese gran prefijo 4.70/32, ha tomado 16 bits de ahí para identificar a nuestra red y nos ha delegado todos los 48 que restan. Entonces nuestro prefijo del cual tenemos pleno uso es 2001.4.70/9/48, del cual nosotros hemos usado la primera red de ahí, que es la 2001.4.70/dba9/0, lo hemos usado para publicarla dentro de nuestra subred donde tenemos nuestras maquinitas en la cloud. Pero es nada más que la primera barra 64 de estas. ¿Sí? Ahí la dirección dba9/0 todo. ¿No se puede asignar a ningún, a nada? Sí podría, Andarío. Lo podrías asignar al round. Es más fácil ponerlo en max. Cuando hablas con dispositivos, es más fácil ponerlo en max por todo el mecanismo que ya mencionamos. Y es conceptualmente más fácil, hay tantos bits. Son 64 bits. Dejemos el 0 dedicado a la identificación de red y pongámosle bits reales que me permiten mapear directamente la MAC de una manera mucho más simple. Claro, pero el default ahí no es una MAC. Es un 1. Perdón. Ahí es donde es. Ah, disculpame. Sí, correcto. ¿Por qué? Porque esta es la dirección del router. Perdón, te entendí mal la pregunta. Es muy correcto. Nosotros acá a mano, ya sabiendo que esta 2.1 no va a estar usada, porque ahí siempre se pone la MAC directamente, para no averiguar cuál es la MAC del router, a mano le hemos puesto el router, la pata del router en el enlace, le dijimos, le prendemos el 1. Le prendemos el bit. De una manera muy parecida, como antes decíamos, la .254, la .1 de la red, siempre se le dedicamos al router. Acá nosotros, pero por una cuestión de convención, también podríamos haber elegido la última, que sería... F, F, F. Después del 9, muchos F. 5. Ah, casi. Barra 64. Son 4 pedazos. Es decir, si nosotros, esta sería la primera de las redes, esta. Pero si hubiéramos elegido usar la última, por cierto, esta es equivalente, completémosla, así la vemos bien. Es equivalente a esta, ¿cierto? Donde esta es parte de red, hemos elegido la primera red, esta sería la segunda red, esta sería la tercera red, esta es la primera red del barra 48 que nos delegaron, que está ahí a la derecha en la pantalla. Sí, que acá dijimos que tenemos plena disposición de esto. Un barra 48 es 16 por 3. Quiere decir que nosotros, yo voy a highlightear, de lo cual nosotros somos dueños de esto. Y H, el proveedor nos dice, "hacé lo que quieras con el resto o distribuirlas como quieras". Yo te aseguro que te voy a routear todo lo que termine con W9, cualquier cosa que es el barra 48. OK, buenísimo. Me quedan 16 bits, que es todo un componente. Voy a hacer que la primera red es la que vamos a poner a clave. O bien podríamos haber elegido acá que sea la, no sé, la que tiene 23, elegimos fuera la primera. Quiere decir que ahí ya tenemos eso. Dentro de esa primera red dijimos, tenemos 64 bits que restan, le identificamos al router como la primera IP de ahí. Entonces ahora viene la pregunta, ¿cómo sería la identificación si hiciéramos lo opuesto, lo equivalente al .254 de IP4? ¿Cómo sería acá entonces? Recién lo respondían pero se te fueron demasiadas F. Eso sería así. Más feo, ¿no? Y además hay que tipearlo mucho más, porque se me embole. Sí, mal habido. Una cosa así. Fíjense, pero sencillamente por una cuestión humana de simplificación de notación es mucho más fácil decir "ah, el router es este, chau". Todo cero, ¡pim! El último bit en uno. O bien podría ser acá el último bit en, no sé, podría haber elegido dos, podría haber elegido, no sé, cualquier cosa, podría haber elegido "baby". ¿Sí? O "café". A ver si me despertan un poco. "Café", ¿sí? Son todos, este... O, no sé, "cacar". ¿Sí? Estoy poniendo "exo", no estoy jugando con eso nada más sencillamente porque sé que... Pero bueno, más fácil ponerle uno. Bien. Se entiende más o menos hasta acá, por donde vamos. Acá nos han delegado, nosotros hemos tomado, entonces hemos usado para la primera red, yo bien podría ponerlo así para que quede un poquitito más explícito. Los primeros 64 bits del prefijo delegado y ese último bit para el router. Pero en definitiva, la identificación de red, como bien la ven acá, es la dba9/64 que identifica esta red pública, porque ahora sí, todas las instancias que tenemos en la cloud tienen una IPv6 pública. ¿Sí? Estamos adverticiando, estamos publicando dentro de la red, los nuevos están levantando ese prefijo y le agregan el post fijo, la parte de host, construyéndolo a partir de su propio Mac. Eso es fabuloso, ¿no? Fabuloso. Entonces, si les interesan, a todos aquellos que no tenemos IPv6, crearse una cuenta en HE y jugar con esto está bueno. Fíjense que acá le ponen configuraciones de ejemplo de acuerdo al sistema operativo que tengan. En caso de Linux, esto recuerden, nosotros es porque le hemos hecho rosca a nuestro router para que automáticamente publique esto. Pero si ustedes están configurando su máquina final, quien proyectaba, bueno, recién quien proyectaba ya tiene IPv6 natural. Para aquellos que no tengan, este sería el pedazo de configuración que tendrían que agregar en el archivo este, netplanendingblah.yaml. Es decir, tendrían que editarlo y agregar esto. Es decir que yo me voy a mi máquina Linux, esto no lo tengo configurado, pero yo solamente les voy a mostrar qué es lo que ustedes tendrían que hacer en caso de que tengan Linux. Acá también le dicen en caso de Windows. Fíjense que es interesante porque les ponen los comandos. Por ejemplo, Linux Route 2, si ustedes copian y pegan... Me parece que me debo haber deslogueado de acá. Exacto. Voy a loguearlo. Un segundito. Fíjense que hay un interesante acá. Sin tener que configurar nada en un archivo, si ustedes agarran y pegan esto así, se registra en un HEE. Pegan eso y ya tienen IPv6 con eso. Si lo quieren permanentizar, perdón por el mal uso de nuestro idioma, en el caso de las máquinas Linux reciente, hay un NTC NetPlan, es donde se configuran las máquinas. Fíjense. Se lo voy a mostrar a modo de ejemplo nada más. NetPlan. Entonces ahí ustedes deberían crear un, no sé, HEE, IPv6, no importa el nombre, .yaml. O mejor, directamente. .yaml Y le meto el contenido. Esto ya se hacía brúticamente, copiando y pegando. Si yo después hago un NetPlan Apply, IPv6, me va a levantar ese archivo, me va a configurar, y fíjense que me ha configurado acá cuál es el local, cuál es el lado remoto, y cuáles son los adreces que yo voy a tener acá adentro. Y en particular, yo voy a hacer esta pata /64. Es decir, me estoy asignando a esta IP pública, porque HEE ya sabe cómo rutear de regreso a mí a través de este túnel. ¿Sí? Y así yo voy a remover ese archivo, para que no me haga ruido. Pero así es como ustedes se podrían autotunelear IPv6 usando este proveedor de tuneling de IPv6. Antes había mucho más, este es uno de los pocos que ha quedado. Y en todo caso, directamente, ya es medio tarde, así que la clase que viene arrancamos, vemos un poquito de XMP, vamos a ver que se parece mucho a 6, perdón, a 4, nada más que aparecen algunas cositas propias de IPv6, pero conceptualmente es muy muy parecido. ¿Y qué nos queda? Ah, y ver un poquitito más, con un poquitito más detalle esto de los adreces de la interfaz, esto que habíamos visto en la Mac, pero habíamos visto que no era exactamente igual, entonces, estudiar un poquitito ahí más cómo se configura la parte de host. Y ver un poquitito también de tuneling. Pero eso lo completamos en la clase que viene. Así que, lo que les sugiero entonces, sí, que esté interesante, créense una cuenta en HEE y experimenten ustedes, tengan IPv6, y como milestone sería espectacular que ustedes se pudieran loggear a sus instancias de la cloud a través de IPv6. Para la mayoría de nosotros que no tenemos IPv6 natural en nuestra red hogareña, a través de HEE. Que es Tunnel Broker. Se los copio en el stack. Y creo que por hoy estamos. ¿Alguna duda, muchachos? Lo que seguramente tienen muchas, pero alguna específica de lo que acabamos de hablar. Yo tengo una de, no de esto, pero de la clase pasada, el profe, el Diego, nos dijo que viéramos el video de "Un día en la vida de un ingeniero" de Netflix, pero no lo pasó nunca, el video. Y estaba viendo cinco capítulos de como una hora, no sé cuál, o todos, o... ¿Ah, sí? Sí, no me acordaba que fueran tantos. Hay dos cosas. Yo he visto, hay un flaco en YouTube que ha hecho una vía, "Un día en la vida de..."Bueno, bien, como veíamos recién, hemos hecho un... en realidad un ejercicio para ponernos del lado de la ingeniería, del desarrollo y del diseño de estas cosas. Hemos hecho nuestro algoritmo que verifica, al menos que estos que son hosts, podrían tomar la decisión de encaminar su datagrama a través de alguien que los lleve hacia el destino. La pregunta que nos deberíamos hacer es, ¿este algoritmo funcionará si yo lo evalúo como si fuera este router que está acá? Está claro que este algoritmo que hemos hecho nosotros acá, con este nivel de abstracción, funciona para este host. Porque este host lo único que tiene que decidir es si habla con un vecino y si no, ¿qué hace siempre? Este algoritmo que está acá busca si es vecino y si no, ¿qué hace? - Se lo da al gateway. - Se lo da al gateway. Ahora, una de las cosas en las que nos vamos a adentrar, y en realidad es un poco la que hemos estado hablando antes, el routeo es un problema de salto a salto. Este salto que es el host, él pudo tomar su decisión de routeo y dijo "bueno, mirá, todo bien muchachos, te lo doy, yo quiero hablar con él". 120, este algoritmo lo pasa por acá, así tenga cinco interfaces, ¿todo bien? ¿A quién le va a llegar el datagrama en este dibujo? Si yo uso los datos que he dibujado acá, he puesto "che, quiero hablar con, mandarle un datagrama al 120". Así tenga todas estas interfaces que tengo, uso este algoritmo, ¿a quién le cae el datagrama? - Al gateway. - Por eso, pero en este dibujo que tenemos acá, ¿a quién le cae el datagrama? - Al 201. - Al 201. La pregunta es, ¿el 201? ¿Puedo usar este algoritmo? Está medio raro porque debería tener un gateway. La pregunta es, ¿el router ese, siempre tiene que decidir si habla con el 100? ¿Puede decidir tener un solo gateway? No. Lo que pasa es que el router, tiene que decidir, o sea, si por ejemplo, estuviera conectado a otro, en vez de en el dibujo a uno solo, estuviera conectado a otro más, tiene que decidir a cuál mandárselo. Claro que sí. La pregunta es, ¿sirve esto que hemos hecho acá, sirve para ese router? - ¿O no? - No. - Profe. - Sí. Una pregunta, por ejemplo ahí, la máquina que tiene la IP 172, ¿podría llegar a la 120? Como lo hemos planteado acá, no. ¿Por qué? Porque, es buena la pregunta, salvo que esta máquina se volviera un router, pero no es un router, es un host. Es decir que como está dado esto, por eso le acabo, este dibujito que me salió feo, cuando uno usa un símbolo, ¿vieron cuando vimos Mininet? Los routers se dibujan con una caja cuadrada y un simbolito de intercambio, ahora sí. Como este no es un router, si a mí me presentan este diagrama, yo digo, no, mirá, esta máquina solo va a poder hablar en esta red con esta máquina. Porque esta no es un router, no reencamina el datagrama, decide por dónde mandarlo, pero él no es un router. Es decir, no reenvía paquetes. Los que reenvían son estos. Ahora... Sí, perdón, no. Yo quería preguntar, si la máquina 170 es 16, 16.1, ¿manda un paquete que no es para la máquina a la que está conectada? ¿Ese paquete se pierde? Probablemente, probablemente, si yo tengo esta red así, tanto esta máquina como esta máquina no tienen gateway. Porque yo no quiero que salgan de la red. No tienen a quién mandarle la fosa. Claro, solo se pueden comunicar a la máquina esta, digamos, la de médico. ¿Qué es un escenario válido? Ustedes pueden tener una red y decir, mirá, yo no quiero que nadie hable con nadie. Bueno, no se rutea lo que no se quiere contactar. Es la primera regla de seguridad en redes. ¿Para qué le voy a dar gateway si no quiero que salga de la red? Por ejemplo. Igual, en este escenario, que fue solo una manera de irle construyendo complejidad al problema que queremos resolver, tampoco se enrosquen. No es muy común ver una red así, digamos, y no tiene mucho sentido hoy por hoy. Menos pensar redes que no van a tener internet, pero... El problema en el que los quiero de alguna forma inducir o invitar a pensar es A ver si esto deja seleccionar varias cosas. No, no deja seleccionar. No se puede seleccionar. No. Es que... Pensemos en este router. Imagínense que ustedes son... La red es esta que está dibujada acá, ¿no? Y si ustedes son el router, el primer router de arriba, este que está acá, ¿sí? Y efectivamente deberían encaminar el datagrama. ¿Qué deberían hacer con un datagrama que va destinado a las 120? ¿A quién se lo deberían dar? Si quisieran que esto funcione, digamos. Yo quiero que ande. ¿A quién le deberían dar el datagrama? Al siguiente router. A este router. ¿Está bien? ¿Sí? ¿Se ve eso? Sí. Ahora... ¿Eso... ¿Qué manera tiene este router de enterarse de eso? Debería preguntárselo si pertenece a la otra red. Guardar en una tabla. ¿Cómo? ¿Preguntárselo o guardar en una tabla? Porque si nos basamos en esta lógica que está acá, ¿qué miraría él? ¿Qué puede decidir esta lógica que hemos hecho hasta acá? Y decide en base al prefijo, así que... Por eso. Si está en su red o no. Claro, es decir, decide en base al prefijo y si son vecinos a los que está conectado, digamos. Si no, se lo manda a un gateway. Ahora, el escenario que tenemos acá es... De alguna forma este algoritmo está defectuoso porque... Si esto es el mismo IP que tienen que usar todos, la misma lógica IP, me está faltando la manera o algo. Alguien dijo ahí, bueno, este router debería averiguar, por ejemplo, que este host... Está atrás de este router. ¿Sí? Podría preguntar si alguien conoce a 120. Bueno, esa sería una manera, pero está claro que le está faltando información, ¿no? Sí. No tiene manera de saber que... Porque si él supiera, por ejemplo, le llega el paquete y dice "che, yo alguien me dice que para ir a Villa Merced tengo que pasar por San Luis, ah, listo, voy por San Luis, pero me lo tiene que decir alguien". Tampoco, y acá aparecen algunas cosas que vamos a ver más adelante, tampoco está bueno que yo le pregunte a otro porque, no sé, capaz que el destino al que voy está... 100 saltos más allá. Además, imagínense la escalabilidad de eso, ¿no? Imagínense si por cada paquetito que yo desconozco el destino, empiezo a preguntar, voy a hacer un flujo en el cual el esfuerzo que tiene hacer la red va a ser mayor en preguntas que en el paquete en sí, entonces básicamente esto podría, además sería muy fácilmente atacable y colapsaría. Sí, exacto, pero la red... Es haciendo el equivalente de las bifurcaciones, los cartelitos de las bifurcaciones, es como que acá tiene que haber un precerebro grande, la dirección nacional de VLAD, que va y tiene un mapa, dejemos los GPS de lado, ¿no? No tenemos GPS, vamos a ver en modo hippie, de los 70, que va y en cada bifurcación ya tiene todo dibujadito, ya tiene un mapa el cual ve y dice "ah, bueno, ese cerebro dice en esta bifurcación, para ir a San Luis Vas por acá, para ir a Córdoba Vas por acá y ponemos ahí". Y así hacerlo con cada bifurcación, es como que tal que quien tiene que decidir cuál camino seguir cuando encuentre una bifurcación, ya está como grabado, ya está como memorizado eso y no tengo que preguntarlo en el momento y no tengo que contactarme con otras bifurcaciones para preguntarles "che, bifurcación vos conocés" y que a su vez tenga que preguntarle hacia atrás, porque eso nuevamente tendría un problema de escalabilidad sumamente grande. Entonces es como que hay otra capa de más arriba que ya ha instalado estas reglas de ruteo, de bifurcación, las ha pre-instalado. Bien, tratemos… Perdón, tengo una pregunta un poco tonta. ¿Los switches tienen algo que ver con lo que acaba de explicar el profe? Porque lo había leído, o si mal no recuerdo, los switches tenían como una memoria que mapeaban direcciones y las hacían como un look up. ¿Tiene algo que ver con el tema que están hablando o no? Hay un encaminamiento, pero es un encaminamiento de tramas en capa 2. Es como que los switches recuerdan de decir "ah, yo vi esta MAC acá" entonces para no hacer un flooding en todos los puertos, yo ya sé que esa MAC está ahí, cuando alguien me ponga en capa 2, yo switch no saber IP, yo solamente manejar MACs, me pone esa MAC destino, yo lo vi atrás de esa puerta, entonces lo mando por ese puerto. Y no molesto al resto de los puertos. Pero esto es bien capa de enlace, lo que estamos hablando con los switches. Esto es un problema en capa de red. Tiene una ligera analogía, pero es fundamentalmente distinto a la manera de resolverlo. Bien, bien. Perfecto. Estoy tratando de ver si me deja… no me deja… no puedes copiar esto. No puedo copiar. ¿En serio? Ah, para trasladarlo a la próxima página. Ah, duplicar. Bastante arcano, ¿no? Duplicar esto… ah, duplicás. Esto nada más. Qué raro. Con la flechita lo seleccionás y le das control + C, a ver si me voy a la próxima página. Pero te deja sumar más de uno. Ahí va, ahí te lo copié en la segunda página, que me parece que era lo que querías, ¿o no? No, el dibujo, quiero copiar el dibujo, pero tendrías que ir uno por uno. Ah, para, para. Y generalmente con shift… Ah, mirá, uh, no, perdón, con control, control. Uy, qué bárbaro que no te deja seleccionar región, a ver, para… Wow, tenés razón, Chen, qué bosta. Acá vamos a tener que usar a un amigo tuyo. ¿Cuál? ¿Cuál? El… este, bueno, por lo menos este amigo nuestro. ¿De qué me estás hablando este buen hombre? Este buen amigo, a ver si nos va a dejar… Es bastante bestiuzín la manera, es bastante con el martillazo, pero… A ver si pega, uh, buenísimo. Uno es vectorizado y el otro es pixelado, pero bueno. Bueno, arrancamos con el… Se ve la pantalla, ¿no? ¿Sí? Sí. Sí, perfecto, perfecto. La generalización o la razón del problema sería nuestra versión de algoritmo funcionó ok para esto, pero estaríamos teniendo un problema al momento de poder evaluar qué hacer acá. Y como bien decía Juanjo, está claro que… Es decir, la pregunta es, tenemos un problema de… Si supiéramos… Al momento de evaluar el destino contra la información correcta, en definitiva, una vez que yo a este router lo doto de la información necesaria para decidir, después, ¿qué caminos tiene para optar a nivel de capa 2? Este router, que está acá. Este. ¿Sí? Imagínense que de alguna forma le podemos describir y decir "che, no, mirá, la red 100 está para este lado, y la red 1 está para allá, la red 172 está para allá". Una vez que lograra averiguar eso, después, ¿qué decisión tiene que hacer al escribir los paquetes? ¿Cuántas opciones tiene? Y tiene que colocar la MAC del siguiente salto. Por eso, pero según el dibujo que tenemos, ¿cuántas opciones tiene siempre? Más allá de toda la red que haya. Dos. ¿O va para allá, o va para allá? Es decir que, al momento de terminar encaminando, ¿de qué depende? Pero ¿qué sentido tiene pegarla a vuelta? ¿Sería una sola opción? No, porque si este router recibe un paquete de la 120 a la 198, 108, 1, 10. El routeo es un problema bidireccional. Una cosa es mandar un paquete así, pero este le va a responder y va a ver qué mandar este así. Sí, pero la 1, 10 no estaría conectada con el router. Pero está acá. O te lo digo al revés. Yo puedo recibir un paquete que va a la 120, va así. Y si este le responde a la 220, va así. Entonces también necesita tener la información para decir "ah, no, la red 200 está para allá y la red 100 está para allá". Ya, claro, sí, sí. Por eso, entonces, no entendí. Perdón. Pero si, digamos, tengo dos links y por uno me vino el mensaje, no tendría sentido volver a mandarlo por el mismo. Eso es lo que quería decir. No, está bien, pero vos estás pensando solo en una red que solamente encamina en este destino no sirve. Vos, a respuesta de ese paquete, vas a recibir uno al revés. Claro, sí, sí. Vas a tener que saber que estás conectado a esta red. La pregunta es, ¿en base a qué creen que dependen las cantidades de opciones en capa 2? ¿De qué es dependiente? De los enlaces que haya. De los enlaces que haya. Es decir, cuantos más bifurcaciones haya acá, van a poder ser las opciones en capa 2 que yo tenga después para el próximo salto. Sí. Y la decisión de capa 2, ¿qué va a terminar siendo parecida a este algoritmo? Cuando sepa por qué lado tengo que irme, ¿qué hago después? Buscar el vecino. Busco la Mac. Entonces, pensemos dos minutos a ver que a esto, como bien decía Juanjo, ¿qué es lo que le está faltando para que nosotros podamos hacer que el algoritmo tome la decisión? Si yo soy este router ahora, imagínense por un momento que soy este router, el que tiene la IP 201 y 10.10.1. Y necesitas saber para dónde está la red del host con el que quieras comunicarme. Sí. Sí. Eh... Necesitas saber... Ok, pero ¿qué es lo primero que yo tengo apenas me prenden? Naturalmente, este router, ¿qué tiene apenas lo prenden? Como información de IP. ¿Qué me dijeron recién? Yo a este router lo prendo y él, ¿qué sí sabe perfectamente de él? O ¿qué le debería poner como mínimo? La Mac está en el hardware, pero en esta red, si yo lo he configurado así, ¿qué tiene sobre cada enlace? Sabe a qué red pertenece. Por eso, esto tiene una configuración que dice, mira, yo tengo la ETH 0, que tengo la ETH 192, ETH 108, ETH 201, ¿sí? /24, tengo la ETH 1, que tengo la 10.10.10.1/24. Yo, suponiendo que una es ETH 0 y otra ETH 1, ¿a estas dos redes qué característica natural tengo? ¿Son redes que están lejos de mí? ¿Yo estoy ahí? ¿Estoy conectado o no estoy conectado a esas redes? ¿Cómo sería? ¿Sabe qué pertenece a esas redes? Claro, es decir, yo tengo un enlace a estas redes, yo estoy conectado directamente a estas redes, ¿está bien? Tengo un link, son mi interfase, como dijeron ustedes. ¿Está bien? Sí. ¿Puedo decirles algo? Si yo les pregunto, ok, este es el router, y nosotros tenemos que hacer que esto, de alguna manera, tenga la capacidad de que yo le describa información de ruteo, necesito en algún lugar, como alguien dijo, como decía Juanjo, escribir esos cartelitos con información que es local a cada router en algún lugar. ¿Esa información, a los efectos de este algoritmo, es algo que va a averiguar o debería ser configuración previa? ¿Cómo, profe? Vamos de nuevo, les pido que prendan la neurona porque los veo medio lentos. Les decía, para que esto pueda tomar la decisión de rutear, nosotros hemos llegado a la conclusión que acá falta la capacidad de poder decirle a cada router por ejemplo, la red destino, que sería la 100, está por este router que está acá, por el router 110, por acá. La pregunta es, ¿eso, si yo tengo que implementarlo en un algoritmo, es dato, es configuración, es algo que ya debería estar precargado, algo que va a averiguar en ese momento? ¿Se averigua? No, tiene que estar configurado. ¿Cómo averiguamos? ¿Cómo averiguaría si, por ejemplo, Eso es configuración previa. Por eso, configuración previa. Y la pregunta es, si yo tengo que, es configuración previa, no hay forma que lo averigue en ese momento, porque lo que acaba de explicar Juanjo recién no escalaría, si cada paquete que me llega, tengo que averiguar dónde está, los routers se vuelan. Es como si yo llegara acá a bifurcación y le tuviera que pedir en ese momento a un tipo de realidad que venga y me escribe el cartel. O ya están hechos los carteles. Están hechos los carteles. Entonces, yo tengo que ponerle a cada router, recuerden que estoy parado, estoy acá. Y esto es súper importante, estoy parado en este router de acá, pensando el problema de este router. ¿Sí? Este router. ¿Qué le tendría que describir? Es decir, yo le tengo que poder describir un destino. Lo que nos está faltando es la posibilidad de describir la información de ruteo en definitiva, de que este destino está a través de las opciones que tengo en este caso. Entonces, eso construye una información de ruteo que va a parar a lo que se llama una tabla de ruteo. La tabla de ruteo es configuración local a cada dispositivo que toma decisión de encaminamiento. ¿Y esa tabla de ruteo qué describe? Destinos que quiero alcanzar y quién me puede llevar a esos destinos. Esa es la información más importante que ustedes tienen que aprender. Tienen que describir el destino y quién los puede llevar a ese destino. Entonces, si yo le digo "yo estoy en ese router, ¿qué destinos puedo querer alcanzar?" Bueno, obviamente estos son dos destinos a los que estoy directamente conectado. Ahora, ¿qué otros destinos tengo? La 100.20, la 1.10. Por eso, ¿hay alguna manera de describir? Voy a tener que escribir. 192, 118, 120. Y, por ejemplo, si yo quisiera llegar a la 120, desde donde estoy parado, ¿quién me puede llevar ahí? Internet 1. Bien. Pero, en realidad, ¿a quién a nivel IP, quién me puede llevar a la 120? Está bien lo de Internet 1, yo lo dejaría ahí. Bien, me voy por la Internet 1. Esa es la decisión por la que voy a terminar saliendo. Pero, si acá en la Internet 1 yo tuviera a varios otros routers, o varios otros miembros de esta red. Pues... Ahí se encarga ese otro router de tomar después la decisión. Por eso la pregunta es... Es decir, está bien, yo puedo tener acá, sobre la Internet 1, muchos vecinos de la red 10.10.10. Ahora, ¿quién es él específicamente? ¿Todo ello o el que me puede llevar? Es decir, tengo que... ¿Quién? El 10.10.10.2. El 10.10.10.2. Es decir, que en realidad es como si para ese destino, mi gateway fuera el 10.10.10.2. ¿Sí? Sí. Ok. Ahora, si quisiera ir a la 101, tengo que volver a poner acá, 192, 108, 101. ¿Qué es? ¿Por dónde voy? Por Internet 1 también. Internet 1, y tengo que poner de nuevo, 10.10.10.2. ¿No hay alguna manera que yo pueda decir, si todos ellos van por el mismo lado, qué debería escribir yo? Decir, che, mirá, todos, de las cosas que hemos aprendido, tengo manera de decir, ah, mirá, todos estos son la misma red. Y van todos por ahí. Y no podríamos crear una dirección con un puerto físico. O sea, yo... Hay alguien que le encantan los switches, ese es David Vido. Te pido, por favor, que empecé a pensar en otra capa porque te vas a morir de hambre. Sí. Salí de la cacerola de la capa 2 porque te vas a morir de hambre. ¿Qué problema me permite describir, de qué manera me puedo describir a todos los que son miembros de la red? De las 101, 102, 120... Con la máscara. Claro. Si yo digo, che, mirá, todos los que son 100... 0/24, si quiero ponerlo. O 100/24, como les guste más. Todos van a irme a parar por ahí. ¿Está bien? Eso describe, de hecho para eso estudiamos CIDR. Hicimos todo lo que vimos antes. Para poder describir... De hecho esa es la razón del CIDR. Poder describir múltiples destinos de ruteo. Es decir, yo acá le estoy diciendo, mirá, todos los flacos de la red 100 se van para este router y se van por acá. Imaginémonos a los efectos didácticos. Ya sabemos que en la máquina... Ya que estamos en ese viaje, estaría bueno rever las dos primeras entradas, que son 0.1/24, para ya oficializarlas en 0.0. O no sé si ibas a ir sobre eso después. No, no, no, estaba... Que me digan... Si yo quisiera describir desde donde estoy parado, imagínense que por un instante vamos a transformar a Don... A ver si lo puedo hacer esto, sí. Vamos a transformar a este aparato en un router también. Así lo hacemos un poco más jugoso. Resulta que este muchacho se volvió router también. Entonces yo estoy parado en este router de acá, ¿no? ¿Qué otro destino puede ser que a mí me toque tratar de alcanzar? Y la red 192.168.1 y la 172. Bien, entonces acá va a decir la 192.168.1.0/24. ¿Por dónde se va a ir? Ethernet 0. ¿Y quién me va a llevar ahí? El 192.168.200. 201. ¿Todos ven esto que estamos viendo? Es decir, estoy escribiendo el cartelito de "che, mirá, si estoy en Mendoza y me voy a ir a la ciudad de la punta, tenés que ir por Villa Mercedes". ¿Profe, ese no sería 220? 220, perdón, sí. Es 220. Es la IP del otro lado, sí, 220, perdón. Es "¿Quién me puede llevar en IP a ese destino?" ¿Y cuál sería el otro destino que me puede llegar a caer, que quisiera alcanzar desde ahí? La 172. 172.16.16.0/24. ¿Por dónde se va a ir? Ethernet 0. ¿Y quién me puede llevar? Ese mismo, 192.168.120. Bien, ¿por qué no es el 1620? ¿Está bien lo que dice él? El 1620 sería a partir del otro router. Por eso, pero si yo pongo acá 172.16.16.20. Porque no es el vecino de intento. No es vecino mío, nunca puedo ir a un destino si no uso una IP que es vecina mía que la pueda alcanzar con alguno de los enlaces en los que estoy vecino. Entonces, esto no se puede hacer. No va a andar, porque estoy tratando de llegar a un destino que no soy vecino. 220. Entonces, si este es el mismo gateway, ¿podría poner una sola ruta acá? Como lo pasó recién. ¿O no? No, porque son dos redes distintas. Después se difurca. Bien. No. La respuesta es, son redes nada que ver. Son distintas redes. No, no comparten. Lo único que compartirían para que yo meta una sola ruta es el número uno. Entonces tendría que poner una 1/8 para describir a todos los demás. Una cosa, o no sé. Perdón, 1/8 no. Tendría que cortar la máscara en un 1/2 bit. Bien. Si yo tengo esta información, que es la del router, voy a borrar al tipito este. ¿Por qué no me lo deja borrar ahora? Con la goma. Tiene que hacerlo, me parece, profe. Ah, con la goma. Gracias. Bien. Esta es la información de ruteo en el R1. ¿Sí? Y vamos a poner acá, este es el R1. ¿Ok? Se ve eso, ¿no? La pregunta es, entonces, si ustedes lo piensan por... No sé si quería agregar algo, Juan, lo que me decías recién de los números para... No, no, no. Solamente las primeras dos entradas que dicen .1/24. Si lo estamos expresando en direcciones de red, arreglarlas a que sean .0/24. No sé si querías hacer alguna rosca más alrededor de eso. No, bueno, no quería desambiguar como era el link, pero lo podemos hacer. Son hiperígenes. Estoy haciendo la tabla de ruteo. Ok. Creo que sirve. La pregunta es, si yo me hago... Quiero terminar de describir la realidad de esto y vamos a decir que... Oh. Me voy a duplicar. ¿Cuál es la realidad de R2? ¿Es la misma tabla de ruteo o él tiene carteles distintos? Tiene carteles distintos. ¿Qué información tiene R2? A ver. Sí, tiene que... ¿Qué es lo primero que le miro a R2? ¿Qué es lo primero que le miro? Que él tiene lo que es miembro, digamos. La información de sus enlaces. ¿Qué enlaces tiene? Él es 10, 10, 10/2/24. Supongamos que esta es la... Este es 0. Tiene link ahí. ¿Qué más tiene link? Con el 92, 101. 101/24. Link. ¿Y todo lo demás que pasa en esta red? ¿Qué más le puede tocar a él tener que alcanzar? Todas las otras redes, pero van a través de la misma... Bueno, pero entonces nos tenemos que... Esto es lo que quiero mostrarle. El ruteo, la información de configuración de ruteo es siempre local. Y eso es lo que cambia salto a salto. Recuerden, los carteles en cada bifurcación son distintos. Entonces, es el mismo mapa, pero la información de ruteo local es diferente. Entonces, describamos cuáles son los destinos que puede querer alcanzar. Díganme uno. Y 172.16.16.1. 16, 16, 1. Bueno, entonces es 0. Si pongo 1/24, ¿es lo mismo que ponga 0/24? No. Y si pongo 124, ¿qué va a haber cuando yo evalúe el /24? ¿Qué le voy a mirar a esto? El prefijo de red. Claro, entonces prácticamente si usted escribe en 100.223.24, acá es lo mismo, porque usted le ha dicho "che, mirá, yo le voy a mirar solo los primeros 24 bits". Bien. ¿Está? Es decir, le estoy describiendo todos los destinos /24. ¿Quién me puede llevar a, si yo estoy en R2, a la red 16.16? El Ethernet 0. Ethernet 0. ¿Y quién es sobre el Ethernet 0 el que me puede llevar? R1. ¿Ah? R1. R1. ¿Qué IP tiene? 10.10.1/24. ¿Es un IP? También. La pregunta es, si yo voy a este, ¿cómo tiene que ser él? Tiene que ser vecino. ¿El 10.10.10.1 es vecino mío? Sí. Sí, porque lo caigo acá. Vamos a preguntarnos otro caso. ¿Quién más puedo querer alcanzar? La red 1. La red 1. Bueno. Sí. ¿Y quién me lleva ahí? El mismo camino. Ajá. ¿Y a quién más puedo querer alcanzar acá para describir a todas las redes que tengo no en el mapa? A la 200. A la 200. Fíjense cómo... Tenemos... Y ya para completar la joda ya le vamos a poner la R3 si quieren. ¿Cuál es la situación de R3? Similar, pero cambiando toda la IP. Tiene 3 links. Profe. Sí. ¿Hay alguna forma de, por ejemplo, un CPU, si le agregás varias placas de red, convertirla en router? Totalmente, claro que sí. Totalmente. Un CPU cuando no es una computadora. Claro. ¿Y a ustedes les caga alguna duda que los routers son computadoras? ¿Tienen router en su casa? Por supuesto. Sí, claro. Mirá esto. Se ve la pantalla, ¿no? Esa es la información de mi ruta por default, es esta. Uf. Uf. Ando por tanto router. Ando por tanto router. Esto es una computadora, ¿o no? Sí. Es una computadora, ¿o no? Porque mira, tiene CPU, cat, proc, CPU info. Tiene memoria RAM. Se hace es un PS, claro. Se hace un PS, tiene procesos. Está corriendo. Tiene un sistema operativo, computadora. ¿No usa swap? Ah. No. No, no, no, no tiene, no le sobra nada para usar swap. Pero lo que les quiero decir es, fíjense, Ippeli, esto tiene varias interfaces. Un poco lo que preguntaba el compañero a ustedes, y efectivamente esto es un router. De hecho es una computadora rara, es un TP-Link Archer, MediaTek. ¿Podrías entrar al router de la cloud? Ya te paso, no sé si lo tenés a mano, ahora ya te paso la IP. Es esta. Estoy adentro. Ah. Estaba mirando otra pantalla. Pero quería darle un avant-premier para que ustedes vean que sí, todos los routers son computadoras. Así que, olvidate. Tenés que tener más de una interfaz para que tenga sentido el routing, aunque sea más de una interfaz lógica. Y tenés que tener un sistema operativo que lo soporte, ¿no? Y que venga preparado para más naturalmente ser un router. Terminamos esta para terminar de hacer la generalización y a ver si encontramos una solución. El R3, ¿qué tiene distinto a los otros? ¿Qué ven usted que tenga distinto? Que tiene tres enlaces directos. Tiene tres enlaces, a ver. 192, 168. .1. .2. 1.20 le pusimos. 1.20/24. Digamos que este es su VTH0 y tiene enlaces. 192, 168, 201, 24. VTH1 link. Y después tiene 172, 16, 16, 20, 24. VTH2 link. ¿Ok? ¿Y quiénes puede querer alcanzar que no conoce? 192, 168, 120. 100. ¿Y todos los vecinos de él? /24. ¿Quién lo lleva ahí? ¿Quién lo puede llevar ahí? Terminé el 2. ¿Es el 2? No, perdón, es el 1. La 200. .0. .1. En realidad el acá es la 200, perdón, acá está mal. Es 220. Y quien lo puede llevar es la 201. Ahora, ¿hay alguna otra red que esté ahí? Fíjense, un caso particular. ¿Qué red le falta poder alcanzar? Que los otros sí lo miran. Si yo lo dejo al R3 así, ¿a quién no va a poder alcanzar nunca? A ver, a los efectos de lo que estamos hablando es... A la 10. Claro, estamos describiendo que lo que le configuremos acá es lo que va a poder alcanzar este router, o va a poder encaminar. Si no está acá, no es alcanzable por el router. Entonces, ¿quién no es descrito yo acá? La 10. 10. 10. 0. 24. ¿Que por dónde se va casualmente? Fíjense, este es un router... También es el 1. Claro. El único que lo puedo sacar de la cacerola donde vive es el 201. Ahora, a lo que quiero llegar, a ver si lo podemos coser antes de que termine el día, es... ¿Qué es lo que está pasando? ¿Qué es lo que está pasando? Claro, digamos que yo ya tengo una información bastante más enriquecida, porque el R1 tiene toda esta información, el R2 tiene toda esta, así que mi configuración es, si yo les tuviera que decir a ustedes, y creo que acá donde me parece que era lo que proponía Juan Jorge recién, ¿cómo guardaríamos esta información en una máquina? ¿Cómo la guardarían? Si la tengo que hacer en un programa, ¿esto qué serían? Una matriz. Una matriz y ¿cuántos campos tendría que tener? El campo, ¿y va acá, Juanjo recién o...? Sí, más o menos, pero va bien, va bien, va bien, en todo caso lo agregamos después si está en contexto. Y tendría la red a la que puedo llegar. Por eso, acá tengo. ¿Y el enlace que tenés que usar? Por eso, pero acá tengo IP, esto es máscara, la interfaz, ¿sí? ¿Y por dónde ir? ¿Qué es otra IP? Si está el link o no. Por eso, y este sería de alguna manera mi próximo salto, es decir, mi destino, mi... ¿Le puedo decir gateway? Es decir, si yo quiero ir a este destino, por ejemplo, a este destino, es decir, quiero ir a alguno de mis otros vecinos, directamente digo, como esto va a ser link, lo contacto, o no. Sí. Entonces, lo que les quiero decir es, esto que está acá, ¿cómo se modelaría en un lenguaje? ¿Con qué estructura lo modelan? Una lista de listas. Bueno, con una RAI bidimensional, digamos, que va a tener un entrada por cada destino que quieran machar. Y en la columna tienen los parámetros, uno es IP, el otro es máscara, el otro es interfaz, el otro es gateway. ¿Se ve? Sí. Por eso, la configuración está en una tabla, en la tabla de ruteo. Está bien. Que es esa. Entonces, imagínense por ahora que a ustedes les cae un datagrama. Como puede ser este datagrama. Este que está acá. ¿Qué pueden hacer usando toda la información que tienen ahí para resolver el problema de encaminarlo? ¿Macheo en dónde está la IP de destino? En qué router y de ahí establezco la conexión, el camino. A ver. ¿Qué tendría que--? Puedo decir, "macheo". ¿Macheo qué hago? Es decir, concretamente, si yo estoy en el router 3 y me llega un paquete que va acá, ¿qué debería hacer con esto? Estoy en el router 3, perdón, es esta. Mi tabla de ruteo va a ser esta, ¿no? Esta. Sí, hay que buscar el prefijo. Tengo que recorrer la tabla. Por eso, tendría que decir, ¿qué es lo que tendría que decir? Para-- Para entrada. Para acá, no sé, entrada en-- No, al revés lo hicimos, en "t" ruteo. ¿Así? Sí. Entonces, ¿por cada entrada qué voy a tener yo? Voy a tener IP, máscara, interfaz y voy a saber si es link o no. ¿Qué voy a decidir comparándolo con lo que tenía acá? Y viendo si-- ¿Qué le tengo que mirar a esto contra esto que está acá? Si es vecino. Si es vecino o, más específicamente, ¿qué voy a mirar ahora? El prefijo. Pero dígame, comparándolo así a mano, a simple vista, ¿qué mirarían ustedes para-- Son un algoritmo. ¿Miran cómo deciden por cuál de estas tienen que irse en base a esta información? Y viendo en la parte de IP, en la columna IP, si tienen el mismo prefijo. Por eso. La que más se parezca. Por eso, pero no, la que más se parezca diría un brujo. ¿El ingeniero qué dice? ¿Qué puedo reutilizar de este código? Y él es vecino o vecino, no me acuerdo cómo se llama la función. O vecino. Pero, bueno, básicamente, ¿qué voy a hacer? Este pedazo de aspecto que está acá, lo voy a necesitar comparar. Es decir, para cada entrada o para cada, vamos a poner ruta, más cortito. En tabla de ruteo voy a mirar si... El primer elemento de la ruta. El predestino con... Ruta, máscara. Sugiero ponerle entrada. ¿Entrada? Me parece clarito que es una línea. Bien. Recuerden que estamos hablando que cada uno de estos tiene IP, máscara, interfaz, gateway. Es decir, yo voy a decir si la IP destino, AND, la entrada que estoy, la máscara, es... ¿Contra qué lo comparo? A la IP nuestra, digamos, el router 3. No, pero por eso, pero estoy haciendo un algoritmo, Guitera, ¿sobre qué? Sobre la tabla. Con cada IP de la tabla. Por eso, pero y el algoritmo acá que estoy poniendo, si ENT, ¿qué tendría que poner acá? ENT IP. ENT IP. Con... ENT... Máscara. Es decir, eso va a comparar si esta IP, la primera vez, va a tomar, voy a decir, che, 120 contra... 120, ¿cae en 120/24? No, ¿cae acá? Es decir, tendría que ir tomando cada una de las entradas de la tabla. Si machea, ¿qué? ¿Qué si? Si machea... Es decir, che, ah, ok. ¿Qué debería hacer yo? Reutilizar el código. Y hacer atraer el código para el otro router que pertenece a ese enlace. ¿Qué debería hacer? Listo, digo que... Agarra la MAC del que es, macheo, digamos. A ver... Me quería caerme. No me escucho. Quiero que me cuenten a ver qué hacemos. Toma la máscara de la IP... De la entrada. Espérate, no. Lo que hace es pedirle al gateway la MAC. Con la línea, como lo hacíamos recién, lo mismo, pero con el gateway en este caso. A ver... Con el gateway, pero... A ver, hagamos... Es decir, acá lo voy a pegar. Pregunta MAC, la habíamos puesto. Sí. ¿De quién? Ent... ¿Qué doble? Pregunta MAC de Ent Gateway. No, ¿verdad? Es Ent IP, y el siguiente es... Se me dieron vuelta los... A ver... Dejémoslo por ahora. Vamos a ver, vamos a ver, vamos a ver... ¿Cómo se llama? De quién fue el gateway, y después qué tiene que hacerle. Mandar... Si averigua la MAC. Sí, se lo manda. ¿Qué tiene que hacer? Mandar la trama a MAC en el datagrama. Ya vamos a ver cómo resolvemos la parte de los que son vecinos directamente conectados. Pero, digamos, para cada entrada en la tabla de ruteo, yo voy a preguntar si la IP destino con la máscara que tengo en la entrada, operada la entrada del IP y la entrada de la máscara, esto me da igual. Debería preguntar la MAC de la entrada que es el gateway, y mandarle la trama de la MAC que yo haya resuelto. Sí. ¿Qué pasaría si nunca machea esto? ¿Qué significa? Que nunca entró acá. Y que no puede llegar. Claro. O que está en un router equivocado y lo tiene que devolver. ¿Cómo que está en el router equivocado? No tiene camino para mandar la IP. Si yo atravieso este bucle, termine este bucle, acá, y salí por acá, es decir, llegué hasta el final y nunca mandé la trama, ¿qué pasó? Es que recorrí toda la entrada de la tabla de ruteo y ninguna abarcaba el destino. ¿Qué es lo correcto en este caso? ¿Qué sería? ¿Lo correcto en qué sentido? No, en términos, si hemos dicho que solo se rutea lo que está descripto en la tabla. Si no está descripto ahí, no se rutea. Si yo le digo notificar, le digo aviso ICMP, ¿qué te damos aquí? No hay ruta, flaco. Para eso, en realidad, acá, cuando manda la trama, estrictamente, si lo viéramos de manera programática, esto no vuelve acá, es decir, acá termina esta entrada. ¿Se entiende o no? Sí, sí. ¿En realidad es un break? Tiene razón el colega. No, perdón, sería un return, colgásele un return. Por eso, pongámosle un return. Bien, acá la única cuestión que nos queda, si quieren de alguna forma, de ilustrar es, bueno, pensemos en esto. Imaginemos este algoritmo, imaginemos que estamos en el router 3, en realidad yo quiero hablar con el 208. Mi destino es 208, vengo acá, digo, para acá, entrada en la tabla de ruteo, digo, bueno, me vengo a la primera, digo, 208. 208, 24, así que queda 200. ¿Es igual a 192, 181? No. No, listo. Es decir que esto no sale por acá, va a la próxima entrada. Toma esta entrada. 208, operado máscara, 220. ¿Es igual? Sí. Lo que yo tendría que hacer es, en esta función, que es la que pregunta la Mac, para este caso particular, en realidad lo que puedo hacer es, si quieren, para que se queden tranquilos, yo puedo decir que, preguntar Mac, que tiene como parámetro, entrada sub-gateway, en realidad es entrar sub-gateway. Yo creo que habría que hacer un if ahí para que quede más claro, me parece, es decir, if gateway igual link. Lo iba a hacer ahí arriba, sí. Pero bueno, voy a eso, voy a eso, como quiera. Ah, perfecto. Acá va a gateway y va a interfaz, ¿no? Ahí está. Bueno, ok. Entonces, si yo acá le pongo "preguntar cosa" y le pongo "entrada sub-interfaz", ¿cuál sería la... si entrada sub-gateway? ¿El link? Sería sub-interfaz, sería. No, lo que les quiero decir es que... Perdón. Le pasa que ahí vas a tener que pasarle la IP. Preguntar Mac, entrada... En el if, profe, que puso si entrada y puso gateway igual a link. Ahí sería si entrada, interfaz. Para tengo interfaz. Ah, gateway y es link, está bien. Y si no es... Se me corrió la columna. Es decir, gateway... Creo que me va a alcanzar, me parece. No me va a ser falta, es decir, piensen que gateway lleva link, como lo hemos hecho, digamos, lleva link o lleva la IP. Entonces si yo pregunto si la entrada sub-gateway es link, ¿qué tengo que hacer? Que lo mande ese link. ¿Ah? Manda la trama. No, estoy averiguando la Mac. Tiene que usar la interfaz. Por eso, pero vamos por partes. Si está link, yo tengo que arpear en ese cable... Ah, ahí no hay que chequearlo simplemente después la IP. Ah, ahora caí lo que decía Juanjo, tenés razón. Acá tengo que mandarle la IP destino, decís vos. Sí. Va a tener, sí. La interfaz va siempre, por eso me parecía hacerlo allá abajo. Tenés razón, tenés razón. Vamos a hacerlo acá abajo. Vamos a hacer... Acá decís vos. Entrada sub-gateway. Exactamente, igual a link. Es link. La Mac, es preguntar la Mac de entrada sub... No, de IP. Destino en la interfaz esa, ¿no? Ahí está, así. Ahora está, perfecto. Perdón, sí, sino me iba a tener que pasar un parámetro más. Tenías razón, perdón. Si no, la Mac va a ser preguntar la Mac de entrada gateway. También en la interfaz, correcto. Entrada interfaz. La pregunta de la Mac, ¿para qué necesitaba la interfaz? Porque yo puedo tener, acá fíjate cómo va cambiando la interfaz. No podés harpear en toda la interfaz a la vez. Claro, sí, sí, tiene sentido. A ver. Fíjense que... Repasamos ahora. Dijimos que queríamos hablar con el 208. Si 208 va a pegar en esta entrada. Va a decir, che, 200 es igual a 200. Entonces, va a agarrar y va a decir, si entrada gateway es link, ok. Va a preguntar la Mac de 208 por la interfaz de TH1. Y después le va a mandar la trama. Es decir que, esta modificación que acabamos de hacer así, ¿qué permite contactar? Los vecinos. Es decir que esta parte del algoritmo así, ya resuelve todo lo que hacía este otro algoritmo. Y esta otra parte del algoritmo que está acá, ¿qué resuelve? Cuando no son vecinos. Todos los demás destinos. Es decir, que esto rutea IP. Y más, rutearía cualquier cosa de cualquier lado de la internet también. Este es el algoritmo de ruteo IP. ¿Dónde está la inteligencia del ruteo entonces? En la tabla. No escucho a mucha gente convencida, pero es correcto. ¿Cómo, perdón, profe, podría repetir? Vamos de nuevo. Este algoritmo, hagamos el ejemplo a ver si sirve. Yo estoy en R3, pero vamos a ver si sirve. Hagamos el ejemplo a ver si sirve. Yo estoy en R3, pero vamos a corrernos a R2 ahora. R2, y resulta que quiero mandarle un paquete a... Estoy en R2, y le quiero mandar un paquete a 172.16.16.1. Si estoy... Vamos de nuevo a R2. La tabla es esta, que está acá. Sí. Veamos. El destino es 16.16.1. Entonces, digo, para cada entrada en tal de ruteo, pregunto, 16.16.1 /24, que sería la primera entrada, me compararía 172.16.16. ¿Es igual a 10.10.10.10? No, es la tercera. No. ¿Sí? Entonces, no entra ninguno. ¿Es igual a 100? No. ¿Es igual a 16.16.16.24? Sí. Es decir que cayó acá adentro. Va a preguntar, "entrada sub-gateway", que sería esta, en este caso, 10.10.10. ¿Es link? No. Es decir que la MAC va a ser... Tiene que agarrar y preguntar la MAC en... La MAC de la IP 10.10.10.1 por la interfaz de TH0. Es decir que va a estar preguntando, está acá, ¿sí? Y está arpeando por esta IP. Le va a responder este router la MAC. Va a tener la MAC y le va a decir, "che, le mando la trama a esa MAC, tomá la trama". Es decir que este se lo va a dar a este. ¿Se ve? Sí. Entonces, ¿dónde reside la inteligencia? En el algoritmo. En el algoritmo, ¿dónde está la inteligencia de esto? Sí, en el algoritmo. Y si esto... Es decir, el código, el cerebro es el algoritmo y lo que le da vida y lo que hace que funcione sería... Es decir, el algoritmo es súper simple, fíjense, que son básicamente 10 líneas de código. Pero lo que le da la... En definitiva, ¿dónde está la clave para que esto funcione? En la tabla de cada ruta. Por eso. Entonces, ¿qué hay que aprender a hacer? ¿Algoritmo de ruteo? Tabla de ruteo. La tabla de ruteo. Claro. Hay que saber rutear. Bien. ¿Qué hay que saber para saber rutear? ¿Qué hay que saber para saber rutear? Preguntarse. ¿A dónde quiero ir? Primero, bajo la base, es decir, la pregunta cero es dónde estoy. Lo primero, ¿no? Es decir, pisar bien, pisar fuerte. Es decir, ¿dónde estoy? ¿A dónde quiero ir? Que sería el destino de ser... ¿Quién me puede llevar al destino? ¿Y quién me puede llevar al destino? ¿Qué característica tiene que tener con respecto a dónde estoy? Que esté en el mismo lugar, que sea un vecino. Tiene que ser vecino. ¿Sí? Entonces, en realidad, lo más importante que tenemos que aprender a hacer, que es lo que a nosotros nos interesa enseñarles, aparte de que hemos aprendido que básicamente el ruteo es cuadrado, como esto, es que hay que tener un ruteo que se pueda hacer en el mismo lugar. ¿Qué significa esto? Es... Ustedes, inicialmente o generalmente, lo que van a tener que hacer, si yo les cambio la red, ¿qué cambia de todo esto que hemos hecho acá? La tabla. Cambia las tablas de ruteo, entonces yo básicamente describo el comportamiento de una red escribiendo las tablas de ruteo y configurando las interfaces. Eso es lo que define el comportamiento de una red. Entonces, tengo que aprender a hacerme las preguntas adecuadas. Y en realidad esto es un problema de lo más común que uno ve en la calle, porque la gente no sabe rutear. La gente no. Las personas que deben tomar la decisión no saben rutear porque confunden los principios básicos. Como nosotros hemos hecho el algoritmo acá, ustedes se dan cuenta que no se puede rutear si no es vecino. Porque voy a arpear por alguien que no está en el cable, entonces no va a andar. Si llevamos este algoritmo a este problema, ¿creen que va a andar? Sí. Sí, sí va a andar. Y acá le falta una sola cosa. Va, le falta una sola cosa. Eh... Dale, dale, que no va a decir. No, no, no. Va a hablar de esa cosa que empieza con G. Con G qué, no. No, o el orden de la mano. Ah, eso, eso, eso, eso, eso, eso. Dale. Claro, pero lo deberíamos introducir. Pregunta, ven ahí, fíjense que gateway, cuando hablamos de gateway, es una palabra bastante sobrecargada, ¿no? Porque en contextos normales, gateway es el gateway hacia el internet, sin aclarar nada. La ruta por default. Acá en gateway estamos hablando de nuestro próximo router que nos lleva hacia un destino que no necesariamente es toda la internet, entre comillas, ¿no? Lo estoy simplificando. ¿Tenemos alguna ruta por default en alguna de esas tablas de ruteo? No. Fíjense, ¿no? Eso es interesante. Estamos ruteando y en realidad, como no tenemos ningún globito que diga internet por ahí, ni algún conjunto muy grande de destinos como para decir, y bueno, hago un fallback y digo, todo esto va por ahí. Podríamos colgarle, lo que sea hacer ejercicio para un router, le podríamos colgar, ponerle a R2, colguémosle una conexión a internet, ¿te parece? Bueno, sí, dale. Y veamos cómo hay que modificar R1. A ver, voy a, bueno, no me entre en otro lado, la voy a poner acá. Sí, ponle ahí una patita. La internet, la internet está acá. Claro. ¿A cuál le querés, al R1? Al R2, colgáselo y vamos a modificar R1 y R2, obviamente. A ver, acabamos de hacer eso, que está lindo el ejercicio que vamos a hacer ahora. Le acabamos de dar un enlace a internet a R2. Bien. Por lo tanto, le acabamos de configurar una interfaz a R2. ¿Cómo deberíamos modificar la tabla de ruteo de R2? Agregamos un vecino más, un link más. Ok, pongámosle, son direcciones públicas, vamos a asumir que R2, para que quede más, eso, cosa así. Oh, qué difícil que sos, Diego, qué raro que sos. Lo digo en broma porque elegí un barra 30. ¿Muy chiquitito? No sé. Es muy chiquitita la máscara, pero está bien. ¿Es casual que Diego haya elegido un barra 30? No, porque si es barra 30 tendría dos hosts nada más. Dos hosts reales con cuatro IPs matemáticamente posibles, ¿no? Sabemos que la primera se reserva para la red, la última para broadcast, que es un medio de internet, que típicamente es. Por lo tanto, la mínima máscara, la máscara más chiquitita que me permite dos vecinos de internet es barra 30. Y como no sobran las IPs, en absoluto, las IPs de cuatro no sobran para nada, bien en nuestro ISP que nos haya dado un barra 30. Ok, vamos a dejarlo ahí porque yo creo que no hace falta poner cuál va a ser la IP de mi router, cuál va a ser. Bueno, bueno, no lo dibujo. ¿Por qué no lo dibujé para no sobrecargar el dibujo? Porque los chicos ya saben. ¿Cuál es la única otra IP posible en esa red? La 2. Bien, ¿por qué no la 0 y por qué no la 3? 0 es de red, 3 es de broadcast. Tienen una misión, ¿no? 0 es reservada, esa te la creo, pero 3 no es reservada, 3 explotaría porque 3 es broadcast. No puedo routear vía broadcast. Una barra 30, tiene dos bits libres al final y eso es justamente, si vos pones todo en uno, te da 3. Bien, edíctennos entonces qué tenemos que poner en R2, que es el que estamos modificando. Ahora y después vamos a propagar, nosotros como vialidad que somos, vamos a ponerle cartelitos a todas las otras bifurcaciones. Pero primero empezamos con la primera, la vamos a pinchar R2. ¿Cuál sería, aferrándonos a los conceptos de las preguntas claves, dónde estoy? Y el 280, 32. No, no, dónde estoy, estoy en R2. En R2. Ok. ¿A dónde quiero ir? A internet. Bueno, pero es un brujo. ¿Cuál es el destino IP? Claro, cuál es el destino. 255, 255, 255, 255. Claro, me tengo que poner a averiguar, ah no, tengo que averiguar la IP de Google y la pongo ahí. Y después averigué la de Facebook. Porque yo tengo que poner una entrada ahí, ese es el punto. Tiene que ser una CIDR. Por cierto, R2 ahí hay que retocarle negro las interfaces, que están todas en el TH0, no sé con qué criterio las estabas... R2... No sé cómo... Ah, este es H0 y este es H1, para ir a la 172 vas por el TH0, para ir a 1 por el TH0... No. Está bien así. Ah, perfecto, ok. Bien, volvamos al problema, esta va a ser el TH2, ¿no? Es la próxima porque tuvimos que pluggear una interfaz nueva, la tercera interfaz. Eso está fácil, pero ¿cuál es el destino? Bien, ahí. Fundamental. Esa es la más simple de todas. La 255 es el gateway. Había dicho, profesor. No, el gateway es, si yo estoy en la red, 32.1/30. ¿Quién es la única? .1/30. .1/30 tiene como posibles números la .0, la .1, la .2 y la .3. Y nada más que eso. Y el destino va a ser siempre la 2, si no te queda otra. No, no, ¿ese es el destino o ese es quien te puede llevar al destino? Estás confundiendo el destino con quien te puede llevar. Claro. La pregunta que tenemos que resolver es la segunda. Por eso acá esto es "use the force", Luke. Siempre haces las mismas preguntas. Porque si no se van a mandar un muco. ¿Dónde estoy? En R2. ¿A dónde quiero ir? ¿Qué es lo que estamos tratando de dar vueltas? De decir, ¿cómo yo puedo, con notación CIDR, describir todos los destinos de Internet? ¿Cuál es la máscara más grande de todas? La máscara que... .1. .0. Que todas sean correspondientes a la red. Claro. Claro, que nada me fije, que no tenga prefijo. Que tenga el prefijo totalmente anulado. De esta manera que me aché de todo. Que yo no le ponga restricción a ese prefijo. Que yo decía, no, todos los que tienen solamente este prefijo. ¿Cuáles son todas las posibles elecciones IP ever? Aquellas que tienen ningún prefijo. Porque yo no fijar el prefijo, le permito que sea cualquiera. Por lo tanto, /0 está bueno. /0. ¿Y qué le ponemos antes de /0? Ah, ya lo puse. Bien. Está bueno. Ahí está. Perfecto. Bien, ¿por cuál interfaz salimos? La 2. La 2, bien. ¿Quién es? Lo ponemos ahí. Ahí sí va, 222. .2. 32. Perfecto. Bien, Mauricio. Vamos a la algoritmo. Igual no debería ir esa entrada al último. Por el tema de que cuando, iterando... ¿Por qué? Cualquiera... ¿Por qué tienen que ir al último? Ah, ¿qué pasó ahí? ¿Por qué tienen que ir al último si...? No, pero está... Estaría bueno que, me parece que estamos hablando... Estamos en una clase uno-tú-no. No sé si toda la gente está... No, yo lo preguntaría... Está excelente la observación y te voy a pedir que te calles un momentito. Porque está muy bueno la observación. Yo tiro ahí, por ejemplo, la... A ver, déjame tomar una. 172, 16, 16, 100. ¿Cuántas entradas "machean" esa entrada? 172, 16, 16, 100. En R2, la que está abajo... Y la anterior, ¿no? En 0, 0. Y la anterior también. Ok, hay dos que "machean". Ahí tenemos una ambigüedad. ¿Cómo desambiguamos eso? ¿Cuál de las dos es la correcta, semánticamente hablando? Es decir, la 172, 16, 16. ¿Y por qué es más correcta esa? Porque es más específica. Bien, porque describe un conjunto más pequeño. Por lo tanto, alguien tomó el esfuerzo de decir... No es todo, este conjuntito en particular va por acá. Entonces respetemos eso. ¿Y cómo deberíamos ordenar la tabla de ruteo... ...tal que se respete que los más específicos estén primero? Y de más específicos, menos específicos. Correcto. ¿Y qué significa eso matemáticamente hablando con los números que tenemos ahí en la tabla? Por la máscara. Por la máscara. Claro, las máscaras más específicas, por lo tanto las máscaras que tienen un número más grande, van al principio. Y las tengo que ordenar. Si no, va a pasar exactamente lo que recién mencionó tu compañero. El que dice "cachazo". Que en realidad, si yo no los ordeno, así voy a tener el problema que... ¡Pum! La entrada más grande me va a machear antes y me va a tirar para cualquier lado. El punto sería, ¿está mal la entrada o está mal ubicada la entrada? Ah, no, yo tengo que tener el cuidado de cargarla en el momento que... Ah, no, la tengo que poner al final para que caiga al final. La entrada, ¿está mal o no estaba en el lugar adecuado? No estaba en el lugar adecuado. Por eso, entonces, yo me tengo que decir, no, en el manual de configuración decirle... No, mirá, tenés que esperar al final de toda la ruta para poner la ruta cero. Le pongo que no ordene por la máscara. Claro, por eso, si no puedo depender del usuario para que esto ande. ¿Qué le cambia el algoritmo entonces? Que es un poco lo que les estaba diciendo. Y primero poner un sort, digamos. Por eso, tengo que decir. Claro, pero hay un detalle, hay un detalle que me gustaría observar. Para mí, el sort es una operación cara. Si alguna vez hicieron algoritmo, saben que el sort es una operación cara. Así que es una operación que se hace en el momento que lo modifico. ¿Por qué? Porque el humano o un cerebro superior modificará e ingresará esas entradas. Y ahí se sortean y se graban ya ordenadas. No el sort en runtime, porque si no, si por cada paquete que tengo que sortear, algo que es estático, para mi punto de vista, como paquete que tengo resolver. En realidad ese sort se hace en el momento en que se cambia. Yo agrego una entrada, entonces en ese momento, cuando el sistema operativo a través de la syscall que me dice agregar entrada, ahí sorteará la tabla y dejará listilla, ordenada adecuadamente para cuando yo venga en runtime, ya esté ordenada y no tendré que hacer el sort con cada búsqueda en runtime. Eso es una optimización casi que obvia. No sé si entienden la diferencia de lo que dice Juanjo, es que no vamos a ordenar la tabla cada vez que ejecute el algoritmo, porque si no estaría gastando ciclo de CPU al cuete. La tabla de ruteo está ordenada al momento de configurar. Al momento de modificarla, porque ya después es estática, hasta que se vuelva a modificar. De hecho la tabla se modifica raramente, define raramente, con baja frecuencia. O la frecuencia de modificación de la tabla es mucho menor que la frecuencia de uso de la tabla. Por lo tanto, más vale sortearla cuando la modifico, ahí ordenarla hasta que cuando la use, que tiene mucho más frecuencia, como la cambio, sea más eficiente. Eso que... Sí, perdón. No, dale, dale, perdón. No, no, dale, porque quería acotar algo tangencial, pero bueno, dale. No, no, no, yo iba a decir una cuestión estructural, pero dale, dale. Díctenos, y ya como para ir cerrando, ¿cuál sería la entrada para...? A ver, pregunta. ¿R1 ya tiene internet? Así lo digo, estamos cansados. ¿Ya tiene internet? ¿R1? Y sus vecinos. No está configurado todavía en la tabla. No tiene. Bien, ok. ¿Qué le falta? Es cuestión de... habría que copiar y pegar la misma entrada, ¿cierto? Hácelo, ahí está, listo, ya está, ahí ya anda. No, no, hay que modificarlo. No, hay que cambiarlo. Ok. No solo el gateway, sino la interfase también. ¿Por dónde se va a internet desde R1? No, más que dos interfaces. Vamos de nuevo, Luke. Use the force. ¿Dónde estoy? En R1. En R1. ¿A dónde quiero ir? A 0, 0, 0, 0. ¿Quién me lleva desde R1 a 0, 0, 0? R2. R2, que vendría siendo... La interfase que apunta hacia mí... De R2 la interfase de la cual yo soy vecino, ¿no? Mi vecindad con R2 me lleva, no R2. Sí, está bien, R2. Pero estrictamente mi vecindad con R2 es la que me lleva, ¿no? Ahí está. Y en R3, ¿quién le podría dar internet? Vamos, Luke. Use the force. ¿Dónde estoy? En su vecindad con R1. En R3. Quiero la respuesta de la pregunta. En R3. ¿A dónde quiero ir? A 0, 0. ¿Quién me puede llevar a 0, 0? R1. R2. La... La R2 de H1. Así. Esta es la verdad de la milanesa del ruteo. El gateway por default, la ruta por default, el gateway de Windows, todo eso es una ilusión óptica. No es una cosa que exista. Es una deformación mental que ustedes han lamentablemente recibido en sus cabezas. Pero no existe el gateway por default. En realidad, es la ruta al destino cero. Miren. Ese es el router de mi casa. Este es el router de la... Cloud. Si yo les pregunto, ¿cuál es... ...el gateway por default? Dice acá en algún lado... Ah, el gateway por default es tal. Dice acá en algún lado, ¿cuál es el gateway por default? Dice default. No, no. Mostrar el IPRU, IPRO, no sé si está mal. Ah, ahora sí. Ah, por eso. Porque dice default, no puede ser. Por eso, no lo quería mostrar. Profe, igual usted dijo que cualquier ruta que me llegue al 0.0.0, ese es como el gateway por default, entre comillas. O sea, esa es la relación que hay, digamos. Esa es la única relación. No existe el otro. No existe tal... Es decir, la palabra default es como si el string default se mapeara 0.0.0 para 0. Claro, aparte si existiera la ruta por default, este algoritmo no funcionaría. Tendríamos que configurar en algún lado la ruta por default. Y yo los invito a que busquen en el libro de Internet Core Protocol, o en el libro de Douglas Comer, en cualquier lado, el algoritmo de ruteo de IP. Y el algoritmo de ruteo de IP es un algoritmo que itera sobre la tabla de ruteo. Entonces, lo que les quiero... Esto es como decirles que los reyes magos no existen, el papá no es el tampoco. No existe, muchachos. No existe la ruta por default. Es decir, no existe un lugar para configurar en un solo lugar y decir "ah, esta es la ruta por default". Solo existe escribir cosas en la tabla de ruteo. La manera de obligar a que todo el tráfico se vaya por un lugar es poner una ruta con máscara cero. Y así funciona. Es decir, si ustedes tienen un Windows, si alguno tiene su Windows ahora pongan, creo que es lo mismo, "route print" pongan. En un Windows. Pongan "route print". Y van a ver que les va a mostrar esta misma tabla. ¿Alguno tiene Windows? Pueden declararlo, no les vamos a hacer nada. Ahí lo dice. No, porque yo le preguntaba porque en realidad no tendría sentido que fuera default. Porque en este caso hay muchas cero, cero, cero, cero. ¿Cómo hay muchas cero, cero? ¿En dónde? Y acá en el gateway, dice. No, pero acá el tema es el destino y la máscara. La máscara es cero. Ah, está bien. No el gateway. Sí, sí, sí. Ahí lo dijo. "Use the force", "Use the force". ¿Dónde estoy? ¿A dónde quiero ir? ¿Quién me puede llevar? Son todas cosas distintas. Bien, perfecto. En serio, se lo hacemos así porque en serio que les va a salvar la vida responderse esas preguntas porque si no se van a confundir. De hecho, recién ustedes confunden quién los puede llevar con dónde quieren ir. Entonces háganse las preguntas, no cuesta nada. Pregúntense a dónde van a ir separado de quién los puede llevar. Y quién los va a llevar es vecino. Entonces, fíjate, acá es a dónde quiero ir es cero, quién me puede llevar es este. Y la máscara es cero, digamos. Estas dos operaciones describen que esto es toda la cacerola. Cero, cero, cero, cero es toda cualquier IP. Y también, ¿por qué les queremos decir que tienen que verlo así? En sistemas operativos sofisticados como estos, como Linux. Y ya con esto les reventamos la cabeza. ¿Qué pasaría si yo tuviera dos conexiones a internet? Si yo tuviera dos internet acá. Habrían dos entradas para cero, cero, cero. ¿Y dónde dice el algoritmo acá que balancee por las dos entradas? ¿Cómo, cómo, cómo? Es decir, ¿cómo podría tener dos entradas? No puede tener dos entradas, va a entrar por una, va a elegir la que esté primera y se la va a pegar. Claro, o sea, tiene dos líneas en la tabla, digamos, dos entradas en la tabla, pero entra por la primera. Y entonces, ¿como si tuviera un solo enlace a internet? ¿Para qué tengo dos conexiones a internet? Quiero tener dos conexiones a internet y entrarlas. Redundancia, no sé, por ahí una no funciona. Eso lo hizo un brujo, no lo hizo un ingeniero. ¿Cómo se implementa la redundancia? ¿Cómo se implementa? ¿No tiene que tener otra tabla para la otra conexión? ¿Otra tabla, dice? A ver. No sé, estoy tirando ideas por tirar ideas. Podríamos dividirla en dos, que vaya la mitad para un lado y la mitad para el otro. ¿Y el algoritmo este qué? ¿Lo tenemos que codear de nuevo, digamos? ¿Se entiende cuál es el punto? Es decir, no puedo tener dos entradas cero. A ver, algunos protocolos yo le puedo poner una métrica acá, le puedo poner un peso y hacer que tome una u otra. Pero la cuestión es, no puedo describir dos caserolas barra cero y decir, bueno, con la que caiga primero. Ahí ya varían mucho las implementaciones, pero la solución en realidad, cuando uno tiene una... es tener otra tabla de ruteo. Tengo dos tablas de ruteo y cada una tiene su ruta a la caserola cero. ¿Está bien? Y le antepongo al algoritmo alguna regla que use una tabla u otra. ¿Se entiende? Es decir, si yo al algoritmo de ruteo, acá arriba digo, a ver, bueno, yo voy a hacer así. Te voy a mirar la IP de la que venís. Y según de dónde venís, por ejemplo, te hago usar una tabla u otra. Es como si te switcheo la tabla de ruteo. Y todo lo demás sigue andando igual. Bueno, eso lo hacen algunos sistemas operativos como el Inun. Se llama policy routing. Pero no cambia el algoritmo de ruteo. Uy, se nos fue el tiempo la miércoles. Bueno, vamos a dejar acá. Es súper importante y yo los invito a que miren esta clase de nuevo. Si alguno no ha entendido algo, la miren de nuevo porque es vital. Voy a cortar la grabación ya. Cofe, una última duda.Bueno, para recordar en dónde estamos parados, hoy vamos a continuar con nuestro viaje por el protocolo IP y vamos a dar inicio a un tema que es para nosotros el más importante de las funciones que tienen. Recuerden que estábamos viendo el protocolo IP y un poco habíamos ido sintetizando cuáles eran las funciones del protocolo IP y cuál era su misión. Hemos estado mucho arriba de la parte de la abstracción lógica y nosotros decíamos que eso se lograba a través de que a nivel IP, cómo se ven todos los miembros de una red IP, qué es lo que tienen para poder participar y lo hace miembros. Hola, ¿están ahí? ¿Una IP? Una IP. Dijimos que la capa, el protocolo IP, por las cosas que vimos en la clase anterior, nos ofrecía una abstracción de la red, básicamente para el protocolo IP y todos los que están arriba, los que juegan en una red IP tienen un número IP. Y eso da una capa de abstracción que es una misión súper importante y una muy excelente decisión de diseño. A su vez vimos que sobre esto teníamos una jerarquía, el direccionamiento IP nos permite saber quién es miembro de mi misma red. ¿Cómo se llamaban los miembros de mi misma red? Como le decimos nosotros. Vecinos. Quiénes son vecinos y obviamente vamos a ver que hay algunos que no son vecinos. Y la otra misión importantísima del protocolo IP es justamente esa. ¿Qué va a ocurrir con aquellos, si yo necesito contactar a alguien que no es vecino mío? Entonces la misión del protocolo IP, que es la que vamos a hablar hoy, es la del encaminamiento o el ruteo o routing, usando las palabras en inglés, que es el protocolo IP es el responsable, el encargado de resolver cómo los datagramas se encaminan hacia el destino. Y cuando decimos se encamina hacia el destino, es se encamina hacia el destino cualquier IP que sea del destino. Para eso, si yo les dijera, bueno, ¿quién es el encargado de que estos paquetes, ustedes están de acuerdo que estos paquetes que llevan nuestra videoconferencia se mueven por una red IP o no se mueven por una red IP? Sí. Ajá. ¿Y la red IP más grande qué hay? ¿Cuál es? Internet. Y la internet, digamos. Claramente muchas de estas cosas son muy sencillas de explicar. Y bueno, ¿y esto andará? Y evidentemente anda, porque si no, ni nos estaríamos viendo ahora. Así que, bueno, imagínense, hay en todos los lugares, y eso es un poco lo que vamos a hablar hoy, es ¿quiénes hacen ese trabajo de encaminarse hacia el destino? ¿Quién hace el trabajo de que estos datagramas lleguen al destino? El router. Ajá. Y los routers son bichos de otra especie distinto que hay en una red. Router o ¿y los otros qué son? Si no son routers. ¿Un switch? Hola. A ver. Hola host. ¿Switch o host? ¿Switch? ¿Qué capa? ¿Switch? Dos. Dos. Entonces nosotros no estamos hablando en esta capa. ¿En qué capa estamos hablando? De tres para arriba. Claro, ¿en qué capa juegan los que juegan con IPs? En capa tres. En capa tres. En la tres, digamos. Deme un segundito. No sé si vos podés continuar un segundito, Juan, que tengo que atender un temita acá. Sí, claro. Bien, capa tres. Recordemos rápidamente un poco que TCP tenía cuatro capas en realidad, pero está bien que hablemos de las capas ISO. La capa que vemos... Ah, yo no tengo control de lo que se está proyectando. Déjeme ver si puedo cortar y tomar... Capaz que sí. Un segundito. Un cachito. De tal manera que se vea mi mouse cuando lo señale. Vamos a ver si puedo robar la proyección. Vamos con una ventana. Reemplazar. Bien. Ventana de la ventana. Dígame si se ve. Está cargando. Ah, bueno. Y se ve mi mouse, ¿no? Es como para confirmar. Sí, sí. Perfecto. Bien. Entonces, recordemos rápidamente que acá en realidad TCP, fíjense que acá está dibujado cuatro capas, enlace, red, transporte de aplicación. Pero en términos dos, sí, acá estamos en la capa tres. Lo importante entonces, lo que estábamos remarcando recién es que las únicas partes que implementan todo el stack de protocolo hasta arriba, incluido la aplicación, son las puntas. Son lo que serían los que se suelen denominar end hosts, o nodos, terminales, o tiene un montón de denominaciones. Pero todas las partes del medio, lo que técnicamente se denomina sistemas intermediarios acá para poder llevar un datagrama de punta a punta, solamente necesitan implementar hasta capa tres, como bien dijeron. Lo que vamos a ver hoy fundamentalmente es cuáles son las características que tiene la implementación de esto. Vamos a poner, si se quiere, la lupa en los routers para ver qué es lo que necesitamos que implementen, qué tipo de lógica, qué tipo de lógica de decisión, de encaminamiento, de reenvío, de datagrama necesitamos que existan en estos routers. Para que cumplan su rol, y su rol es sencillamente servir de alguna manera de encaminamiento, de secuencia, para que si este host de la izquierda pone un datagrama con destino al host de la derecha, todo el conglomerado de estos routers conectados antes sí sean capaces de resolver esa entrega. Llega por aquí y se entrega al host destino. Una pregunta, me parece que lo habíamos hablado en la clase pasada, pero me disculpan si ya lo había preguntado. ¿Qué significaría que estos routers se implementaran más arriba de capa tres? Estamos en el contexto de que, recalcando el hecho de que solamente hace falta que se implemente hasta capa tres, porque es capa de red, yo estoy preguntando a modo de completar la idea, si estos routers se implementaran más arriba de capa tres, ¿de qué serían capaces? Voy a cambiar la pregunta un poco. Justamente por estas capas nosotros sabemos que una aplicación es capaz de comunicarse con otra aplicación aquí. Y si quiere, las que se comunican, capa siete, estas aplicaciones hacen uso de todos estos stacks de protocolo, en el caso de TCP hace uso de la capa de transporte, de la capa de red, de la capa de enlace para poder enviar ese datagrama y construir en una, usando una secuencia de datagramas, un conjunto de datagramas, construir algo lo más parecido a una conexión. Esta aplicación, hablando con esta aplicación, yo desde acá, desde mi browser, navegando Google, ¿sí? A través de usando el protocolo de aplicación al JTP. Y en el medio solamente necesito que estas cosas, que solamente entienden hasta capa tres, para lo que yo necesito usarla, me reenvíen datagramas. Entonces yo lo que le pregunto, si proveyéramos a esta de las capas acá de más arriba, ¿sí? Si el router le ponemos capa cuatro, o si quiere capa de transporte y capa de aplicación, ¿qué podría hacerle ese router entonces? Y ¿podría hacer redes a nivel de software? No, eso sería más bien, bueno, a ver, ¿es un router más inteligente? ¿Le pondría un cráneo a ese router y podría de alguna manera, lo que vos estás diciendo es que es más o menos una consecuencia, pero a ver, tal cual está la figura ahí, lo voy a preguntar más sencillo. ¿Yo me puedo conectar, entre comillas, lo que siempre se dice así, medio como dice mi colega en forma de brujo, ¿me puedo conectar al router? Tal cual está lo que estamos presentando. ¿Vos estás presentando ahora, Diego? Me parece que tomaste vuelta la presentación. No, yo me paré en esa diapos nada más. Ah, listo, listo. Así se los pregunto de una manera simple, ¿me puedo conectar al router ahí? Tal cual está ese dibujo así. No. ¿Por qué? Me parece que sí, pero no sé. Yo por lo que veo, creería que sí. Interesante, ¿y quién me atendería en el router? Pues si yo me conecto, cuando digo conecto, es voy a establecer alguna sesión, ya estoy hablando capa 5, porque es una conexión, transporte, sesión, aplicación, porque me voy a conectar yo como humano para hacerle algo al router como configurarlo, por ejemplo. Me estoy espoliando la respuesta, pero no importa. El tema es, tal cual está ese dibujo, yo me puedo conectar al router? ¿Tiene cerebro de transporte? Y no faltan esas capas. Ah, ok. Entonces no me puedo conectar al router. ¿No le puedo hacer nada más que a lo sumo un ping? Sí le puedo, por supuesto, tal cual está dibujado ahí, decirle, che, reenviame ese datagrama, haceme que estos datagramas fluyan. Si acá sale, te llega un datagrama en esta patita de la izquierda con destino al host que tenés a la derecha, perfecto, el tipo tiene el cerebro capa 3 como para decidir, preguntar, ah, tiene que salir por esa interfase y este ñato de la derecha es mi vecino, se lo entrego, lo descubro y plim, y terminó mi rol de este router como un elemento de capa 3 dentro de toda esta internet. Claro, necesitaría capa más alta para poder configurarlo, para poder... Claro, para poder de alguna manera, en comillas, conectarme al router, entrar al router, decirle, mirá, ahora te voy a cargar esto, te voy a configurar esta interfase nueva, te voy a dar de baja esta otra interfase, y para eso, si se quiere, para administrarlo al router, decirle capa administrativa al router, porque yo no voy a instalarle un web server al router, no voy a instalarle un motor de búsqueda al router. Como si podría instalarle este host y es suficientemente interesante su infraestructura, puedo instalarle un Apache, puedo instalarle un PHP, hacer aplicaciones, pero no es el objetivo si este router tuviera capas de más arriba, el objetivo sería que esas capas de más arriba me permitan administrarlo tal que yo la aplicación que usaría para hablar con el router, con estas que no están acá, sería un Secure Shell o algún tipo de interfaz Graphion, con UI, a través de HTTP, con alguna interfaz bonita para poder decirle al router, mirá, te prendo tal cosa, te apago tal otra, te agrego tal IP, te saco tal otra. Solamente quería declarar eso antes de lo que viene, porque es importante separarle estas vidas, no, serían estos roles al router, no para el rol que nosotros estamos pidiéndole ahora, el router alcanza con que tenga cerebro capa 3. El problema es cómo configuro ese cerebro capa 3, que es para buscar las capas de arriba para poder conectarme con el router, administrarlo al router. Sí. Entonces los routers de nuestra casa en realidad tienen hasta capas de aplicación, por ejemplo, que yo pueda entrar a configurar y todo. Recordemos que cuando hablamos de routers en nuestra casa estamos tirando el concepto, que es una caja que tiene, en realidad tiene un switch, porque atrás tiene unos puertos de Ethernet típicamente, cada vez hace de un switch virtual con la capa wireless, con lo cual provee en realidad servicios de capa de enlace en el 802.11 para lo que es wireless, pero además también tiene capacidad de routeo, tiene capacidad de NAT, tiene firewall y demás. Eso que está explicando Juanjo y que acaba de preguntar, creo que era Fernando, me parece que, no, Alejandro. Alejandro, me parece. Es muy buena pregunta y a su vez hace mucha referencia al por qué de esta materia. Y ustedes como ingenieros tienen que verlo, digamos. Muchos dispositivos que nosotros vemos empaquetados en algo hoy son la suma de un montón de funcionalidades que en definitiva están referenciados por estándares de cosas distintas. Que la mayoría de la gente diga, compré un router, y un poco el objetivo de esta parte que nosotros estamos mirando solo el routeo en IP, digamos, no estamos hablando del router que ustedes compraron y pusieron en la casa. Estamos hablando de la función de routeo. Es muy importante que ustedes identifiquen a dónde va la cuestión estándar. ¿Por qué? Porque en realidad todos los dispositivos actuales son extremadamente complejos y son sumas de piezas. Hoy yo puedo comprar un dispositivo y ese dispositivo trae hasta un filtro anti-spam y está en el borde de mi red y no puedo decir, ah, bueno, como está en el borde de la red, es un router. No, es un anti-spam. Es una cosa que está mirando cuestiones de capa de aplicación. Y ni sabemos las cosas que se van a inventar a futuro, pero está claro que los modelos de referencia van a seguir estando ahí. Yo solamente a modo de muestra, en realidad nosotros estamos siendo muy gentiles al decirle, tiene funcionalidad de reencaminamiento de router, pero si quiere un router que forma parte de, que está en un ISP, por ejemplo, no va a ser una cajita como esta que nosotros compramos. Es más parecido a esto, ¿sí? Que tiene muchas bocas, muchas interfaces. Es solamente como para traerlo un poco a la realidad. Es decir, es como que nuestro router, nuestro AP router y demás, como que tiene todo englobado esta funcionalidad. Y para responder a tu pregunta, sí tiene implementado hasta capa 7 porque si yo tengo las credenciales adecuadas, yo puedo abrir un navegador, conectarme a la interfaz administrativa de ese AP más router que tengo en casa y cambiarle cosas. Dependerá de tu ISP si te ha dado esa capacidad o no. Hay ISPs que te dan esa capacidad, te dicen "sí, acá te la pago el administrador" y podés entrar y ver los parámetros de trabajo, podés, lo típico que es mapear un puerto desde la IP pública que quizás tu ISP te esté dando hacia adentro para, qué sé yo, torrents o juegos que requieren que vos tengas presencia con una presencia externa. Entonces, para esa administratividad sí o sí, necesitas más arriba de esto. Más arriba de esto porque si no, no va. Te dejo acá para hacer trabajo, digo. Sí, sí, sí. Lo importante, y ahí va, no lo importante. En realidad es, yendo a la simpleza de... Una pestaña, esto. Bien. Los diseñadores, en general, esta diapositiva es un clásico. Ustedes tienen que entender que en redes, en general, está muy separado arquitecturalmente lo que son los sistemas finales de las comunicaciones a los que son los sistemas intermediarios. Pero esto es un patrón común en redes que se aplica incluso en muchas capas. Si yo les pregunto a ustedes, ¿cuál es el sistema final en una red celular y cuál es el sistema intermediario en una red celular? Si ustedes lo piensan dos minutos, dicen, no es lo mismo uno que otro. ¿Cuál es el end system en una red celular? El teléfono. El celular. Y quiénes, es decir, es una red peer-to-peer, digamos. Ustedes hablan de celular a celular o hay alguien en el medio? Una antena. Antenas. Por eso. En realidad vemos la antena como materialización, pero en realidad la antena son switches, son conmutadores de comunicaciones. La palabra switch, cuando nosotros decimos switch es un conmutador. Es un conmutador de comunicaciones. Si yo le dijera a ustedes, ¿se entiende, no? Que es distinto cuando uno hace una red, cómo es el dispositivo del end system y cómo es el sistema intermediario. ¿Se ve? Sí, sí. Incluso los diseñadores en IP fueron sumamente inteligentes en, y está repartido en todo el diseño de los protocolos que vamos a ver. Asumiendo que, algo que yo les pregunté a ustedes, ¿cada cuánto creen que se cambia uno y otro? Y a su vez, ¿de cuál hay mayor población? Los end systems son los que hay más y que se cambian más frecuentemente. Y bueno, después los intermediarios son los que duran más tiempo y como dijo hay menos. Ok. ¿Y quiénes son los que agregan, los que si yo quisiera agregar features, funcionalidades nuevas, tendría que actualizar? Probablemente. El end system. El end system, sí. Entonces no es menor esta decisión. Porque si ustedes la toman al revés es un lío. Si ustedes dicen, mira, yo voy a pensar, voy a hacer una tecnología, vamos a estar agradeando cada cosa nueva que hagamos, vamos a tener que tocar todos los sistemas intermediarios. Es algo que... Claro, por eso, pero desde el punto de vista del diseño, eso obliga a que ustedes digan, bueno, mirá, ok, lo que vamos a diseñar, hagamos que contemple la mayor cantidad de funcionalidades y sea lo más simple y eficaz, de manera que no tengamos que estar tocando de acá hasta N tiempo. Entonces, también un poco lo que le estaba mostrando Juanjo es, la verdad que la internet completa funcionaría igual, de hecho funciona igual, con el IP estándar, con el protocolo IP estándar que está escrito en los RFC hace 20 años, 40 años. Incluso la internet que usamos ahora. ¿Está bien? Y los end systems, piensen cómo cambiaron los end systems en la historia de la internet. Cómo era el end system de los 80 y cómo es el end system de hoy. Sí, no tienen punto de comparación. Ok, ok, ¿no? Y la función que realmente ha garantizado que eso ocurra es la que vamos a hablar ahora, que tiene que ver con, bueno, ¿qué es lo que hay que lograr hacer para que esto ande? Si yo le digo, bueno, listo, el protocolo IP, misión y esto es lo que quiero que resolvamos entre todos. La misión del protocolo IP es encaminar los datagramas, que es la palabra que le damos a los paquetes IP. ¿Cuál es el problema realmente? Yo tengo que encaminar el datagrama al destino y esto es lo que vamos a repetir 800 millones de veces. IP es un protocolo encargado de encaminar los datagramas al destino. Y eso, y acá está la otra regla que es valiosísima, es un problema que se resuelve salto a salto en una red IP. Esto ya se lo ha hecho varias metáforas Juanjo muchas veces. Es como si yo le dijera, che, tengo que pensar cómo hago. Yo les digo a ustedes hoy, es el mismo problema pensar cómo van a salir de sus casas para llegar hasta el Empire State de Nueva York. Le digo, mira, haceme, ¿cuál es el plan de todos los caminos que vas a hacer? A decir, che, andate al Empire State. Y usted diga, bueno, yo voy viviendo, salgo hasta el aeropuerto y en el aeropuerto pregunto. El mismo problema en complejidad. ¿Cuál creen que es salto a salto y cuál es el otro de punta a punta? El salto a salto es el mochilero. El mochilero. Bueno, es muy buena metáfora la del mochilero. Es buena metáfora. Es decir, IP a su vez, ¿cómo va a resolver ese problema? Lo va a resolver salto a salto. Es decir, se va a ir preguntando en cada... ¿Cuándo hay que preguntarse por dónde agarrar? Cada vez que presente qué. ¿Imaginen? Caminas distinto. Una bifurcación, es decir, che, yo llegué a un lugar y voy a... Y entonces hagamos lo que lo hacemos, nos vamos a ir manejando de acá a Nueva York. ¿Con qué se van a informar ustedes? ¿O qué van a ir haciendo para hacer eso? Creo que habíamos... Había dado el ejemplo de que vamos preguntando en cada esquina para dónde tenemos que doblar. Y si tuviéramos que usar un sistema de soporte e información que... Voy a traer... No voy a ir de acá a Lempareste, pero si le dijera, estamos acá en Mendoza y le vamos acá a Buenos Aires. Y ustedes van manejando. ¿Tienen que realmente preguntar o existe un sistema de soporte? GPS, bueno. No, bueno, olvídate del GPS. Los carteles. ¿Qué hay en los carteles en la ruta? Información. Indicadores. ¿De qué tipo? Distancias, ciudades. Es una información que ustedes dicen, ah, listo, yo llego al cruce, miro el cartel, ah, Buenos Aires para allá, listo, Buenos Aires para allá. Entonces yo estoy con el destino en la cabeza y cada vez que llega una bifurcación alguien me da un soporte para decidir para dónde voy. Ese sistema de calle así, ¿es global? ¿Funciona en todo el mundo o solamente anda acá, en Argentina? Global. Es decir, es un sistema de encaminamiento global. Evidentemente funciona, ¿o no? Sí, sí. ¿Y cómo funciona? Bueno, en la ruta, la ruta es un sistema de encaminamiento global. ¿Cómo funciona? Bueno, la ruta es un sistema de encaminamiento global. ¿Cómo funciona? Bueno, la ruta es un sistema de encaminamiento global. ¿Cómo funciona? Bueno, la ruta es un sistema de encaminamiento global. ¿Cómo funciona? Bueno, la ruta es un sistema de encaminamiento global. ¿En dónde cae esa decisión? ¿Quién tiene que tomarla? El router. Solo el router. Por ejemplo, acá nadie decide nada. Ni de los hosts, ¿no? Se ha enviado el mensaje y... ¿Y cómo lo envió? Porque el host también tiene que tomar una decisión. Pero el host es el que dice... Claro, entonces tenemos un algoritmo para los hosts, que es un algoritmo distinto al de los routers. ¿Por qué asumen ustedes? ¿Cómo sabe un host que no tiene que hablar con alguien que... Y a su vez, ¿qué va a hacer si no sabe? ¿Ustedes vieron? Hay una RFC para hosts y otra para routers. Son distintas. ¿Hola? No, no son distintas. Entonces... Bueno, no nos vamos hoy hasta que no hagamos el algoritmo. Así que empiecen a pensar porque yo voy a abrir la pizarra. Tenemos que resolver este problema. Digamos, el que no sabe, el que no sabe, el que no sabe. Pizarra, tenemos que resolver este problema. Digamos, el que no ha encomendado. No se puede ir nadie hoy sin escribir el algoritmo de ruteo de IP. Y el host indica cuál es el destino y... No, no, no, no, pero eso lo dice un brujo. Yo quiero un algoritmo. ¿Qué hace un algoritmo? ¿Cuál es la definición de algoritmo? Pizarra nueva... Puedo seleccionar una de drive, me dice acá. Recientes. A ver si me deja abrir una pizarra reciente. Hacemos una pizarra nueva. Uy, esta está más fiera. Voy a hacer una nueva, me parece. Está escrita a mano. La voy a hacer nueva. Pizarra... Abrir una jam. Nueva pizarra. Voy a compartir mi pantalla. Compartimos con todos. Confírmenme que estamos viendo lo mismo. No me dejes que haga cuchinada, Juanjo. Haceme que escriba bien. Así no sirve después. Voy a buscar la pizca. Por las dudas en la presentación no se ve en el mil, digamos. Ok, ahora ya les voy a prestar mi pantalla completa. Sí, esa estaría buena porque si no, como para seguir lo que se va haciendo. Toda mi pantalla. A ver ahí. Pero antes de hacer eso, tengo que apagar todos los mensajeros que tengo prendido en mi máquina. No me vaya a molestar nadie. Ahí está. Ok. Confírmenme que vemos lo mismo. Ahí está. Sí, perfecto. Se ve todas tus pantallas. Ok. Bueno, entonces lo que estábamos hablando es que... Y un poco lo que queremos construir con ustedes. Ya hemos dado algunos lineamientos. Sabemos que existen sistemas finales y existen sistemas intermediarios. Una ayudita es... No es la misma la tarea... Fíjense que ahí en la diapos está declarado que la... La misión del ruteo está como dividida en dos funciones. Una es el encaminamiento, es la decisión por dónde ir. Y otra es el reenvío. Es decir, un router le llega a un paquete, en este caso por ejemplo, le llega en este caso y decide, le llega a un paquete, toma la decisión y dice "Ah, este lo tengo que mandar para allá". Lo reenvía. Y esa es prácticamente la función que diferencia a un host de un router. El host no reenvía paquetes, no recibe paquetes que no son para él y decide mandarlos para otro lado. Tiene sus paquetes, pero también tiene decisión de ruteo, tiene que decidir por dónde mandarlo. Es decir, que el problema de ruteo es el mismo para un host que para un router. Es más, lo que nos han encargado es que hagamos un algoritmo que banque las dos funciones. ¿Me explicó? Sí, bro. Entonces quiero que pensemos por dos minutos, si esto es un algoritmo, ¿qué tienen los algoritmos? Pasos a seguir. Una sucesión de pasos ordenados que cumplen una tarea. ¿Y qué más tiene? Andan solos. Digo, algoritmo es porque hace un programa. Les pregunto a ustedes, el router, ¿cómo toma la decisión? Está en un chip. ¿Dónde está la decisión? Analiza variables. Pero les pregunto a ustedes, ¿no creen que está corriendo un programa, un router? Sí, tiene. Tiene un software. ¿Tiene sistema operativo el router? Sí. Y ya vimos, ya hablamos de esto. El sistema IP, el protocolo IP. Es del sistema operativo. Es parte del sistema operativo. Es decir, que así como toma decisiones de cargar algo en la memoria y moverlo de un lado para el otro, tiene que tomar decisiones de red, el sistema operativo. Sí. Entonces estamos hablando que alguien programó lo que los diseñadores del protocolo IP pensaron, que dijeron, mirá, encaminamiento, salto a salto, para, pa, pa, pa, pero después hay que programarlo. En realidad, ¿ustedes saben cómo son la historia de los RFC? Los deben haber visto en algún lado. ¿Saben lo que es un RFC? Creo que no. Ah, no lo vieron en ningún lado. Bueno, la Internet completa está basada en estándares, ¿sí? Que están numerados, y esos estándares en el mundo de la filosofía de Internet se llaman RFC. Que en realidad RFC es "Request for Comment". Es decir, alguien se levanta hoy y dice, "Che, tengo una idea", y escribe. Con una etiqueta, con un formato, dice, "Che, mi idea es esta". "Miren, busquemos la RFC IP, RFC 791". ¿Quién la hizo esta? ¿Dio? "Ah, ¿quién hizo esta RFC?" Un ingeniero. ¿Ah? "Information Science Institute, University of Southern California, ti, ti, ti, ti". Entonces dice, "Casi todas las RFC son iguales, por eso es importante aprender a escribir". Como estamos tratando de hacer. "Miren la fecha, septiembre de 1981". Esto es como si fuera un apóstol para nosotros. John Postel, este flaco, no solamente hizo esto. Hizo el sistema de nombre de dominio, por ejemplo. Escribió la RFC esta, la IP, e hizo el sistema DNS. Entienden lo que es el DNS, ¿no? Esa piecita que hace que usted ponga "W, WB, WM, WB" y no tenga que estar pensando en IP. Sí. Bueno, ¿cómo hizo? Él escribió esto. En realidad, lo que iba a decir es, "Los RFC tienen una descripción". "Ti, ti, ti". Esto dice, "La IP describe muchas de las cosas que nosotros les estamos contando a ustedes". Las capas, van a ver. Les aseguro que es una buena práctica leer RFC. Acá es donde la primera vez que se habló de lo que era un gateway. Acá habla de muchas de las cosas que estamos hablando nosotros ahora. Esto es algo que vamos a ver en la clase que viene, como es el datagrama IP. Tuxi, las opciones, Sara, PP, papá. Y las RFC se acompañan con código funcionando. Con una implementación. "A mí me parece que habría que hacer..." No, no, pará. "Voy a hacer la RFC y me escribiré un pedacito de código que muestre la prueba de concepto de lo que está hablando". ¿Está bien? Que es un poco lo que le estamos tratando de pedir. Estamos pidiendo un algoritmo, no nos vamos a poner a escribir algo de código en C, o en Java, o en lo que les guste. Por eso el mundo de Internet funcionó. Porque no es un mundo de gente que, "A mí me parece, y la norma, y la revisa, otro es..." En realidad, alguien pensó algo, construye una implementación con una prueba de concepto, se mejora, y si todos están de acuerdo, yo chiste a prueba. De esto va como va, la usémoslo. Poner el número, 791, chau. Sale. Todo tiene RFC. Miren. Esta es la RFC de HTTP. Si ustedes mañana quieren hacer un web server, rellen esto y construyen un web server. Porque si yo tengo que hacer que todo el HTTP, listo, acá están los verbos, los métodos. Todo tiene RFC. Por eso nosotros, quizás, hemos asumido mal, que ustedes entendían. Van a ver que cada protocolo que veamos tiene la referencia al RFC. El RFC es, alguien escribió la idea, especificó la funcionalidad, construyó una implementación funcional con código funcional, y bueno, los mecanismos que tiene la Internet Society, que sería el contenedor de todo esto, que en realidad la parte que hace todas estas cosas se llama la... La IEEE. No, no es la IEEE, es la Internet Task Force, la ITF, que es la que tiene organizados los grupos, que son los que evalúan las RFC, y hay grupos sobre temas distintos. Pero cualquier persona puede proponer una RFC, en realidad no termina, en realidad tiene un nombre previo a hacer una RFC, pero cuando alcanza el nivel de acuerdo suficiente de un grupo, que es totalmente distribuido, no está centralizado, se aprueba una RFC. Y después alguien dice "che, mirá, yo quiero hacer algo que soporte IP". Bueno, lo único que tengo que hacer es implementar lo que dice la RFC. Y si lo voy a hacer en un sistema operativo nuevo, o voy a programar un tubo fluorescente que soporte IP, o una licuadora que ande IP, bueno, la puedo programar, mientras respete la RFC, yo sé que va a hablar con cualquier otra cosa que respete la RFC. Así es el mundo de la ingeniería en general, y ustedes tienen que ser bastante puristas con los estándares. Cada vez que construyan algo, primero no inventen la rueda de cero, sino que refieran a un estándar, porque los estándares empoderan las cosas que construyen. Si usted dice "no, yo hice mi propio algoritmo, yo estoy seguro que es muy seguro, porque lo pensé muy bien, pero ¿y qué estándar tiene? No, no, no, el mío es muy bueno, pero le hice eso". Bueno, seguramente están en una, no invalida que se les pueda haber ocurrido algo bueno, pero probablemente muchas cosas ya están, y sea mucho más valioso que las soporten con un estándar, sino tienen que defender con su espalda, y no es lo mismo. En ingeniería, mucho de lo que nos da sustento son los estándares, y es importante saber cuáles son los estándares de las ramas de las cosas que hacemos. No sé si me explico. Para que usted sepa, JWT, que lo deben haber visto en algún lado, ¿saben lo que es un JWT? Sí, sí, sí. Bueno, tiene una RFC. Yo solamente quería hacer un plug respecto de un par de cosas, respecto de la naturaleza abierta de los estándares, y que básicamente el Internet no sería lo que es hoy, si esto lo hubieran agarrado los que hicieron los protocolos anteriores, para los cuales tenían que pagarnos, no sé, mil dólares, para recibir la especificación, no participaba, era como estaban entregados por alguna entidad supernatural y bajaba el estándar, ¿no? Versus esto, las RFCs, hasta el mismo nombre, "Request for Comments", no es "This is the law", esta es la ley. Y si ustedes lo piensan, es importante la comparación porque para el momento de tiempo que estábamos hablando, años 80, todos los otros protocolos de comunicación eran básicamente desarrollados por comité, por entidades, así de poca gente, bajo control, que escupían especificaciones de protocolos para implementarlos. Fíjense, la naturaleza abierta de los estándares permitió al Internet ser lo que es hoy. Y si uno lo ve quizás de una forma más expansiva, y lo comparamos con las APIs hoy, las APIs más abiertas y con más cantidad de usuarios también a la vez, son aquellas que crean ecosistemas enteros. Cuando digo APIs abiertas, por ejemplo, no sé, vos querés autenticar a un usuario y no querés vos hacerte cargo de crearle la clásica, otra vez se tiene que acordar del usuario y password, o sea, enlazar con autenticación contra Facebook, o contra Google, o contra Twitter, o contra GitHub, entonces yo voy a consumir esas APIs, que no han sido desarrolladas de una manera abierta, eso sí hay que admitir, pero que están de facto abiertas, expuestas, para que se usen. Y que yo, como consumidor de esas reglas, estoy cambiando muy violentamente la altura en el stack donde estoy, pero lo que quiero resaltar es que APIs que son visibles, o especificaciones que involucran protocolos que son visibles, que son abiertas, crean ecosistemas enteros alrededor de eso. Y eso que ocurrió con todo el stack de CPIP, lo podríamos comparar un poco con las APIs también. ¿Qué es lo que está pasando con las APIs? Nada, una acotación. Bueno, tomamos esta derivación porque estábamos hablando de... Imagínense que acabamos de escribir la RFC, tenemos que decir cómo es el algoritmo para que esto rutee. Y estábamos haciendo el viaje, les decía yo, si yo tengo que hacer un algoritmo, una serie de pasos, ¿esos pasos sobre qué trabajan? ¿Sobre el sistema operativo del router? Bien, perdón, me fui a la definición del algoritmo, eso va a correr en el router, va a ser un programa, el algoritmo codificado en un lenguaje se transforma en un programa. Este algoritmo, ¿el algoritmo con qué trabaja? Pasos que hacen, ¿con qué? Solo toma decisiones sin ninguna... ¿qué? No, tiene que tomar los datagramas. Ok, pero justamente estamos haciendo la pieza que tiene que resolver la decisión de ruteo. Que camina, ¿no? Sí, recibe información de los demás caminos. Pero, para, por eso, pero vamos a identifiquemos el problema. ¿De dónde va a sacar? Es decir, ¿qué es lo que recibe como para tomar la decisión? Alguien dijo ahí. Y yo les dije, el ruteo se decide por el destino. ¿Qué es lo que tiene que mirar? Tiene que mirar el destino del datagrama. Bien, es decir, que yo tengo como entrada de este algoritmo, la decisión de ruteo la va a tomar mirando, ¿qué cosa? El campo de la IP. La IP del destino de un datagrama. Ok. Entonces, tengo un... voy a poner por acá. A ver cómo que puedo escribir. Con este puedo escribir. Si yo dijera, bueno, ¿cuáles son los datos? Del algoritmo. La IP del destino. Bien. Yo acá tengo IP destino. ¿Sí? También tiene que mirar la cantidad de saltos que lleva ese datagrama para decir si se logra o no. ¿Por qué? Porque después de qué cantidad de saltos no lo descarta. Bueno, pero estamos... eso para alguien que construye la solución de un problema de la manera que yo razono es un problema para después. Primero tengo que hacer que rutee, después veamos las optimizaciones. No digo que no esté mal. Sí, no solo optimización sino validación de input. ¿Qué pasa si viene fruta, si viene verdura en esa dirección IP destino? Porque no todos los... si yo te doy una secuencia random de bits y se lo pego a una dirección IP, no todas las direcciones IP son válidas per se. Entonces, es un proceso incremental, ¿no? Vamos a lo fundamental que es cómo implementamos el ruteo y después lo vamos perfeccionando. No sé, supongamos que la IP destino es 120. Eso es datos. Sí, la verdad que a mí me llega un datagrama y le miro el destino. Ahora, ¿con qué creen que se toma la decisión? Hay algo más que es información que yo... Imaginémonos que estamos en el host, en un host inicialmente o lo que sea. ¿Hay alguna información que yo tengo que usar adicional para devaluar esto? La red a la que pertenezco. Bueno, llamémosle configuración. Yo tengo configuración. Digamos que tengo una placa, ¿no? Como vimos el otro día, tengo la placa Ethernet 0 y yo estoy en la red 192. Yo soy 200, no sé. 20. Y mi máscara es /24. Esto es contexto, digamos. Resulta que a mí me llevo un datagrama que dice que va a la IP 120 y yo soy 220/24. ¿Qué hacemos? Y primero, ¿no podría ver si la IP destino está en mi misma red? A ver. ¿Cuál sería la primera pregunta? Si yo les pregunto que tenemos este dibujo y les digo "hagamos un dibujito acá de..." A ver si dibujo. Habría que ver a quién estoy conectado físicamente. Bueno, pero acá ya tenés esa información. ¿Quién sos acá? Si yo les digo "hagamos un dibujo de esto". Y es un host. Este es un host, que es el... El 220. No quiero arruinar porque después me da vergüenza mis dibujos y los veo y digo "me mata el Parkinson". Con respecto a la gente que tenga Parkinson, pero... A ver una forma. Bueno, ahí está. Esto si lo veo así, este es el host. ¿Qué le pongo acá abajo? 200.20/24. ¿Por qué hace esto? ¿Por qué hace esto? ¿Orden? No me deja... Ah, mira vos. Si lo ensancho, después lo puedo achicar. ¿Está bien este IP? 2200. Ahí. Si partimos de más o menos de este escenario, yo les pregunto. Si este flaco es el 220/24 y por alguna razón necesita hablar, ¿con quién quiere hablar como destino? Con el 120. 120. Así a simple vista. ¿Qué pasa con el 120? No están lo mismo, ¿verdad? No es destino. Entonces, si yo le estuviera que decir "che mira, esto anda, en realidad hemos armado las cosas para que anda". ¿Qué le faltaría a este esquema? ¿Qué debe haber acá? Un router. Bien. A ver, vamos a hacerlo con un rectángulo. Acá probablemente tenga que haber un router. Voy a hacer... Si este host confía que este router le puede dar una mano para llegar al destino, ¿cómo es este host? ¿Qué tiene que ser? Vecino. ¿Y qué sería que sea vecino en el mundo IP? Que tenga la misma manga. Que tenga un barra 24 nomás. Y ustedes dijeron la misma máscara. Y tiene que estar conectado físicamente para algún medio. ¿Y qué más? Si, tiene que estar conectado de alguna forma, ¿y qué más? ¿No había una manera? Creo que era un OR con los bits, la máscara. No, no, no. Sí, sí. A ver, lo que estamos es... Estoy tratando de dibujar cómo es si esto anda. Yo le dije "bueno, partamos del supuesto que esto anda". Pero acá faltaría alguna data de cómo es que el router es vecino. ¿Qué debería compartir con el 220? Y hasta el 200 debería tener la misma data. El router es el 201/24. Y tiene este IP. De alguna manera está alcanzable con este. Y como bien dijo alguien ahí, estos dos... Mirá, no hace rayas esto. ¿Ahora hay rayas? Serían los primeros 24 bits. Claro, claro. Acá el prefijo de red igual. Y a su vez esto está, como alguien dijo, está conectado. Este está conectado con este. ¿El 220 podemos asegurar que está de este lado o puede estar...? No, puede estar... O sea, el 120 tal vez puede tener tres routers en el medio hasta llegar. Bueno, hagámonos una ilusión de que no sabemos. Muy bien. Por ahora digamos que hay dos. Así como para completar el dibujo y que tengamos una idea en la cabeza. ¿Me explico? Vamos a suponer que hay dos routers. Y acá está. Son muy parecidos los números. Bueno, no les jode que sean parecidos. Resulta que el 120 está acá. ¿Y qué podríamos aseverar respecto del 120? Este es un router, ¿sí? Tiene que ser un router. ¿Qué pertenece también a la misma red? Acá también debería tener algo que sea de su misma red. Es decir, acá es 101. 101. 101. Vamos a tirar una rayita. Y ya que estamos. Vamos a suponer que esto está así directamente. ¿Qué hay acá? Si estos dos routers están conectados y son vecinos, ¿qué debería haber ahí también? También deberían pertenecer a la misma red. A la red 100 o a la red 200. No, puede pertenecer a otra. A una pública. Bueno, por ahora no quiero meter la internet para no quemar la cabeza. Debería haber una red cualquiera. 10.10.1/24. Tiene un IP de este lado. Y si este router es vecino a este, de este lado, tiene que tener un IP de la misma red. Por lo que hemos ido definiendo hasta acá. Es decir, que esto puede ser así, por ejemplo. ¿Se entiende? Sí, profesor. Perfecto. Yo tengo una duda. No entendí bien esto del medio. Con los 10.10.1/24. O sea, en el medio habría una red. Y lo que pasa es que si nosotros estamos haciendo este esquemático a nivel IP. Y dijimos, mirá, este router va a ser vecino a este. Y están conectados. Si nosotros aspiramos a que esto se comporte así. Ellos deben ser miembro de la misma red. Por lo tanto, le ponemos direcciones IP que puedan ser alcanzables para gente que son vecinos entre sí. Esta es una red IP que es distinta a esta. Por eso hay un router. Si fuera la misma red, este router no tendría sentido. Claro. Sería un switch. Por eso, piensen que ahora, cuando empezamos a dibujar cosas y ponemos conectores. Yo tendría que haber puesto unas nubecitas, pero no tengo nubecitas acá. Normalmente en IP lo que hacemos es dibujar. Cuando hay una red, ponemos una nube. Dibujamos los hosts, dibujamos los sistemas intermediarios. Y después la IP. Porque a nosotros lo único que nos importa es eso. Las capas que hay abajo, ustedes no van a ver nunca más qué capa hay de red abajo. Ustedes ni saben la capa de red que hay entre ustedes y yo ahora en este momento. Y no tiene ni sentido que la conozcan. Que lo resuelvan la gente que hace infraestructura de esa capa. El problema acá es la capa de ruteo para arriba. No sé si me explico. Y a su vez, para que ustedes, fíjense, se aferren a los conceptos. Ya van a ver que si yo a ustedes los parara. Y un poco de las disciplinas que creemos que adquieran. Si yo a ustedes los paro adentro de este router. Que listen las interfaces de red. Y ustedes dicen, ah mira, este tiene esta IP, esta IP. Los meto en este router, ven esta IP y esta IP. Y los pongo en este host. Y después los pongo en este otro host. Me tienen que poder dibujar la red. O se la tienen que poder figurar. Eso es lo que hace un ingeniero de redes. Yo ni conozco. Yo sé, por ejemplo, perfectamente cómo es la estructura de red. De casi todos los lugares con los que trabajo. Pero porque vi las IP de los aparatos. Y es más, si yo estoy parado en este equipo que está acá. ¿Sí? Y sé que su puerta de enlace es esta. Yo asumo que acá hay un router. Y chau, y lo dibujo. No tengo por qué preguntar mucho más. No sé si me explico. Lo que hicimos recién igual, entre todos, fue, fíjense, hemos hecho un supuesto. Esto es una pequeña internet para nosotros. Y esto es algo que la otra vez salió en los diarios y se terminó confirmando. Esto es una in-internet. Así. No es la, la internet. Ustedes saben que esto es distinto. Esto es muy distinto. Por lo menos para nosotros. Si ustedes nos escriben, che dice internet con minúscula. Bueno, esto es una redcita que hiciste. Esto es algo que usa los protocolos IP y camina. La internet con mayucla es la internet. La que usamos todos los días. Es como si esto fuera un sustantivo propio. ¿Se llamaban eso? ¿Sustantivo propio? Sí. Por eso. Y este es un sustantivo común. ¿Está bien? Esto es una internet. Por definición, ¿cuándo hay internet? Cuando hay más de una red IP, hay una internet. Acá hay una red IP y acá hay otra red IP. Esto es una internet. Eso es lo que definió la palabra internet. Hay una interrelación en redes. Esto es una internet. Y el principio funcional de una internet es el que mueve a la internet real. Así que no hacen falta muchos más conceptos. Esto es bien de ingeniería de la que nos gusta a todos, los ingenieros. Che, si yo hago algo y esto verifica que hace andar esto, no importa si después hay mil de esto en el medio. Tiene que andar. Entonces nuestro algoritmo, si resuelve este problema, va a resolver el de la internet con mayúscula. Es más, adelantándome, ¿qué cambiaría esto si esto fuera internet real? Si esto fuera internet de verdad entera. ¿Qué cambiaría en esto? La cantidad. Pero aparte de la cantidad, ¿qué no es un problema? Para un algoritmo no debería ser un problema la cantidad. Que hay redes públicas y privadas. ¿Qué cambia? ¿Qué cambia entonces? ¿El valor de qué? De la IP. Esto cambia nomás. Y como esto es un algoritmo, cambia un dato de un algoritmo. No cambia el algoritmo. ¿O no? Sí. Bien. Bueno, tenemos que escribir el algoritmo. Entonces, somos acá. Estamos en el 220 y resulta que nos llegó un paquete para el 120. Tratemos de tirar unas líneas de código de cómo resolveríamos este problema. Algo fueron diciendo recién. ¿Qué es lo primero que miraríamos? Que sean de la misma red. ¿O no? A ver. Tipo, "if ip destino" es la operación que habíamos hablado con el orco en los bits. Y Ethernet, para saber si están en la misma red. Me la re compliqué. A ver, a ver, a ver, dale, dale, dale, a ver. Pásamelo en limpio. ¿Cómo, cómo? En realidad lo que él está comentando es la primitiva del problema. ¿Qué es lo primero que tenemos que saber? Saber si están en la misma red. La IP destino. Claro. ¿Por qué? Entonces, llamémosle, tenemos que hacer una función. ¿Quieren que le llamemos? La función vecino. Bueno. Es un predicado, es decir, es lo que dice el ES. Si es vecino o no es vecino. ¿Y qué datos lleva la función vecino? La IP destino. IP destino. ¿Y qué es lo que le miramos a esta función? La máscara, las máscaras. Están usando la... ¿Qué hay que comparar? Algo que lo dijo alguien recién. ¿Qué es lo que compararíamos? Y el OR de la máscara con la IP de cada uno. ¿El OR? Si hacemos el OR de esto, ¿qué va a dar? Debería dar el /24, 11111, para que sea... no. ¿Qué hay que ver? ¿El OR no me sirve? ¿Qué es lo que me sirve? XOR. Pero... Pensemos en la operación binaria, pensemos luego. Claro, eso. Pensemos luego para que lo hagamos. ¿Qué es lo que tenemos que comparar? ¿Qué es lo que tenemos que comparar? ¿Qué es lo que tenemos que comparar? ¿Qué es lo que tenemos que comparar? ¿Qué es lo que tenemos que comparar? ¿Qué es lo que tenemos que comparar? ¿Qué es lo que tenemos que comparar? ¿Qué es lo que tenemos que comparar? ¿Qué es lo que tenemos que comparar? ¿Qué es lo que tenemos que comparar? La pregunta es ¿Cuál es la operación? Imaginando que acá hay una operación Esta es la operación, AND, ORG, SOR, lo que fuera ¿Y cuál es el acá el operando? Es decir, ¿contra qué lo tengo que comparar? Vemos la primera línea nada más ¿Cómo se ve la H? Ah, para, probablemente tengo que salirme Ahí está, sí, ahí va Ahí está Ahí tiene que poner unos ¿Dónde tengo que poner unos? Donde apoche la flechita ¿Es un AND, es un ORG? Es un AND Un AND ¿Por qué un AND? Porque si hay, como dijeron, el operando tiene todos unos en la flechita Cada vez que haya un cero, va a haber un cero Entonces va a quedar igual la edición de arriba ¿Y quién es el operando? Esa es la pregunta En IP, si ustedes quisieran hacer eso en IP No, no, para, completemos el problema binario Tírenme cuál sería el operando acá Ah, ok, el número Voy a separarlo, disculpen, esperen un cacito Son nada más dos ristras de 8 bits Vamos a hacer simple, son nada más que 16 bits Ahí va ¿Cuál sería el operando acá que me daría como resultado lo que tengo abajo? Bueno, cualquiera de 8 bits Cualquiera, yo pongo AND contra 1, 0, 0, 1, 1, 1, como cualquiera Si querés esto lo mismo que la primera parte de arriba Quiero los primeros 8 bits Yo quiero ver acá el resultado Yo quiero que aparezcan los primeros 8 bits Los voy a copiar para que sea más explícito Ustedes no están viendo, pero ya lo verán apenas ahora Yo quiero esto como resultado Y los voy a highlightear, a ver si puedo highlightear Bueno, no importa, se lee bien Entonces, obviamente lo operando está mal Lo que yo quiero es que ustedes me arreglen el operando ¿Cuál es el operando que a mí me desenmascarra nada más que esos primeros 8 bits? Y tengo que poner, los últimos 8 en este caso serían ceros y después todos 1 Bien, ok Algo así más o menos Bien, perfecto, buenísimo Y ahora sí, si lo traemos al mundo IP, ¿cómo mapeamos esos conceptos? ¿Cuál es el primer operando y cuál es el segundo operando? El primero, el de arriba, sería la IP y el de abajo, la máscara ¿La máscara de qué manera? Por ejemplo, ¿esta máscara de cuánto sería, más allá de que no tiene 32 bits? ¿Cuánto sería la máscara de la IP? Por ejemplo, ¿esta máscara de cuánto sería, más allá de que no tiene 32 bits? ¿Sería un barra cuánto esto? Un barra 24, porque tiene los últimos 8 en cero Está bien, completarlos hacia la derecha, no hacia la izquierda Imagínate que acá yo me hubiera tomado el trabajo de ponerle dos octetos atrás a todo, a las tres líneas Un barra 8 ¿Y por qué 8? ¿Cuál es el elemento del cual vemos 8 en la pantalla? Los primeros 8 a 1 Ok, ahí vamos Quiere decir que yo ese número que es decimal, 8, 16, 24, son los simples, o 10 o 12 Lo tengo que mapear en una ristra de unos para poder hacer esta operación binaria Nuevamente, porque queremos comparar los prefijos Quiero "filtrar" entre comillas y comparar el resultado de ese filtro El segundo operando el AND lo estoy usando como un filtro Lo estoy usando para decirle "mostrame nada más que los primeros bits, x cantidad de bits" Porque yo quiero comparar los primeros x cantidad de bits ¿Eso qué permitiría calcular? Que es lo que acaba de decir Juanjo ¿Qué es lo que les daría? Entra uno en la misma red con el prefijo de resultado No, no, no, eso no les va a decir, eso lo único que va a dar es el prefijo Lo que hay que hacer con la IP destino y la IP origen Para saber si es destino Y habría que hacer esta cuenta para las dos IPs y después comparar que los resultados son iguales Bien, ok, entonces nosotros tenemos que hacer Esto lo puedo dejar acá Está buena la cuentita No te molesta que lo corra y lo entiende No, porfis, dale, claro Bien, entonces tendría que decir, si la IP source AND, ¿qué cosa de la IP source? Supongamos que esto es, a ver, supongamos que IP source y IP destino ¿Cómo tendríamos que hacer si tiene varios atributos? ¿Qué deberíamos hacer con esto? IP destino podríamos, o sea, separar la marca Mirá, este es IP destino, esta es la IP, sub IP Que es todo lo que tengo, ¿no? Y mi IP origen en realidad tiene IP source, IP, es la IP ¿Qué otro atributo tengo yo que se dé esta? IP source, máscara o máscara Ah, máscara Me parece que tienen mis apuntes del año pasado ustedes Me parece Ok, ¿qué otro atributo tengo que tener? Nada más Prefijo, ah, no sé Por eso no, porque el prefijo lo hago con esto, entonces yo digo, bueno, si la IP source IP AND, la IP source ¿Qué? Máscara ¿Es igual a qué? A IP destino No, al prefijo Por eso, ¿cómo calculo el prefijo? Yo tengo que mirar, ¿cómo determinaría si 200, 100 entre 220 no es vecino a 220? Yo acá pongo la IP destino, IP AND qué? La IP, la máscara de la IP La misma La misma máscara que es mía, es decir, IP source, máscara Si esto es igual, hagamos esta operación con estos dos datos, ¿qué haría esto? Uno daría IP source, IP más, ¿qué número me quedaría? Con la cuenta que le mostró Juanjo acá, ¿qué número me quedaría? 192.168 No, no para ahí No, pero con los datos que tengo aquí 200 Y ahí no para, porque nos hemos recortado, no hemos hecho ninguna operación para el ¿Es igual a qué? Y si fuera, estaría en la misma red, exactamente lo mismo No, no, no, no, quiero que vean los datos que hay ahí, tienen el algoritmo 100.0 Es decir que, esto va a dar, este caso va a dar falso, ¿no? Falso, sí Supónganse que en vez de tratar de hablar con la 100.200, yo trato de hablar con la 202, si hago esta cuenta, ¿cómo va a dar esto? True 200, 200, acá, es decir que este predicado que he creado acá, más o menos mira si es vecino o no es vecino en base a mis datos de configuración, ¿o no? Sí, exacto ¿Sí o no? Sí ¿Sí? Ok, entonces, si esto es verdadero, le voy a decir que retorne verdadero Verdadero ¿Qué va a retornar esto? Es un predicado, digamos, estoy haciendo un... Falso Falso Ok A ver, esto me va a dejar achicar la letra ya Ok Bien, acá tengo la función vecino, entonces, la función vecino me calcula si alguien es vecino o no es vecino ¿Cómo la vamos a usar? ¿Qué tendría que hacer yo entonces ahora? Con esta... he creado un predicado que me resuelve si alguien es vecino o no es vecino Y otro if, que diría si if vecino is true, ahí resolvería que está dentro de la red, de su misma red, digamos Bien, digamos entonces, por ejemplo, arranca el algoritmo acá y dice, bueno, si vecino, ¿qué le tengo que pasar? Las ips ip source, ip destino Si este es verdadero, ¿qué hago? Le envío el... ¿Qué pasa? ¿Cómo lo mando, por correo? ¿Cómo hago? Por el puerto que esté conectado No, por eso, pero... muchachos, por eso le hice el dibujito para referenciar algo concreto Si alguien es vecino, por ejemplo, del 202, ¿qué tengo que hacer? Lo manda al gateway ¿Cómo? ¿Si es vecino mío? No, el gateway lo mandás cuando no es vecino tuyo A ver Pero, o sea, si están conectados a un switch, ¿se los tengo que mandar así o así al switch? ¿Cómo tienen quemada la cabeza con los switches? La verdad es que tienen un desastre en la cabeza Tienen un desastre con los switches en la cabeza El switch... a ver Supongamos que esto es una red Ethernet, ¿no? Que ustedes ven al switch, ven que... Ustedes generan los bits y van al switch, pero en realidad ustedes están hablando en Ethernet ¿Cómo contactan? Es decir, este es vecino El cable va al switch, pero... Si no tienen un problema en la cabeza severo, muy severo, de lo que es una red de conmutación de paquetes ¿Ustedes escriben en el cable la dirección física del switch? Si él es vecino Eso me parece que no lo tienen bien en la cabeza Me parece que hay algunos de ustedes que no lo tienen bien en la cabeza o lo tienen... Porque siempre meten al switch El switch es el aparato que está ahí y es con el que tienen el cable, punto ¿Con quién hablan ustedes cuando hablan con los vecinos? Con el vecino ¿Cómo? Por el cable El cable es la capa 1, y esta es la capa 3, nos falta una en el medio ¿Con quién hablan? Con la Mac Con la Mac... 800 millones de veces hemos hablado de la... Todo esto, evidentemente, son cosas que siempre cuesta masajearla Cuando ustedes escriben una trama Ethernet Es decir, este es vecino, listo, el flaco está en la misma cacerola de red mía Lo próximo que tengo que hacer es... Encontrar... Yo qué tengo de mi vecino Y su máscara te va a encontrar La máscara, no, si soy vecino mío Tengo que... ¿Quién dijo? La Mac Tengo que, con la IP que tengo, preguntar quién tiene esa máscara y después colocarle el zapado No, la máscara ya la tienen la misma, si ya dijimos que son vecinos Yo ya dije que es vecino Como él está en mi cacerola de red, no sé su Mac Pero yo tengo que escribir, yo después de eso escribo una trama Ethernet y pongo la Mac de él Y no sé si hay un switch, un hub, no me calienta, eso no lo sabe un host ni un dispositivo ¿Ustedes realmente creen que su computadora es consciente de que existe un switch al medio? No, no entiendo Entonces dejen de decir que va al switch, el switch es un intermediario Cuando hablen de Ethernet y de K2, el destinatario es la Mac destino No digan que es el switch, porque si no yo tendría que escribir la Mac del switch En K1 su máquina está conectada al switch Ustedes tienen un cable al switch, o tienen una conexión wifi a la AP Pero el destino de la trama es la Mac destino Es muy importante que todos confirmen que entienden lo que les estoy diciendo Si, profe O sea, independientemente de lo que hagan en el medio, podemos decir que el destino de la trama está fijado por la Mac Claro, porque si no están confundiendo el destino con el intermediario, no sé si me entienden El switch es un intermediate system de K2 El problema que les conté recién, de los end system y los intermediate system En K2 los end system son hosts y los intermediate system son routers En K2 los end system son Macs, son placas Y los sistemas intermediarios son los que intercambian las cosas entre esas Macs Que sea más o menos inteligente, yo les hago una pregunta ¿Cambia la vida en una red si ustedes ponen un hub o un switch? No ¿Cambia la vida si yo estoy cableado y ustedes están wifi y somos la misma red? Es decir, ustedes están enchufados al router de su casa y yo estoy wifi en su casa No, no es lo mismo Puedo hacer una pregunta, capaz me da tonta, pero, ¿quién digamos, si digamos, está en la misma red Ya no veo IP destino, si no voy a ver Mac de destino ¿Quién hace ese cambio de datagrama de K3 a trama de K2? Bueno, es muy buena la pregunta Es muy buena la pregunta y es buena y oportuna porque tenemos que, esto tenemos que ahora coserlo todo en la cabeza No se sientan ajenos, porque siempre llegamos a este lugar con toda la gente que llega hasta acá Y siempre hay una, porque realmente nunca se integra, no es un problema Él pregunta, y alguien quería hacer una cotación, no sé quién iba a proponer la respuesta Sí, yo, pero bueno, no importa, lo dejo que haga Bueno, dale, reformula la pregunta que tenía y la conversamos No, creo que lo que está preguntando mi compañero, o sea, la respuesta sería que si mi host ya sabe a quién le corresponde esa IP Ya él directamente en la siguiente capa, cuando crea la trama, coloca la máscara Si no lo sabe, tiene que hacer una inundación preguntando de quién es Y después, cuando ese host se auto-identifique, le va a responder con su máscara y ahí va a armar la trama y se lo anula Sin malos recuerdos, protocolo ARP, ¿no? Bien, correcto, así se llaman todas las piezas, pero acá hay una cosita que es una de las primeras cosas que uno tiene que entender Y por eso que las capas, cuando uno va bajando de capa, cada capa le agrega información a lo que va a mover en el cable Para que funcione el destino de cada capa, esto lo tienen que haber visto Y si no lo vieron, dese la página 10 del libro de Stalin en redes Y si no han visto el libro de Stalin, estamos en problema, el libro de comunicaciones de datos Cuando ustedes tienen un protocolo de capas, cada capa, para poder hablar con su otra capa, le agrega cabeceras a la información Es decir, la capa, vamos para arriba, la capa de aplicación dice acá "get/" dice el HTTP Ese "get/" se lo dio a la capa de transporte, la capa de transporte le va a decir "che, tengo que mover este get/" Contra aquel destino, pero agregame, va a hablar con el puerto 80 y yo te espero en el puerto 9000 Le agregó los puertos, eso se lo va a dar IP, dice "ah, esto va" Todo esto que trae puerto, origen, puerto destino, get/, hay que ponerle la IP destino y mi IP origen Es decir, que le agregó IP origen y IP destino La capa de abajo, que lo va a mover en el cable, antes de mandarlo en el cable, tiene que decir "che, ¿a quién le doy esto?" Tengo que averiguar la MAC del destino que me puede mover esto por los cables Entonces le va a agregar la MAC destino y mi MAC origen Entonces, la pregunta original que vos me hacías es "¿dónde está esta información?" Está toda, porque lo que termina entrando en el cable es una trama Ethernet Que a su vez la trama Ethernet le agrega, antes de meterla en el cable, le dice "che, ojo, esto es un Ethernet" Le pone un preámbulo, si, usted lo ha visto, unos bits de preámbulo y un bit que termina Dice "esto que transporto yo arriba es IP" Porque yo podría estar usando la capa Ethernet para llevar otro protocolo que no fuera IP Como es, no sé, bueno no hay muchos ahora todavía Como podría ser el protocolo NetBIOS, digamos, que funcionaría sin IP Pero yo puedo mover en Ethernet cosas que no sean IP Entonces cada capa le agrega cabeceras, que cuando llega al destino, cada capa va sacando el pedacito que le sirve para comer para saber qué decidir Eso usted tiene que entenderlo, que estamos hablando de capas y cada capa agrega información administrativa Que es la que va haciendo que esto funcione Entonces, lo próximo, nosotros estábamos viendo en CAP y PEDESTIN, ok Ahora, como estamos en un host, bueno, ok, listo, ya determinamos, no es vecino, si es vecino Y básicamente la decisión del algoritmo del host, estamos viendo todavía Pero este, si es vecino, dijimos, cómo va a averiguar, bueno, como dijo un compañero Los protocolos de capa de enlace tienen normalmente una forma de, si yo tengo información de una capa superior, averiguar la capa inferior Porque en este caso, ¿qué tengo yo de mi vecino? Yo sé fehacientemente qué es vecino por una cuestión de configuración Porque la máscara, operé la máscara y me dice, che, este flaco es vecino mío Si es vecino mío, significa que está al lado mío en el mismo medio, ¿qué hago? Dijo alguien por inundación recién Pregunto a quién le corresponde Pregunto en el cable, le digo, muchacho, a todo, ¿quién es? Dijimos que queríamos hablar con él, 202 ¿Quién es 192, 168, 202? Les grito, eso, ¿cómo se hace para que les llegue a todos? Un broadcast Claro, pongo un paquete en capa 2 de broadcast ¿Qué termina pasando con eso? Y todos los flacos dicen, ah, mira, llegó esto, alguien está preguntando por qué debería, qué respuesta debería recibir Y el que tenga esa IP le dice, soy yo Ah, soy yo, entonces, ¿qué hace? Todos le dicen, no, yo no soy, yo no soy No, no, no, no, no, no, no, no, no, no, no, no, no, no, no, no Está un huevón preguntando por el 202, listo ¿Qué hace el 202? Ah, acá estoy ¿Cómo le dice que acá estoy? Bueno, le responde, le dice, acá estoy En esa respuesta, como el tipo le dijo acá estoy, ¿cómo va a ser para responderle? Veamos la capa 2 de la respuesta, de la pregunta esa que dicen de broadcast ¿Qué MAC destino lleva? La del que le quiere hablar, en este caso el 200 La pregunta de inundación lleva, ¿cómo se haría para que les llegue a todos? Con F, todo, con todas F Muy bien, va a todas F, ¿por qué a todas F y no a todas? ¿Quién dijo? ¿Por qué a todas F? Es parte del protocolo, para que la reciban todos, para que la agarren todos digamos En el protocolo, si yo quiero hablar con todos en una capa 2, les grito al FFF, es decir, escribo un solo paquete al FFF Eso golpea a todas las interfaces de la red, que están en el mismo, capa física mía A todas, eh No les quiero enroscar la labor ahora, pero les llega a todos Entonces, el 202 que recibió, recibió un datagrama con MAC destino FFFF, MAC origen la de quién? La del 220 La del 220, la del que estaba preguntando, entonces ¿qué hace para responderle? ¿A quién le responde? Toma esa MAC de la 220 y pone su propia MAC La MAC destino, la del 220, la del como origen y dice "soy yo" Entonces, ¿qué es lo primero que tenemos que averiguar acá si es vecino? ¿Quién tiene ese IP? ¿Ah? Le dimos a la MAC, digamos La MAC es una función que pide a la MAC, sí Entonces, si la MAC es la MAC, no sé, llamémosle función Preguntar MAC de quién Del equipe destino Destino, bien Y si ya tengo la MAC, ¿qué hago? Se la manda directamente, se da la mano Manda el mensaje con la MAC Dice "mira, tengo una función que es de la capa 2, que es mandarle la trama, no sé, ¿a quién?" A esa MAC MAC ¿Y qué le tengo que mandar? Los datos Los datos de la RAM, sí, data de la RAM IP ¿Y acá qué tengo que hacer? ¿Cuándo creen que corre este algoritmo? ¿Cómo le hago? ¿Cómo le hago? ¿Cómo le hago la pregunta? ¿Qué hago acá? Es decir, ¿mandé la trama y después qué hago? ¿Y nada, ya lo mando? Por eso, ¿este algoritmo acá qué hace? Después de esto, ¿qué hace? Es decir, este programa, ¿cuándo se va a correr? Cada vez que tenga que mandar, es decir, acá ha habido, imagínense, hay una Todo este algoritmo es mandar IP, a IP destino, ¿sí? ¿Está bien? Esta función se llama mandar IP ¿Ok? ¿Quién usa la función mandar IP? Mandar data de la RAM IP Si lo pensamos en capa Capa 3 Es decir, esta función la va a llamar la capa de transporte cada vez que tenga un transporte para mandar, ¿o no? Entonces, si acá mandó la trama, después de esto, ¿qué hace? ¿Qué más tiene que hacer? ¿Y si tiene otra trama que mandar? No, bueno, por eso, pero ¿usted está encodeando la mandar trama IP? Estoy tratando de hacerle Ya decidieron a quién va, mandaron la trama en capa 2, ¿qué hacen? Si esto es una función, después acá, ¿qué más tienen que hacer? ¿Hay algo más que hacer o están listos? ¿Esperar la respuesta? No, no siempre tenés respuesta Es decir, de nuevo, se los he hecho así a modo de programa Ustedes estamos codeando la capa de IP, por decirlo de alguna manera, ¿sí? Mandaron un paquete IP Ya vieron si era vecino o no era vecino Este era vecino y se lo mandaron al vecino ¿Qué pasó después? ¿Qué hay que hacer? ¿Terminaron lo que tenían que hacer o no terminaron? Sí, ya mandan la respuesta Por eso, ¿qué tal? Si no es vecino... Por eso, pero si es vecino le manda la capa 2 y termina ¿O no? Le pongo "exit" para que lo veamos Si no es vecino, ¿qué hacemos? Tengo que... o sea, la más que voy a poner es la de mi gateway A ver eso, por qué... Si el paquete no es para mí, si yo determino que no es un vecino Esto agarró y me dio el caso que tenemos dibujado acá ¿Qué hago? Se lo manda al router Claro, se lo tengo que dar al router Entonces... Envía el... o sea, manda a trama pero a la router ¿Se entiende lo que estamos hablando? Es decir... Recién tenía un paquete que era para uno que era vecino que está acá Yo pregunté en este cable, hice un broadcast y se lo mando derechito Ahora sé fehacientemente que este paquete se tiene que ir por acá ¿Está bien? Tiene que agarrar y salir, irse por acá ¿Qué me cambia de este algoritmo? El destino Destino ¿Me cambia la IP de destino? No, no, la IP de destino no, la MAC de destino cambia ¿Todos ven eso? Sí Bien, es decir que si esto no es así... O sea, perdón, a ver si... A ver si lo entendí bien Entonces, en el datagrama tendríamos la MAC, sería la MAC del router Exactamente Y la IP sería la IP de destino que definimos al principio La IP yo no la toco porque yo el datagrama no lo puedo tocar, lo tengo que encaminar nada más El datagrama no lo toco, es el mismo Digo, che, ¿se lo pongo acá o se lo pongo allá? Eso se ve Entonces, acá ¿por quién pregunto? Por la MAC del gateway, del router Debería tener entonces, supónganse que tenemos en algún lado Acá tenemos un parámetro de configuración que es "ipsource_gateway" En este caso ¿quién era? El 201 Entonces yo acá voy a decir, che, mirá, "ipsource_gateway" Y acá voy a decir, "manda_trama" ¿a quién? A MAC ¿Y qué le mando? El datagrama IP ¿Se puede mejorar algo este código? Está medio cochino ahí ¿Qué harían con esto? ¿Qué le ven que no lo he hecho bien yo acá? Hacía una función que se iba a mandar eso y nada más le pasaba la IP de destino ¿Qué está cambiando el código acá y este exit? ¿Cómo lo harían? Yo acá también tendría que poner un exit ¿Cómo mejorarían este código acá? Y que no sea solo "ipsource" o "ipsdestino" si no lo vea antes Y solo ponga un código, si no lo duplica, si está casi duplicado ¿Y el "manda_trama" no hace falta? Lo puedo poner abajo Bien Este lo saco acá Y este lo saco ahí ¿O no? Sí, brofe Brofe, tengo una duda, es medio tonta, es bastante tonta Pero cuando nosotros acá pusimos el router, que dijimos que tiene 192, 168, 201 Los routers, ¿tienen dos? O sea, ¿por qué acá tienen... Me cuesta ver por qué tienen dos direcciones IP, una es privada y la otra es pública, sería Todas son privadas acá, eh Este es el rango, las 10 son redes que no están directamente conectadas a internet también Son todas IP privadas Pero igual, es buena tu pregunta Imaginate, si vos sos un puente y tenés un solo lado, ¿podés vincular gente? No Por eso, entonces como mínimo, por eso por definición Yo te diría, si hay dos redes IP y te digo que están conectadas ¿Qué hay en el medio? Claro, hay como dos vías, sería Siempre, un router... Claro, no para ir y venir, digamos, por definición Si vos, acá hay una red, ¿no? Esta es una red IP y esta es otra red IP, y son redes IP distintas ¿Por qué son distintas? Bueno, porque su número de red operado a su máscara da otro prefijo Y yo las quiero vincular, lo que tengo que poner en el medio es un router Entonces como mínimo, cuando hay router, hay al menos dos redes IP distintas ¿Por qué digo al menos? Porque vamos a empezar a ver que yo podría tener un router, como le mostró Juanjo recién Tres, cuatro, diez interfaces Y un nodo más central del... Pensemos en el ruteo, ¿cuál sería un ruteo en una ruta? ¿A qué se parece un router con muchas interfaces? En el ruteo, cuando van por la ruta ustedes Una rotonda Una rotonda, por ejemplo, con más de una salida, porque usted dice "ah, no, mirá, llego acá y me puedo ir a Córdoba, puedo ir a San Luis, puedo ir a Neuquén" Y en algún lugar va a haber más de... no siempre hay bifurcaciones que a una u otra Claro, bien, perfecto De hecho, eso da pie a... Que ya lo vamos a ir generalizando, es decir Yo podría tener muchas interfaces Claro, y si yo tengo muchas, ¿le da una dirección por cada interfaz? Muy bien, muy bien Entonces Antes de irme ahí, verifiquemos si esto... a ver si esto le podemos hacer la tabla de la verdad y anda bien Coinciden que más o menos esto... Le llamé mandar datagrama IP, esta es No sé si está Juanjo ahí Vecino, sí vecino Sí ¿Cómo se llama en el API de SOCKS de Berkeley esta función vista desde... bueno, no se ve desde arriba? Bueno, sería, en realidad tenés que abrir un socket raw y ahí tenés que hacer un send message sería Send underscore message, MSG Más o menos, algo así, claro Ese sería, obviamente está mucho más adornado de arriba, pero sería básicamente ese Entienden ustedes que esto sería, desde el punto de vista del... y esto es la parte que quisiera que ustedes conecten Si fueran un desarrollador y están haciendo la capa IP, están decidiendo programar esta parte que está acá Y vos decís, che, ¿quién usa esto? Y esto lo usa alguien que está arriba, que necesita mandar un datagrama IP ¿Está bien? Sí, capa 4 La capa de transporte es la consumidora de esta función, sería Y fíjense que acá nosotros estamos consumiendo una función, esta, mandar trama, sería una función de qué capa? Dos Claro, está bien Acá hemos abusado de una especie de generalidad, pero lo que estamos tratando de hacer es aproximarnos a una idea de lo que sería el algoritmo Y supongamos por un instante, como bien decían recién ¿Qué puede pasar si yo tuviera... Más de una dirección IP acá, por ejemplo, estoy conectado, por un instante, estoy conectado Eh... No, no te inclines Esta es mi IP, soy un host, ¿no? Sigo siendo... Soy un host que tengo un IP de este lado, pero también tengo otro IP y acá hay... Acá estoy conectado a la red Uno Tengo el IP 1.20 Y resulta que este es el router Eh... Ahora no lo voy a complicar con el router Soy una máquina... Ay, borrate Una máquina que tiene dos placas de red y tengo acá... ¿Puedo tener dos placas de red o no puedo tener dos placas de red? Sí, mientras tengas los puertos PSI Sí O por ejemplo, puedo tener una placa de red y cómo podría tener... distintas redes capa 2 Una antenita Wi-Fi que pasa No, no, con la misma placa de red Hay manera de que con la misma placa de red tenga... Emulado, actualizado En varias redes... No Y de cielo, no Una VLAN, yo puedo tener una sola placa de red y estar en la VLAN 1 y en la VLAN 10 Tengo una placa de red y está taggeando en VLAN distinta Teníamos miedo de decir switch ¿Ah? Teníamos miedo de decir switch No, bueno, pero... La VLAN, de nuevo, ¿cómo creen que están hechas las VLAN? Claro, no, no son distintas Es más, es más, les voy a decir ¿Se puede hacer VLAN sin un switch? Creo que sí ¿Cómo? Estoy seguro Y porque las VLANs eran lógicas, o sea, llevaban cada trama, cada catagrama Llevaba un pedacito que decía que VLAN pertenecía, ¿cierto? Bien, por eso, yo puedo hacer perfectamente Ustedes se pueden crear VLANs en un switch, en un hub Y que la VLAN es un tag, si la ponen en modo taggeada, que sea, más Ponen que está adelante de las etiquetas de las tramas está el tag de VLAN ¿Sí? Entonces yo puedo agarrar y decir, che, mirá, pongo VLAN 10 o VLAN 11 Es la misma placa, escribo una trama, nada más que una lleva el tag de la VLAN 10 Y el otro lleva el tag de la VLAN 11 Entonces, el juego de VLAN está basado en las etiquetas, yo levanto las de VLAN que estoy taggeando No hace falta ningún switch Pero bueno, para darle una media vuelta de rosca al problema Si yo tuviera este escenario, ¿cómo le iría a nuestro algoritmo? Le iría a un FOR por cada IP que tiene Se fija en una IP si es vecino y se fija en la otra si es vecino Y en caso de ser ninguna va algún... Ah, entonces, ¿qué cambiaría de lo que tenemos acá? ¿Qué hay que mejorar acá? Y hay que agregarle la otra IP, la otra máscara Por eso, pero si tenemos que modelarlo en código, ¿esto qué sería? ¿Qué le falta a esto? Una clase, hacerlo por clases No, porque si lo hiciera por clases tendría que instanciar objetos distintos Si yo tuviera una... ¿esto qué es configuración? ¿Qué me cambio ahora acá? Yo tengo la eth0 es esta, y la eth1 es... 192, 168, 120, /24, digamos Tengo otra IP Si lo tuviera que meter en una estructura, ¿qué le agregan a esta estructura? ¿Qué se refiere con...? Si ustedes tienen que cargar toda esta interformación en una estructura de datos Porque esto recién la teníamos acá, decíamos IP source, IP Pero resulta que ahora hay varias IP source Y no podemos ponerlo en el mismo modelo Bueno, por eso, ¿qué le falta a esto? Una dimensión Claro Entonces, ¿este es el problema? Bueno, por eso, ¿qué le falta a esto? Una dimensión Claro Entonces este sería, no sé, IP source sub 0 IP source 0 ¿Sí? 0 ¿Y qué más debería hacer acá ahora? Esto se debe decir, el IP 1 Como si fuera, este es 1, 20 No voy a complicar con el gateway por ahora Porque después vamos a ir a la generalización de esto Entonces, ¿qué le cambiaría a este algoritmo? Para que pueda soportar ese problema Si yo fuera un host con más de una IP, ¿qué debería haber? Y por ahí si, tendríamos que ver si es vecino para cada IP que yo tengo Por eso, ¿dónde hay que iterarlo? En el método Acá, entonces, tendría que ser para Para cada IP source Sería una iteración acá, ¿no? No se está viendo a medida que típicas, no sé si es que tenés otra ventana Sí, se quedó otra Está frizado ¿No? Pensé que era el único No, no, no, no, no, no, no Está esperando que refrescara, pero hace rato que cuando vas hablando, el sub 0 Será mi, ah, miércoles, pero dice, ¿estás presentando para todos? A ver, dejo de presentar y lo mando nuevo Dale, trae No, no, no, profe, porque yo acá me, o sea, si se mete a la página A ver Sí, en la pizarra apareció En la pizarra Ahí estoy de nuevo, a ver Tal vez porque estaba escribiendo y no lo había soltado, a veces como que Uy, mirá, hay muchos, claro, todo eso, todo el arroyo ese que has hecho, no sé No, hay que hacer, hay que hacer, ah, con razón lo escuchaba, es que están callados Me parece que es lo que decís, uy, hay que soltarlo Bueno, no, agregué acá la dimensión 1 con las dos IP ¿Y qué tenemos que hacer acá? Tenemos que hacer un bucle Sí Para cada IP source Sub i en IP source O bueno Así no se me O para cada, sí, claro, bueno Habría que llamarle distinto ahí Llamémosle acá O ponerle mayúsculas eso, pizarra array o algo por el estilo, como quieras IPs, ah, bueno, ok Ahí sí se ve, ah, se ve en mi pantalla, ustedes lo ven porque ven mi pantalla Ah, ahora sí Sí, está en mi pantalla Está, entonces para cada IPs en Se entiende que en IP source No, al revés, para cada IP Para cada IP, se usa en IP Bueno, no sé cómo quieren hacer, no sé cómo tienen el bucle, esto significa que lo carga en IP source Y después usa en IP source acá adentro Bueno, sí Para cada IP, claro, _src, sería al revés, al menos yo lo entendería al revés For each IP_src, ahí está, en IPs Ahí está, dos puntos, le gusta dos puntos Perfecto Y sí, ya que me estás traduciendo Python, hazme la convocatoria Entonces, ok Esto generalizaría, tiene una Para que esto no falle, vamos a hacer acá un abuso O pongámoslo, porque no es mala idea ponerlo como algo global que está fuera de la lista, ¿no? Si lo sacamos, ok Sí Acá vamos a hacer así Claro, ponerle gateway directamente Ok ¿Tiene entonces un solo gateway y no importa cuántas IPs tenga? Es parte de lo que queremos En principio sí, más avanzadamente hablando, de forma más avanzada No puede tener múltiples gateways, pero requiere otro tipo de lógica Vamos a quedarnos con que sí, con que el gateway es global Lo que no va a ser global es en cuál Recordemos que el gateway es siempre mi vecino Sí En eso estamos de acuerdo, ¿no? Ya habíamos recontra hablado de eso Por lo tanto, el gateway va a estar asociado a una interfaz en particular Un gateway va a ser siempre vecino de una interfaz en particular Entonces hay una relación con cuál es la interfaz correspondiente Pero lo vamos a dejar global por ahora Bien Supongamos, a ver este algoritmo, si camina más o menos bien Si le creamos No sé, esta máquina está reinteresada en pertenecer a muchas redes Son las 8 menos cuarto, ¿te parece que hagamos un toquecito antes de meterse? Hacemos unos hasta las 8, ponele No, no, pero cierra acá porque en realidad debería ser corto ¿Qué pasa por un instante si, no sé, esta máquina también pertenece a la red 172, 16, 16, 20 Y esto es 16, 1 Se rompe el algoritmo Hay que agregarlas ¿Se rompe el algoritmo? No, hay que agregar al array, hay que agregar el IP nuevo y listo Es decir que, bueno, esto es config ¿Esta configuración dónde se hace? Normalmente en su window El sistema operativo Claro, va a entrar panel de control, configuración, agregó el IP y listo Es decir que, digamos que, ¿este algoritmo soportaría cientos de IP o no soportaría cientos de IP? Si me sirviera de algo, digamos, si el IP es 2 y la máscara 2 ¿Camina o no camina? Camina, camina Si Si te quieres tomar la leche, claro, pero camina 20 Si, camina Bueno, me parece bien lo que dice Juanjo, nos tomamos un break hasta las 20 Hasta las 8 creo que estamos, dale Ok, perfecto Voy a cortar la grabación de esto, así se va cocinandoBien, entonces recién hicimos una revista sobre IPv6, hablamos de tunneling, hablamos de cómo es el autoadresamiento que hace la configuración automática de adreses que hace IPv6 y algunos otros aspectos del addressing de IPv6. Nos estamos por despedir la capa 3, pero no podemos hacerlo sin antes ver, tal cual en IPv4 e ICMP en 6 es, como bien sabemos, es un protocolo que está a la misma altura en la capa de red y que ayuda a ICMP de 6. Vamos, es fundamentalmente, semánticamente, muy muy parecido a IPv4 y tiene unas pequeñas diferencias que son las que recalcaremos especialmente a Albert Lurka. Tiene el mismo diseño de protocolo si se quiere, recordemos que en ICMP 4 teníamos el tipo de mensaje y después el código de mensaje. Lo que ven acá en negrita, como "destination unreachable", "packet to bit", es el tipo de mensaje y después esto tiene un subcódigo que vendría a ser el subtipo de mensaje, lo que está aquí adentro. Fíjense que los conceptos son muy parecidos a 4, "destination unreachable" tenemos "no root to destination", que en 4 sería "network destination unreachable". Acá aparecen este tipo de cosas, "beyond scope of source address", ¿alguien me traduce qué significa esto con lo que acabamos de ver? ¿Qué es "source destination"? ¿Qué será eso? Esto lo responde un router y dice "no, destination unreachable, no jodas, de esa manera no podés ir". ¿Qué me está diciendo? Un F80, un 2000... Claro, exacto, es decir, yo he intentado, que es muy parecido a lo que tenemos en la cloud, lo que pasa es que el stack tiene que ser inteligente para decir "ok, mi default router es F80, pero si yo voy a un destino 2000, no puedo ir con una source address F80, tengo que seleccionar", y hay todo un algoritmo para seleccionar la source address adecuada para saber que el regreso sea correcto. Entonces, protocolo IPv6 es como que ya tienen bebido en el mismo stack estos scopes distintos, entonces yo no puedo contactar un scope global desde un scope local, sencillamente porque no funciona y porque no hay NAT en 6. En 4 lo podemos hacer alegremente, que nosotros vamos de 192, 168, Sarasasa, hasta, no sé, 200.1.2.3, el protocolo nacional al respecto, porque no había en IPv4 esta gran separación de scopes. Hay direcciones privadas, existen direcciones privadas en IPv4, existe NAT en IPv4, pero en IPv6 no existe NAT, por lo tanto es inválido intentar desde una link local a una global. Entonces, directamente tu router acá te va a explotar, si es que no te explota el stack local posiblemente. Ahí yo no recuerdo los detalles. Las mismas cosas que habíamos visto, address unreachable le llama acá host destination unreachable, porque el destino no está presente en el link, como sabemos el único que puede dar host destination unreachable y asegurar que no está el host es el último router que ya es vecino de mi destino. Y hay algunas otras cosas, un poco más, que acá aparece más explícito un caso de firewall, que es algo parecido a esto, la política de ingreso/degreso no te permite. Y hay un específico para reject también, cuando vos tenés entrada local en la tabla de routeo que directamente te recheca. Pero básicamente, conceptualmente es destination unreachable, más allá de que aparece este caso particular que les mencioné recién. PMTU packet tweak, directamente, acá no hay "uh, debería fragmentarte, pero DF=1" me dijiste, no, recordemos que no hay fragmentación en camino, en el camino los routers no fragmentan, así que acá todos tienen que ser señoritos que descubren MTU, entonces si vos, origen, me mandaste un paquete y yo link próximo no pasa, listo. Packet tweak, es como que el DF=1 está implícito, porque de hecho, como hemos visto, no hay un renglón, no hay un lugar para especificar fragmentación en IPv6. El time exceed, que es el mismo que vimos, nada más que en el caso de 6 hemos visto que ya se le llama adecuadamente a la cabecera, lo que mal llamábamos en IPv4, time to leave, como no es un time, bien lo hemos hablado mucho, ahora es un hop limit, que es el correcto. Básicamente lo que siempre hemos dicho coloquialmente es "te acabó la nafta". Parameter problem es lo mismo que en IPv4, no sabés escribir IPv6, es básicamente vos escribiste algo en la cabecera que está mal, aprendés a escribir IPv6, entonces SMP en algunos casos devuelve el parameter problem, o alguno de los campos de la cabecera no está correcto. Y acá tenemos los bien conocidos, el core request y core reply. Router advertisement es nuevo, ¿me recuerdan qué era lo que hace el router advertisement? Lo acaban de ver hace un ratito con Diego. Router advertisement. Pasa del prefijo de red. ¿Quién lo envía eso? El gateway. Claro, los routers, básicamente "llenan", entre comillas, "llenan" la red de router advertisement, ¿y qué hacen los nodos con esos routers advertisement? Fijan su OIP. Tomando justamente el prefijo ese que defaulteamos en 64 y le pegan el POS fijo, el lado host, que está construido determinísticamente en la MAC, para obtener la IPv6 de 128 completa. Entonces eso es un concepto súper importante que no existe en IPv6. En realidad no existe un mecanismo, no. No existe un mecanismo similar. Router solicitation, esto en realidad es el complemento de esto. En principio los nodos, ustedes van a ver que también tienen el permiso, si se quiere, de poder pedir, cuando recién arranca y dice, "quiero IPv6" y puede que el router advertisement esté puesto con una frecuencia muy grande, por decir, en vez de ser cada, creo que nosotros lo tenemos que ver bastante rápido, cada 30 segundos, cosas que se auto-configuran solitos, el admin puede decir, bueno, cada 5 minutos, este nodo acaba de arrancar y ya quiere, necesita IPv6, entonces apenas arranca y obtiene el link, hace un router solicitation. Obtiene link, pero ¿con qué IP va a hacer un router solicitation si solamente tiene link? ¿Nadie le ha dado un IP? Recapitulo. El nodo final, el host, obtiene link y dice, "che, yo quiero empezar a andar en IPv6, vamos a ver, capaz que tenga un IPv6 público, entonces hago un router solicitation, pero ¿cómo voy a hacer un router solicitation si todavía no tengo IPv6? Solamente obtener link. ¿Qué hay de mentiroso en todo eso que acabo de decir? Hay una parte que es mentirosa, que es mentira. Y si tiene porque el F80 lo podés asignar solo. Exacto, tal cual, yo tengo link y ya tengo IPv6, no tengo que pedirle a nadie más permiso a nada, por protocolo, yo tengo link, tengo la MAC, si, la parte de atrás, F80, MAC, bling, ya tengo IPv6, suficiente para esta cacerola. Hago un router solicitation justamente para descubrir, a ver, che, acá hay un router que nos saque de esta cacerola. Entonces, contra el router solicitation viene un router advertisement. Y si no, si no estoy tan frenético, me pongo a escuchar y vendrá un router advertisement y le pego otros prefijos, además del prefijo F80, que sabemos que tiene scope de cacerola, de enlace. Bien. Acá está el más interesante distinto, que es el network solicitation y el network advertisement. ¿Qué serán esos? Si tuviéramos que compararlos con IPv4. Solicitud de vecinos, advertisement de vecinos. [VOCES INTERPUESTAS] Cuando estudiamos la clase pasada, sí, usa multicast, dijimos que había un protocolo que notablemente se despedía y no existía ni pero 6. Protocolo fundamental para IP en un momento que necesita algo y después es olvidable, pero siempre tiene que estar, porque si no, eh. Y que no es IP el protocolo. [VOCES INTERPUESTAS] [VOCES INTERPUESTAS] Es el ARP, ¿no? El ARP. ¿Qué problema resolvía ARP en 4? Perdón, en 6 no existe ARP. Con una IP solicitaba la MAC. Mapa direcciones de capa 3 a capa 2, ¿no? Eso es lo que-- IPv6 lo que trae como novedad, si quieres, es que no le pide ayuda a un protocolo distinto a los que ya tiene, sino que usa el mismo, IPv6 sobre IPv6 para hacer esa resolución. Y vos te rascarás la cabeza y decís, pará, pero estás pidiendo resolución de vecino de IPv6 y estás usando el mismo IPv6. Bueno, justamente para estos mecanismos de multicast, recordemos, podría ser broadcast, pero broadcast no se usa en IPv6, entonces usamos multicast, con el cual básicamente es conceptualmente la misma implementación de ARP. Te voy a preguntar en multicast cuál es la MAC de este IPv6. Nuevamente, digo multicast, bien podría decir broadcast como ARP, pero como esta cosa evolucionó y se encontró que broadcast realmente es malo, se usa multicast para decir, che, ¿quién tiene este IPv6 en la vecindad? Y el vecino responderá el mecanismo del mismo, pero lo que es muy interesante es que la implementación es como parte integral del stack, o mejor dicho, la capa de stack IPv6 está todo autorresuelto. Con el caso de IPv4, IPv4 necesitaba pedirle un protocolo distinto, porque ARP en principio no tiene que ver con IP, es un protocolo de ayuda, pero tiene que estar ahí para poder hacer que IPv4 funcione. En IPv6 está todo autorresuelto, ¿no? Eso es importante y esa es la gran diferencia, una de las grandes diferencias que tiene ICMPv6 de ICMPv4. Y creo que estamos, sí, señor. Bueno, entonces, como habíamos dicho, y voy a aprovechar, estoy compartiendo esa ventana, déjenme buscar la presentación de TCP. Vamos a cambiar bruscamente de capa y nos vamos a ir para arriba. Como les comentaba Diego, hemos decidido, hemos decidido este año, para que no se nos escape del tintero, dar IPv6 antes de TCP. En años pasados nos parecía más, ¿puedes creer hasta el control? Sí, el control de esta porquería es poco reliable, pero estúpido sistema operativo del reverendo. ¿Pip? Sí, pip. No, me tengo que dejar. Qué cosa insoportable, por favor. Sacarte una SIM para ahí, para despuntar el vicio ahí. La tengo al lado, la tengo al lado. ¿Sabes cuál es el problema? Me es complicado, esta Mac la tengo guaireada para los tres monitores que tengo acá. Y las tengo por atrás, me da despedir sacar el HDMI y ponérselos, si no, sin duda estaría usando mis SIMPAD. De hecho, la necesito para jampear a la cloud, la necesito porque no tengo 0 tier acá en la Mac, por cuestiones de seguridad no puedo montarle VPN extrañotas. Bien, cambiemos rápidamente, entonces díganme a qué capa nos estamos yendo, muchachos. ¿En qué capa estamos? ¿A cuál vamos? Capa 4. Bien, capa 4, discutiblemente 5. 4 es transporte, 5 es sesión. Podríamos hacer una discusión filosófica si TCP en particular tiene capa de sesión o no. Vamos a dejar en que no, nos vamos a quedar en capa 4. Vamos de 3, capa IP, capa de red, a 4, capa de transporte. Acá esto es como repaso de lo que ya conocemos, un poco el mapeo, ¿no? Recordemos que en realidad en el modelo TCP, lo super recontra simplifica a estas capas que vemos acá, que es Data Link. Bueno, este en realidad es el modelo OSI, este es el modelo TCP, que es NETWORK INTERFACE, a veces se llama NETWORK ACCESS, INTERNET TRANSPORT Y APPLICATION. Estas son todas las capas del modelo OSI, no las vamos a repasar. Pero sí, acá estamos bastante cómodos en capa de transporte, capa 4. Algo interesante que a nosotros nos gusta recalcar y tratar de ser prolijos con la identidad de paquetes, como bien sabemos estamos en tiempos que hay que ser muy prolijos cuando hablamos de identidades, en este caso no sería otro tipo de entidad, sino identidad de conjunto de bytes. Cuando hablamos en capa 2 hablamos de tramas, cuando hablamos en capa 3, acá le ponen paquetes y no me gusta, hablamos de datagramas, porque paquetes sería más genérico, cuando hablamos en capa 4, donde estamos ahora hablando de segmentos y de mensajes, y en capa de aplicación hablamos de pedazos de data. Esto ya lo habíamos visto, un poco las características, pero vamos más allá de las comparaciones, me gusta que acá nos vamos a empezar a encontrar con cosas que se quieren nuevas. Vamos a encontrar que en los protocolos de transporte TCP, hay estos tres, este tuvo un inicio de SSTP, un inicio como decir, "ah, SSTP nos va a venir fantástico, va a poder hacer telefonía sobre IP, porque es una especie de cosa intermedia entre TCP y UDP, nadie lo usó, así, guac". Directamente se implementó de una manera distinta a nivel de aplicación, a él le dio bolilla porque había que, básicamente, otro protocolo a la altura del stack, que está a la misma altura de TCP y UDP, así que había que implementar unas capas de transporte, capas de transporte de cada endpoint, de nodos finales, y realmente no he visto mayor uso de SSTP. Pero está bueno, vamos a volver sobre esto, está bueno el ejercicio porque nos permite desacoplar conceptos que por ahí nosotros los consideramos acoplados, como por ejemplo, orientado a conexión y corrección de errores, en realidad no necesariamente están acoplados, sí, ambos están en TCP, pero no necesariamente son intrínsecamente, tienen que estar intrínsecamente juntos, así que bueno, ya vamos a volver. Algunas características de TCP, es orientado a conexión, IP es orientado a conexión. ¿Y IP? ¿Cuando un nodo IP quiere comunicarse, enviar un datagramo, otro nodo IP tiene que establecer antes una conexión? No. No, ok. Es muy "love and peace", es decir, yo le tiro el datagramo a la red, la red hace el best effort para llegar al destino, llegará o no llegará, en general, sabemos que tiene mucho éxito en que llegue, pero nada te lo asegura, no sabes si el otro está o no está, insisto en el esfuerzo por preguntarte, iniciar una comunicación con el otro. TCP vamos a ver que hace mucho esfuerzo para que eso sea así, por eso lo hace orientado a conexión. ¿Orientado a conexión es stateful o stateless? Stateful. ¿Por qué? Sí, orientado a conexión. ¿Qué significa y por qué? ¿Nos podrás explicar? Porque la conexión requiere guardar ciertos tipos de datos, que eso vendría a ser el estado. Entonces, si tenés conexión, es stateful. Bien, está muy bien. Ahora, ¿y cuáles serían esos estados? Está muy bien, yo tengo que recordar algo de, yo sé que esto es una conexión, si tenés el caso de IP, como bien sabemos, son datagramas cuyo problema empieza y termina en el datagrama, así lo consideran de hecho los routers en el medio. También el stack, todo el stack de IP, el problema empieza y termina en el datagrama, ya está. Sin embargo, acá hay una conexión, yo tengo que recordar, memorizar, que yo estoy conectado con el otro. Ahora, hay un estado, por eso es stateful. ¿Cuáles serían esos estados de un protocolo orientado a la conexión? Simplificado, ¿no? Muy, muy simplificado. ¿Han visto máquinas de estado cuando han visto programación o algoritmos? Sí. OK. Tratemos de describir cuáles serían los mínimos requerimientos de un protocolo orientado a la conexión, cuáles serían esos estados. Si vos tuvieras que escribirlo y decir, bueno, estamos de un estado X y vamos a saltar a un estado próximo Y, un estado A, un estado B, un estado C, un estado D y potencialmente un estado A de vuelta. ¿Cuál sería ese primer estado inicial? Como estado desconectado, digamos. Desconectado, no conectado, estado cero, ¿sí? Como toda máquina de estado, arranca de un estado en el cual no se ha producido ningún cambio, donde aterrizo por default. Desconectado, un socket desconectado. Inicio de la conexión. Entonces, podríamos, vamos a supersimplificarlo, pero habría un estado intermedio de conectando. Yo lo voy a saltear y voy a saltar derecho, nada más por una simplificación, ya vamos a volver, TCP tiene un montón de estado intermedio. Desconectado o no conectado a conectado. ¿Cuándo puedo transferir datos? ¿Cuándo la aplicación puede transferir datos? ¿Cuál es el requerimiento? Cuando está conectado. Cuando está conectado. Entonces, ahí está fundamentalmente lo stateful. Yo voy cambiando de estado y tengo, no puedo desde la nada empezar a transferir datos. Es decir, estoy desconectado. Ahí van los datos. No, pará, pará, estoy orientado a conexión, papi. Desconectado, establece la conexión. Estamos conectados, estamos en el otro estadio de estado, en el otro circulito de estado, conectados. Ahora sí transferimos datos. Y después, esto es para siempre, listo, nos conectamos para siempre. Ya no nos podemos conectar nunca más. ¿Cuál sería el próximo estado? Solicitar desconexión. Ajá. Solicitar desconexión sería la acción, el verbo. Y el estado sería desconectado, ¿no? Que en realidad es equivalente al estado no conectado, en principio. Puede tener algunas cositas distintas. Vamos aquí a TCP. Yo lo estoy de vuelta, súper simplificando. Es solamente para mostrarles que saltar de un estado a otro requiere esfuerzo, requiere intercambio de paquetes. Algo que, como bien sabemos en IP y venimos súper recalcando, que es stateless, que no es orientado a conexiones, sencillamente porque vos mandás el datagrama. Sí, mandás, plim, y allá va. No hizo falta hacer el esfuerzo de ver si está el otro, si el otro me quiere recibir, si les parecen bien los parámetros de conexión que yo le he pasado, ya estamos de acuerdo, hicimos el handshake, estamos conectados, bueno, podemos transferir datos. Hay como una burocracia de manejo de estados, ¿no? Entonces, importantísimo ese concepto. Veamos otro del... Sí, vamos. ¿Puede ser que esto sea lo de three-way handshake? Vamos a ver. Podrían ser any way, podría tener muchos, vamos a ver por qué son tres. Sí, sí. Three-way handshake es lo que te lleva a un estado desconectado, un estado conectado en el caso de TCP. En el caso de otros protocolos con orientado a conexión, podría ser distinto. Por ejemplo, TLS, que es un protocolo de aplicación, tiene como siete mensajes, porque hay criptografía involucrada, y además acá no hay criptografía, acá es simple, es, vamos a ver por qué es ese three-way handshake. Acá hay algo interesante, la unidad de transporte es el byte en el caso de TCP y no es el mensaje, como ahí... Esto es lo que a mí me gusta describir como una manguera, ¿no? Porque es como que TCP tiene que hacer un trabajo para hacerle ver ese socket del lado origen contra el lado destino que tiene una manguera continua y que este puede inyectar un stream potencialmente infinito de bytes y se modela para la aplicación ese socket como una manguera, donde la unidad de transporte es el byte, no el mensaje. Eso tiene fuertes implicancias, porque por ahí uno lo considera, pero imagínense que ustedes estuvieran haciendo un... tienen que modelar un protocolo de aplicación para SQL, ¿todos conocemos SQL? ¿Sí? ¿Lo hemos visto en alguna parte de la carrera? Sí. Sí, por favor. Ah, bueno, bien. Imagínense que yo quisiera que el protocolo para esta base de datos, le llamo umsql, por "um" SQL, yo puedo hacer pipelining de queries. ¿Qué es pipelining? ¿Alguien me explica? Es poner un set de queries que se vaya ejecutando una después de la otra. O una cola de espera, digamos. Bien, cerca, cerca. En realidad yo puedo enchularle varias a la vez. No tengo que hacer... No tengo que enviar, esperar que se ejecute. Enviar, esperar que se ejecute. Enviar, esperar que se ejecute. Sino que sencillamente yo es como que le enchulo cuatro queries a la vez, y después puedo seguirle poniendo y el otro me va respondiendo, quizás me ha respondido tres queries, quizás yo le enchulo ocho más, una más, y el otro me va respondiendo, y para eso voy a necesitar ponerle identidad a esas queries. Si el protocolo, como es el caso de TCP, es orientado a bytes y no a mensajes, ¿cómo hago yo para diferenciar? ¿Esta es la query 1, esta es la query 2, esta es la query 3? Puedo confiar en que si la aplicación, y esto es importante que lo atendamos, yo soy la aplicación que implementa ese protocolo, que está implementando una aplicación, porque un protocolo es una aplicación, como podría ser SQL. Y yo hago lo siguiente. Sockets, ¿no? Sockets conectados entre ambos lados. Origen, destino. Acá estoy, origen. Le mando. Es pipeline, así que tengo permiso para mandar varias queries SQL a la vez. Le mando la query 1, la query 2, la query 3, la query 4, y se lo escribo en cuatro veces distintas en el socket. Hago un write con el query 1, hago otro write con el query 2, hago otro write con el query 3, y otro write con el query 4. Yo tendré la garantía del otro lado de que quien lee el servidor de base de datos, cuando lea, va a hacer read, ah, mira, acá viene la 1, read, ah, mira, acá viene la 2, acá viene la 3, acá viene la 4. ¿Qué les parece? Existirá esa garantía de que, si yo escribí cuatro veces acá, desde un paquetito de 500 bytes, otro paquetito de 600, otro de 700 y otro de 200, del otro lado cuando leen, leen uno de 500, uno de 600, uno de 700 y uno de 200. ¿Será así? No, pueden llegar a ser ordenados. No, no, TCP asegura que estén ordenados. No es el problema del orden, en este caso. Que es otro de los aspectos acá, eh, ojo. Entrega ordenada de bytes. La pregunta es otra, que es más sutil. Si yo escribo 500, 600, 700, 800, para hacerlo simple. Del otro lado, del socket, del server de base de datos, hace un read. ¿Hará un read de 500 y le garantiza el protocolo que le dé solo 500? ¿Después viene a hacer otro read y saca 700? ¿Después viene a hacer otro read y saca 800? ¿Tiene esa garantía? ¿Sí? ¿Qué les parece? Si el protocolo es garantizado a bytes. ¿Cuál es la unidad de comienzo y fin que se preocupa el protocolo? El byte. Entonces no les dan ninguna garantía de mensaje, pero ninguna. Es más, si ustedes pensaran que esa implementación sobre TCP funcionaría, se les haría torta. ¿Por qué? Porque bien puede ser que si vos escribiste suficientemente rápido del lado de origen, imagínate, mandaste 4 queries y mandaste 500, 600, 700, 800, y como bien sabemos, 500 más 600 es 1100. Entra en un solo y capaz que logró enchularlo en un solo MTU, acá llegaron 1100. Entonces cuando lee el server, lee 1100. Y de pronto se encuentra, ¿cómo hago yo para diferenciar que el query este tiene el query 1 y el query 2? El protocolo no me da esas marcas de comienzo y fin de paquete. No existe tal cosa a nivel de aplicación en TCP. En TCP es un flujo continuo, una manguerita infinita continua de bytes. Si yo tuviera que resolver ese problema, ¿qué tendría que hacer? A nivel de aplicación. Ahora estoy programando el protocolo es el UMSQL. Usar algún flash, no sé. Bien, ok. Voy a tener que yo arreglármelas para que cuando yo escriba esta secuencia de bytes, tenga algún marcador de comienzo y fin para que el otro lo pueda levantar. Ahí gRPC es la implementación más interesante de todo eso, que es Global Remote Procedure Call o Google RPC, que de alguna manera encapsula, pero es a nivel de aplicación. Ya vos definís un protocolo a nivel de aplicación, dado que protocolo de transporte no te asegura esas marcas de inicio y fin de escritura, vos tenés que a nivel de aplicación construirle y poder decir, bueno, si este es todo un mensaje que está encapsulado y tiene esta marquita de comienzo e inicio, pero cuando entra en la manguera infinita va la marquita, va la data, va la otra marquita. ¿Se entiende? Eso es cuando yo tengo un problema que no es un problema típico de HTTP, que estoy descargando algo, por ejemplo, que estoy cargando una página HTML, que si viene una parte que se quiebra justo en el medio de un tag y después viene el resto y viene bien, el navegador lo va a completar correctamente, sino que es el problema cuando yo quiero paquetizar a nivel de aplicación. Bueno, todo esto es para describir, y esto es súper importante, somos muy malos cuando no se... va, muy malos, muy estrictos cuando no se ha comprendido esto. TCP siempre orientado a bytes, contra la aplicación es una manguera continua de bytes. Después veremos cómo se las arregla porque ahora tiene un dolor de cabeza TCP. ¿Cuál es el dolor de cabeza que tiene TCP? Desgraciada aplicación que quiere una manguera continua de bytes y abajo que tengo. Yo soy TCP, capa 4. Arriba tengo... Y IP, es orientado a... Datagramas. Datagramas, sí, y la desgraciada aplicación está queriendo una manguera continua de bytes, así que yo tengo ahora el dolor de cabeza de hacerle creer a ambas patas de la aplicación, los sockets de aplicación que tienen una manguera infinita de bytes, y abajo que me dan para elaborar una cosa paquetizada. Entonces, yo, y esa es la parte más importante que tiene resolver TCP, si se quiere, es cómo convertir, cómo hacer una adaptación, y acá va contra mis amigos electrónicos, una adaptación de impedancias entre... Arriba algo que quiere una secuencia continua de bytes, y abajo que tengo cosas paquetizadas, que ni hablar que son continuas, que sabemos que se pierden, que pueden llegar desordenadas. Entonces yo, papi TCP, tiene que encargarse de modelar un flujo de bytes continuos hacia la aplicación, sobre una red que es paquetizada y que es sin garantía de entrega. Esa es fundamentalmente la misión que tiene TCP. Entrega ordenada. La entrega ordenada se refiere siempre, pensemos esto nuevamente que es a nivel de socket de aplicación. TCP te asegura que vos, si mandaste hola mundo, no vas a recibir mundo hola. Si mandaste hola espacio mundo, vas a recibir quizás ho, la espacio m, ndo, undo. Pero va a venir ordenado, no hay garantía de que venga en el mismo momento, pero ordenadito va a venir. Control de flujo, ya vamos a ver sobre esto cuando nos metamos un poco más. Pero en general, ¿qué significa control de flujo? ¿Qué pasa por ejemplo si yo fuera bueno cantando rap y diera esta clase de TCP como un rapero así? Porque este TCP tiene control de flujo, entonces después envía los paquetes cuando no lo va a hacer, no va a hacer la fragmentación para poder, pero no... ¿Ustedes me escucharían? Iría muy rápido. ¿Cómo? Iría muy rápido. ¿Muy rápido para quién? Para la que escuchamos. No para la red, ¿no? Para la que escucha. Entonces control de flujo es, más allá de esa analogía medio ridícula, es entender que quien transmite no puede empujar más de lo que el otro puede recibir, y tiene que poder leer y entender cuánto está recibiendo el otro, y el otro bien puede decirle "no, para, para, para". El TCP receptor le dice al TCP transmisor "para, para, que todavía no he desbuffereado lo que me has enviado antes". Y el TCP transmisor tiene que parar, porque si no se para, ¿qué va a ocurrir? Pierde el dato. Sí, se va a mal utilizar la red, porque el transmisor envió, hizo todo el esfuerzo de la red para llegar, y este estaba, por decir, con el buffer lleno, y se va a desperdiciar. Entonces, el transmisor tiene que poder de alguna manera leer y saber cuánto el receptor está dispuesto a recibir y modular su transmisión en base a eso. Ese es control de flujo. No tiene nada que ver con entrega ordenada, que no tiene nada que ver con corrección, es sencillamente entender cuál es el grado, la capacidad de recepción del otro lado, y adaptarme a eso. Súper importante. Y control de congestión, en realidad, es, vamos a ver bastante de eso en TCP, es tratar el TCP de entender cómo la red puede estar congestionada, porque como bien sabemos, la red nos feedbackea. Habíamos visto un tipo de mensaje "source quench" de ICMP, pero ya no está usado, entonces, es responsabilidad del TCP darse cuenta, así como, a ver, che, cómo estamos viviendo hoy, darse cuenta que esta red huele y congestiona, vamos a ser un poco más cuidadosos, vamos a bajar ritmo de transmisión, o, fuaa, esta red está fantástica en este momento, démosle fruta. Esa diferencia entre TCP, TCP tiene una manera heurística, que significa no determinística, sino va viendo eventos que ocurren con su stream, vamos a ver qué tan bien está pasando el stream que yo estoy tratando de enviar, y en base a eso se autofeedbackea para decir "ah, acá aparece haber congestión". ¿Sí? Bien. Todo esto lo vamos a ver en detalle, pero ahora como para introducción. Bueno, entremos entonces al TCP. Varios puntos de esto ya lo hemos hablado y visto. Hemos, básicamente, movido un stream de bytes, acá hay un concepto que se llama espacio de secuencia. Esencialmente, espacio de secuencia es TCP numerando lo que la aplicación le escribe, si la aplicación le escribió, por ejemplo, ¿ustedes tienen permitido a nivel de aplicación? Mi gatita, ahí está. Un segundito. Ustedes vieron cómo son los gatos con sus esclavos humanos. Un segundito. Ahí me ayudó Claudia. Se pone loco, y nota el pie. En particular, la desgraciada se pone loca cuando estoy hablando con otra persona, así por mí, y empieza a requerir, "dame bolilla, soy yo, soy yo". Bueno, ahí vamos, volvemos. Espacio de secuencia, entonces. Lo tienen que ver como una especie de ranurado a nivel de byte. Y acabo la pregunta. ¿Ustedes, como usuarios de aplicación de un socket TCP, un socket que hicieron un... ¿recuerdan cómo era para obtener un socket? Un socket de tipo stream, y después le mandan una syscall que es conecta, a destino, le pasan la IP del puerto, imaginemos que se conectan, y después ustedes obtienen un file descriptor, el cual básicamente, un descriptor de archivo, el cual ustedes escriben bytes. Y a ustedes ahí le pueden escribir un byte, o le pueden escribir un mega, si quieren. Y obviamente pueden seguirle escribiendo, pueden hacer, por decir, un while write en el descriptor del socket, le voy enchulando bytes. Entonces, el espacio de secuencia es como TCP modela esto, y básicamente es un concepto súper simple. Empezamos desde cero, vamos a ver que eso es mentira, no es cero literalmente, pero conceptualmente pensémoslo como cero. El momento en que me escriben, nada, el momento en que se estableció la conexión estamos en cero, y si la aplicación me escribió en 10, yo muevo el space de secuencia en 10, y lo voy moviendo de acuerdo a la cantidad de bytes que me escribió la aplicación, y esto me sirve a mí para medir también cuántos bytes he logrado pasar con éxito al otro lado. Es súper importante porque siempre hay como, el espacio de secuencia es como que tiene offsets o marcadores en juego, ¿no? ¿Cómo empezaría? Imaginémonos de un estado conectado, un socket conectado, que estamos en cero, espacio de secuencia en cero, la aplicación me escribe mil bytes, por ejemplo. Entonces yo muevo, tengo mil bytes de problema ahora, como TCP. ¿Por qué es mi problema ahora? ¿Cuál es el problema que tengo que resolver de estos mil bytes de espacio de secuencia? Yo como TCP, ¿qué problema tengo que resolver ahora? Google, hello. Yo soy TCP, la aplicación escribió mil bytes, y los tengo acá en el buffer de transmisión de TCP, estos mil bytes. ¿Qué problema urgente tengo que resolver yo como TCP? Los guardo, los mil bytes, esperamos un rato, qué sé yo, los dejamos ahí, mañana hacemos algo con esto. Total, tengo memoria de sobra. Habría que ver cómo enviarlo, o sea... Mi problema urgente es, tengo que sacármelo de encima. ¿Y qué es sacármelo de encima? Enviárselo al otro lado. Si esa es mi misión, es transmission contra protocol por algo de la T. Si tengo la T, así como si fuera Superman, acá la T dibujada en el pecho, de TCP, yo tengo que resolver el problema de transmitir esto, de enviarlo. Entonces, cuando el espacio de secuencia de todo lo que ya he transmitido coincide con el actual, le hace más simple, no tengo ningún nada buffereado para enviar, tranquilo, yo TCP al menos del lado, de este lado transmisor. Pero apenas la aplicación escribe, yo tengo todo este problema, y mi problema ahora es puchear, empujar estos bytes que le lleguen al destino, que el destino me confirme que le han llegado bien. Ese es mi problema ahora, y ahí tengo esa discorriente, tengo el problema de rascarme la cabeza y decir, bueno, ¿cuál es el MTU que tengo? ¿Cuál es el PMTU que tengo? ¿Entran estos 1000 en los PMTU? Típicamente sí, porque el PMTU es 1500, entonces listo, le pongo la cabecerita, puerto, origen, puerto, destino, entonces lo vamos a ver los puertos, y se lo mando a IP, y vamos a ver, yo tengo que confirmar que eso llegue, porque yo como TCP, a mí me pusieron la estampa de que yo hago entrega asegurada, entonces tengo que estar seguro de que llegue a otro lado, sin errores y qué sé yo, entonces no es que escriba esos 1000 bytes como IP, que se hacía muy del pistola y lo escribí y listo, lo enviaba en su datagrama, sino que yo tengo que pelear por esos 1000 bytes. Entonces, el espacio secuencia es una manera ordenada en que TCP mantiene estos offsets, estos punteros de, ok, estamos acá, la aplicación escribió esto, yo he logrado puchear esta parte, nada más, me falta puchear esto, apenas me vayan confirmando el lado receptor que llegaron bien, yo sigo pucheando, pero es como que hay varios, ¿se entiende esto? ¿no? Varios offsets, ¿no? Hay un punto de arranque que es todo lo que he logrado confirmar que llegó bien y que ya no es problema mío, porque el otro lado me confirmó que llegó ok, ya no es problema más mío, pero yo tengo cuánto está en vuelo, cuánto ha potencialmente escrito la aplicación, yo tengo que jugar con ese espacio secuencia y como es y siempre, obviamente, mi objetivo final es colapsar los espacios de secuencia, mejor dicho, un solo espacio de secuencia, pero colapsar estos offsets, tal que todo lo que recibió el otro lado sea exactamente todo lo que ha escrito hasta ahora este lado. Y esa es la misión del TCP. Y cuando esos se separan, es mi momento de empezar a empujar esos bytes al otro destino, a debufferearlos, ¿no? Los bufferea mi buffer de transmisión que está en el kernel, parte de TCP, y yo tengo que tratar de empujarlos para que el otro lado me confirme y ya estar seguro que pasa. Esa es la misión del TCP. Sí, vamos. Había dicho del PMTU, ¿eso es problema de TCP o de IP? En realidad de los dos, es interesante. Nosotros lo vimos en IP, vimos que IP colaboraba con LEF=1 en caso de IPv4, pero es TCP quien tiene que ajustar el tamaño del segmento. Y a USA y P, TCP va a intentar, esto es lo que hace TCP, imagínense que no ha tenido feedback previo contra el destino S. Pueden estar muchos hops hacia adelante, ¿no? Varios, como bien sabemos, la Internet tiene al menos, no sé, por decir algo, 10 hops hasta los host de Estados Unidos, 15 hops hasta Europa. Si hay muchos hops hacia adelante, yo no sé cuál va a ser el MTU. Pero yo arranco sin memoria previa, yo TCP y digo, ups, me acaban de escribir 10.000 de aplicación, ¿no? La aplicación dice un write de 10.000 bytes. ¿Cuál es el mejor feedback que tengo? Yo tengo que empezar por algo. ¿Por cuánto empiezo? No tengo PMTU aún, no tengo path MTU. ¿Cuál va a ser un valor razonable para empezar, como para no molestar al stack IP acá local? Si me escribieron 10.000 y bueno, empecemos con 2.000, ponele. ¿O no? ¿Empecemos con 500? ¿No? ¿O sí? ¿Para cómo definís qué número? ¿Qué número tengo para mirar? Yo TCP. TCP, como bien sabes, no, recordamos que los implementadores de TCP hicieron un firulito con la separación de capas estricta y dijeron, no, no, no. Acá para que esto performe, los protocolos de distinta altura tienen que ser capaces de ver hacia abajo y hacia arriba para optimizarse. Y acá TCP puede hacer una trampita, ponerse una lupa y mirar hacia abajo y decir, "Upa, no tengo un tamaño razonable. A ver qué tamaño razonable puedo ver en algún lado como para que esto empiece a andar más o menos bien, sin fragmentar, sin subutilizar la red". ¿Qué usarían ustedes? El de la propia red. ¿Qué es eso? ¿Qué es el de la propia red? El MTU que te he definido con el router. Ah, casi. El MTU, no, pero va bien. El MTU de la interfase por la cual yo obtengo la ruta de destino, ¿no? Yo voy a tener muchas rutas. El caso más simple, típico, el de siempre, un host finado con un solo gateway. Veo el dispositivo que me saca el gateway, leo el MTU. Fíjense que estoy leyendo desde el capa 4 una propiedad de capa 2, de capa de enlace. Pero esto es para ayudarle a la capa 3, para no mandarle verdura a la capa 3. Decirle, "Ah, yo soy TCP, vos capa 3, vos podés 64K y me escribirán 10K. Listo, te mando 10K tu problema capa 3". No, no, no, para. Yo me fijo abajo tuyo, abajo de IP, me fijo, "Vos tenés 1,500 abajo IP". Voy a ser gentil, te voy a armar un datagrama que a vos IP te va a hacer que no fragmentes. Fíjense, ¿no? Capa 4 mira capa 2 para hacer que la capa 3 no fragmente. Entonces, hay como una, hay muchos de estos shortcuts, de estos atajos de implementación, de optimización que usa TCP. Todos los atajos de TCP IP. Bien, entonces, ahí vamos. ¿Y qué usarían entonces como resultado? 1,500, ponles y fueron a Ethernet. Y ahí van, de esos 10K que me escribió la aplicación, van los primeros pedacitos de 1,460. Porque tenemos de los 1,500 que entran en Ethernet, le roba 20 cabeceras IP4 y vamos a ver la mínima, la típica. Y vamos a ver que TCP también tiene una cabecera de 20, casualmente. Entonces me quedan 1,460 de esos 10K que me escribió la aplicación. Yo del espacio de secuencia de 10K, que es mi problema ahora, yo tomo los primeros 1,460, corto, recorto, y los meto en un datagrama que entra justito, así tipo Chef, tipo gourmet, entra justito en los, IP le pone su cabecera y entra justito en los 1,000 de Ethernet. Y allá va, prendo una velita, mentira. Y allá va, y ahí es donde entonces sí puedo encontrarme con que un router en el medio tenga una depresión de MTU, porque, por ejemplo, tiene un túnel IPIP, como mencionaba Diego, y no pasa 1,500, el próximo, el próximo capa de link tiene, voy a redondear, típicamente no es así, 1,400. Entonces no va a pasar, ¿y qué ocurre? Ya lo hemos visto. El router descarta, envía un ICMP de regreso, y lo que es interesante es que, ¿a quién afecta ese ICMP? ¿Capa de enlace, capa de red o capa de transporte? La capa de red. Es leído por la capa de red porque dice "MPS capa de red", pero ¿quién actúa en consecuencia? Recuerden, yo fui TCP, no de manera naive, puse un mensaje, digamos, corté mi 1,460 de datos y terminé armando algo para que el datagrama final de IP fuera milky. Y allá fue, se encontró con una depresión de MTU, se descartó, y vino un ICMP de FIBA diciendo "Ah, este no pasó, el próximo MTU en el camino que tengo es 1,400". Vino por ICMP, por lo tanto sí, claro, lo tomó la capa 3, pero ¿quién lee eso y quién actúa en consecuencia? ¿Quién se optimiza? ¿Quién aprende eso, en definitiva? Y la capa 2 ahí. ¿Capa 2, capa de enlace? ¿Ethernet cambia ahí? No, bueno, o sea, si la capa 1. ¿What? Físico, le cambiamos el voltaje al cable de red. Me estoy confundiendo. Sí, no, no hay problema, no hay problema. Fíjense, no, pero está bien, el ICMP viene de regreso con una información importante, la información que acarrea es "Ah, milky no, milky no, no pasó, este milky no pasó, en realidad te estoy informando que tenés 1,400 en el camino". Entonces sí llega la capa 3, pero eso pasa a TCP, y ahora TCP en vez de decir en una forma naive "Y milky, porque es la Ethernet que yo tengo", dice "Ups, acá me vino un mensaje ICMP, yo tengo que memorizar que hacia ese destino tengo 1,400 en el camino". Entonces yo TCP, en vez de volver a intentar enviar estos milky, ¿qué hago? Lo hago más chico. Lo hago más chico, lo hago de 1,360 más cabeceras a 1,400 porque ya he aprendido que en la red hay eso. Entonces, la respuesta es ICMP que acarrea la info importante de que hay una depresión de MTU con 1,400, la recibe ICMP, pero la lee TCP para adaptarse a ese PMTU. Y ahí responde tu pregunta respecto del PMTU. Es TCP en definitiva quien va memorizando esos PMTU y va actuando en consecuencia. Pero fueron descubiertos con la ayuda de la capa de red, con ICMP. Seguimos. ¿Se entendió? Perfecto. Marvelous. Bonici. Confiable y con entrega ordenada. ¿Podría ser confiable y con entrega desordenada? ¿Podría ser no confiable y con entrega ordenada? - Sí, yo creo que podría ser no confiable. - A ver, ejemplo. Primero, definimos confiable. Confiable se refiere acá de que lo que leo es lo que se escribió. Si yo logro leer este pedazo de secuencia de bytes, si dice hola mundo, no dice, perdón, si dice hola, no voy a leer aló, voy a leer hola. ¿Sí? Hola. Perdón, te interrumpí. ¿Me decías que podría ser con entrega no ordenada? - No, decía que tal vez si la entrega es no confiable, podría igual ser ordenada. Igual después me puse a pensar que si es no confiable, puede ser que justo los, digamos, los bytes donde te dice el orden sea la parte no confiable. - Está bien, no, pero está bien, bien podría ser. De hecho, SSTP tiene algunas características, así que este protocolo está como en el medio de WP y TCP. Bien podría ser que vos tenés una entrega confiable. Es decir, si vos leíste algo, no tiene ningún bit flipado en el medio. Si no va, si el otro pedazo escribió hola mundo, vos no vas a leer conejitos mundo. ¿Sí? Vos vas a leer hola. Pero bien podría ser, no es el caso de TCP, que sea confiable sin entrega ordenada. Imagínate, hola, como mundo estás. ¿Sí? Bueno, bueno. Es el garantido de que los bytes que se escribieron fueron sin fliparse, pero no había entrega ordenada. Es una locuración teórica poco práctica, pero lo que estoy tratando de generar en ustedes es romper estos conceptos, porque se ayudan para hacer un protocolo razonable en la vida real, pero en realidad son conceptos distintos. El hecho de que estar seguro de que hay un checksum o algo que me protege este pedazo de data para estar seguro de que es leído tal cual se escribió. Y otra cosa es que venga ordenado. Bueno, TCP tiene todo en entrega ordenada. ¿Por qué? Porque TCP trata de emular esto que vengo insistiendo, que es el modelo de una manguera continua y potencialmente infinita de bytes. Algunas otras características de TCP que tiene un ACK positivo y no tiene ACK negativo. ¿Alguien me puede un poco explicar qué podría significar eso? Y qué es ACK. ACK es por ACK Knowledge, que significa OK, básicamente. Y que es positivo y no negativo. Eso tiene una serie de condiciones de diseño que están súper interesantes de discutir, que es lo que vamos a discutir ahora. Porque se confirman los dataramas que llegaron o sea, las partes que han llegado y no las que faltan. Mensajes. Segmentos. Perdón que te corrija, pero por esto que somos medio stock cuando hablamos en las distintas alturas del protocolo. No, sí, está perfecto. A esta altura son segmentos. ¿Por qué? Porque TCP justamente en la secuencia, en el espacio de secuencia, lo que hace es segmentarlo. Como bien sabemos de cuando incluso íbamos a la primaria, los segmentos tienen una rayita de comienzo y de fin. Entonces TCP, el problema es enviar estos segmentos de un lado a otro. Entonces, bien. Entonces, me estabas diciendo, con lo del ACK positivo. Sí que enviamos, por ejemplo, el segmento 1, 2 y 3 y encima me llegó el 1, me llegó el 2 y el 3 no me llegó. Mandamos el 4. Y como no me llegó el 3, para enviar algo que no me respondieron, que llegó entonces, creo que hay un tiempo de espera y lo vuelve a enviar a partir del último no confirmado, digamos. Buen resumen eso. Y hay una razón, ¿cuál les parece a ustedes puede ser la razón para el otro lado no largarse a decir, "Che, no me llegó el 3". ¿Está claro que... No hay que llegar tarde. Bien, ok. Además yo no sé si existió o no, hay una cuestión hasta causal ahí. Yo, el lado receptor, imagínense, recibo 1, 2, qué sé yo si existe el 3, no le puedo decir "Che, ¿y el 3?" Capaz que el 2 terminó, por este momento. Hay otra condición en la cual sí podría ser activo el lado receptor y decir "Che, el 3, el 2 vino horrible, no pasó el checksum". Yo leo el 1, obviamente como es confiable, hago chequeo de checksum, todos los bits correctos, papá, yo iba. Levanto el 2 y falló el chequeo de checksum. Y yo del lado receptor ahora estoy en un problema, así "Che, le aviso a la origin que esto llegó flipado". Qué malo, el ordenador de TCP, ¿qué le hubiera costado hacer que los receptores de TCP le dijeran a los transmisores de TCP "Che, llegó mal esto", para que "Ay, no más rápido, se corrija". Lo que hace, lo descarta y como nunca le llega el acuce de recibo positivo después de cierto tiempo lo reenvía. ¿Y por qué hicieron eso y no hicieron lo que yo le estoy proponiendo ahora de hacer un rápido acuce de no correcto, NAC? Supongo que es más pesado para la red. A ver cómo sería ese escenario. Sí, porque hay que intercambiar más información. ¿Y qué consecuencia final tendría? Pensémoslo en escala. Ahora estamos con la lupita en dos puntitos, que tiene el problemita chiquitito de que "Uh, me llegó este segmento con los bits flipados" y TCP por diseño no lo va a NACear, no hace nada del lado receptor, lo descarta completamente, no envía un ICMP, no envía nada, nada, nada. Lo descarta. Así. Y se queda calladito. Como bien vos decís, hay alguien aquí que está cuidando, está cuidando a la red. ¿Y por qué está cuidando a la red al hacer eso? Muy bien lo que decís, lo que quiero es que exploremos un poquito más por qué le está cuidando a la red. ¿Qué pasaría si de pronto, imaginemos, en una porción de la red que puede estar implementada, por ejemplo, por canales de wireless, que sabemos que tienen mucho más bit error rate que un canal wired, de pronto ocurre que en camino, los datagramas que acarrean segmentos de TCP empiezan a fliparse sus bits al pasar por acá. Pero no tenemos dos puntitos, pero tenemos todos unos pedazos de internet de un lado a otro y pasan todos con los bits flipados. ¿Y IP no hizo nada al respecto de eso? ¿Entre paréntesis? ¿No tenía un checksum IP? ¿Qué protege el checksum? ¿Las cabeceras? Nada más que sus cabeceras, es súper contra egoísta, IP dice no, yo te garantizo los primeros 20 bytes, lo que viene después no es problema mío, yo no te voy a proteger con mi checksum. Y eso es por diseño. Ok, entonces, volviendo. Tenemos una zona de la red ahí en el medio y tenemos un poco de internet, ¿qué pasa si la red empieza a flipar? Entonces, volviendo. Tenemos una zona de la red ahí en el medio, que tiene un montón de rayos cósmicos, interespaciales y demás, y los bits se flipan y llegan todos rotos al otro lado. ¿Qué ocurriría si todos los TCPs de este otro lado se enojaran y dijieran "Knack, knack, knack, knack". Tendrían que enviar más mensajes que harían que congestionarían más a una red y provocando quizás un nivel de error más alto. Y esto quizás sería un ciclo y cada vez se realimenta más. ¿Por qué? Porque más congestión, más potencialidad de error, más TCP de los otros lados que tienen problemas. Entonces, básicamente, el internet no existiría hoy. Si hubieran decidido poner "knack". ¿Por qué? Porque la realimentación de "che, hay un problemin" hace que el problemin sea peor aún. Entonces, súper importante. Fíjense, a nosotros nos gusta mucho no solamente pasear por el protocolo, sino entender cuáles son los criterios de diseño y entender por qué se eligió uno u otra cosa. En este caso, el hecho de decir "no, acá no hay knack, es todo hack". Y ser un problema del origen, entender así y decir "che, nunca me llegó el hack por esto y bueno, acá lo vamos a reenviar". Nunca tengo que hacer algo, ¿no? Tirar el problema al lado transmisor. Justamente, de vuelta, para cuidar un recurso preciado que habla poco, que es la red. Bien. Retransmisión. Todo esto nos lleva a lo que acabamos de decir. Retransmisión, si hay "hack timeout". Volviendo al ejemplo que mencionaba aquí el compañero, Lucas, decíamos si tenemos 3 segmentos como problema, yo envío el 1, recibí el ok del 1, yo, lado transmisor, ¿no? El segundo segmento, recibí el ok del segundo segmento, envío el tercer segmento, clic, clic, clic, clic, sabemos que no hay knack, clic, clic, clic, clic, y bueno, espero un tiempo razonable, ya vamos a ver qué sería razonable, y lo reenvío, ¿sí? Cruzando los dedos, entre comillas, de que finalmente se me hackea el 3. Recordemos que la misión de TCP es empujar espacios de secuencia. Si el receptor hackea espacios de secuencia, ya no es más problema del transmisor. Y ese es el objetivo, yo tengo que empujar esto que me escribió la aplicación, para que el otro lado me vaya hackeando todo esto, y yo igualar el cursor, si se quiere, sobre ese espacio de secuencia de lo que me hackeó el lado receptor, con lo que yo tengo para transmitir. Si los dos son iguales, no hay nada que hacer. Si los dos son desiguales, yo tengo que empujar esto para hacer que el otro venga. Y ahí viene un poco también el concepto de ventana deslizante, que a veces habla el TCP, es como que sobre este espacio de secuencia, el problema es nuevos bytes que se van sumando en el espacio de secuencia, y cómo yo tengo que lograr que el otro lado me vaya hackeando para asegurarme que esos bytes han pasado al otro lado. ¿Quedó claro más o menos eso? ¿Sí? Sí. Bien. Vamos entonces. Nuevamente tratando de resumir. Ahora quizás volviendo hacia una visión general. Básicamente el CP es lo del circuito virtual, lo que yo defino como esta manguera infinita de bytes. Como es orientada a la conexión, tiene un momento de establecimiento, de uso y de fin de la conexión. Para eso vamos a ver cómo son estos handshakes que alguien mencionó, estos tres mensajes de handshake. Existen los hacks como mecanismo para poder, el lado receptor, a su lado transmisor, ir diciéndole que sea recibido. Lo que es interesante es, a mí me gusta mucho, y lo hablamos recién, cómo TCP hace esta adaptación de una gestión de I/O hacia la aplicación, que tiene que ser una, es una gestión de input/output orientada a bytes, y hacia abajo, hacia la red, una gestión de input/output orientada a paquetes. Entonces, cómo TCP se tiene que agarrar la cabeza y tratar de convertir este continuum de bytes en algo que se corta en paquetes, que son los datagramas que después yo puedo enviar vía IP. Vamos a ver en gestión de la aplicación, cómo se ve hacer la aplicación. Creo que todos a esta altura ya conocemos lo que son los ports. Básicamente, como para dar una idea más formal, así como IP nos permitía identificar nodos en una red, los ports nos permiten identificar procesos dentro de un nodo. Si yo llego con un IP hasta un nodo, y subo, si llego con IP, capa 3, y quiero subir a capa de transporte, en transporte, detrás de un punto de acceso a transporte, un socket, siempre va a haber una aplicación. Entonces, la manera de identificar que es una u otra aplicación a quien yo tengo que entregarle este segmento, va a ser a través de los puertos. Ustedes ya lo conocen, hay puertos bien conocidos, 180 para HTTP, 443 para HTTPS, 22 para SQL, que permiten, son como puertos ya por, de hecho están en RFC, que definen lugares donde el lado pasivo espera que alguien se conecte. Y ya sabemos que a un 180 me voy a conectar para HTTP, a un 443 para HTTPS y a un 22 para SQL. Y aparece el concepto de apertura activa o pasiva, que está muy relacionado con el hecho de que sea orientado a conexión. ¿Alguien me puede, más o menos, comentar qué se imagina que es apertura pasiva o activa de un socket, en este caso, de un punto de acceso? Porque esta es gestión de I/O hacia la aplicación, que son sockets. ¿Qué es la apertura pasiva y qué es la apertura activa? La apertura pasiva puede ser cuando uno está escuchando en el socket solicitudes, por ejemplo, en las servidores web, que escuchan las solicitudes de las otras computadoras que se conecten, y ahí devuelve algo en relación a lo que suceda en el puerto. Y la activa vendría a ser el navegador solicitando al puerto 80, por ejemplo. Bien, buenísimo. [VOCES INTERPUESTAS] Contame. Uno sería del lado del cliente, puede ser, y otro del lado-- Vamos a dejar el tema del cliente-servidor, que típicamente cliente es activo, servidor es pasivo, casi por naturaleza. Pero vamos a posicionarnos más del lado de TCP, de que sea pasivo o activo. Pasivo es, yo abro este punto, un socket, y me pongo a escuchar. Típicamente es un servidor, el 99% de los casos es un servidor, ¿sí? Que dice, OK, yo me pongo a escuchar acá, y sí, tengo un montón de hermosas páginas web para servir en el 80, pero es pasivo, porque yo no es que salgo a buscar al cliente, "Eh, muchacho, ¿cuándo te venden?" ¿Sí? No, sino que abro el 80 y me pongo acá a escuchar a que alguien haga apertura activa. Alguien con un browser, le apunte a mi IP, puerto 80, y se conecte, y ese sí va a hacer una apertura activa, porque ese pide el socket e inmediatamente intenta conectarlo, activamente intenta conectarse al destino. Entonces, el TCP tiene un comportamiento distinto si es una apertura pasiva o una apertura activa. Hace cosas distintas. Que influyen en cómo se mueve cada uno de los lados en esta máquina de estados que referíamos cuando arrancamos esta charla, ¿no? De cómo estoy. Por ejemplo, fíjense que aparece acá otro estado interesante. Nosotros, cuando arrancamos esta charla, hoy simplificamos en estado, ¿no? Conectado, conectado, desconectado. Ahora, la apertura pasiva, ¿tienes estado? ¿Cómo describieron ustedes cuáles, si tuvieran que describirme los estados de un lado de apertura pasiva? ¿Cuáles serían los estados esos que transitamos? Esperando conexión. No conectado, ¿no? Es decir, cero. Vos pediste el socket, nada. No está, nada, ¿no? De hecho, si ustedes recuerdan la interfaz del socket, yo pido un socket y en realidad lo puedo mover hacia activo o pasivo, ¿no? No, no es que cuando yo pido el socket le digo "Che, voy a pedir un socket activo", no. Yo pido un socket. Ya vemos si lo hacemos activo o pasivo. Entonces, de no conectado, he pedido el socket, estoy listo, y entonces, ¿cuál es el próximo estado? Para un lado de apertura pasiva sería... Escuchando. Escuchando, "listen", ¿sí? Me quedo ahí, "pling", y ahí ese, bien puede ser ese mi estado infinito, si soy un website no popular, ¿no? Que nadie se conecta a mi socket, ¿no? Yo sencillamente me quedo ahí, "pling", esperando conexión. ¿Cuándo saltaría de estado? Yo del lado este, del lado que hice la apertura pasiva. Cuando alguien me solicite iniciar una sesión. Una sesión, recordemos que es conexión, sesión es capa 5, ¿no? Protocolo de transporte. Una conexión. ¿Una conexión? ¿Sí? ¿Una conexión? Entonces, sí, hay que hacer del otro lado una apertura activa, cuya máquina de estado salta de no conectado a conectándose. Se intenta conectar a mí, entonces ahora sí ya saltamos de escuchando a conectando, o quizás iniciando conexión, o respondiendo a un inicio de conexión, en estado intermedio, y si todo va bien con el handshake, ahí "rapidito", entre comillas, "rapidito", salta a un estado conectado. Cuando ambos lados logran estar en ese estado conectado, recién pueden intercambiar datos. Bien. Entonces, es importante, fíjense qué distinto, qué asimétrico es una apertura pasiva de una apertura activa. Bien, eso era, eran algunos aspectos de, recuerden TCP/4 tiene arriba aplicación, y abajo tiene red. Entonces veíamos cómo se comportaba hacia la aplicación, gestión de I/O hacia arriba, hacia la aplicación. Gestión de I/O hacia la red, justamente esto es lo que tanto venimos insistiendo, de que transforma un stream continuo de bytes en segmentos finitos, que tienen un comienzo y fin, que terminan siendo datagramas, datagramas de IP. Bueno, y acá ya hemos estado hablando de cómo hace la gestión, pero ya vamos a volverse a estos aspectos de la transmisión y demás. Un aspecto interesante también es el control de flujo en transmisión, y acá viene un concepto, le vamos a decir hola, al concepto de ventana. Vamos a ver que TCP maneja dos ventanas, y vamos a ser bastante molestos en cómo hace el manejo de estas dos ventanas. Entender cuál es la diferencia, en cómo se ayudan y qué significan. Ventana de recepción, es una ventana de terminística, que la escribe el lado que dice, mirá, yo tengo esta cantidad de bytes disponibles para que vos envíes. ¿Qué lado será? ¿El lado receptor o el lado transmisor? El que dice eso. Casi que dice ventana de recepción, lado RX, en bandeja, lado receptor. Y es, estrictamente, es el tamaño del buffer de recepción. Es así, literalmente. Típicamente una implementación de hoy en día, por más memoria que tenga, yo no sé cuántos sockets vamos a tener, podríamos tener ustedes bien. Tenemos 200, siempre andamos con 200 millones de tabs abiertos con cada página web que puede tener una conexión para el HTML, otro para el AJAX, otro para descargar imágenes, otro para descargar updates. No puedo asumir que puedo usar toda la memoria para los buffers, con esto quiero decir que los buffers de recepción y de transmisión son relativamente chicos para los tamaños de memoria RAM que hoy manejamos. Andan en el orden de los 32K, 64K, no es mucho más. Imaginemos 32K, que es un número bastante típico. Entonces yo tengo, yo, lado receptor, acaban de conectarse, yo le digo al lado transmisor, "tenés, tengo 32K para recibirte". Porque acaba de establecerse la conexión, socket conectado, y en el kernel, hay un espacio de 32K. ¿Quién va a ir llenando ese buffer de 32K? Como todo buffer tiene alguien que lo llene y alguien que lo vacía. ¿Quién llena ese buffer de 32K? ¿Y el transmisor, digamos? El lado transmisor, estamos hablando del lado receptor, ¿no? Yo como el lado receptor del TCP, ese buffer está dedicado a vos, transmisor. Quiere decir que vos lo que me vayas enviando, yo lo voy a ir poniendo en este buffer. Ejemplo, recuerden que son 1460, no son 1500, por el tema de las cabeceras, yo lo voy a simplificar en 1500. Imaginemos aproximadamente entonces, 1500 pedazos de data que van llegando acá, ¿sí? Vamos a redondearlo más fácil, vamos a redondearlo en 1000. Tenemos 32K, vamos a redondearlo en 1K, en 1024. Tenemos 32K, viene un segmento de 1K, ¡pling! Ahora tengo 31K disponibles, yo le digo al lado receptor, le corrijo y digo, ojo que ahora tengo 31K. El lado transmisor lee eso, entiende que tiene 31K, sigue enviando, por ejemplo, a pedazos de 1K, manda otro K, ahora tengo 30K y yo le digo al otro lado, mirá, tenés 30K. ¿Sí? Y esto va, siempre hay un juego ahí en que el lado receptor le va diciendo, mirá, yo tengo este espacio de buffer para recibirte en este momento y el lado transmisor tiene que entender eso y tiene que obviamente obedecerlo. Si el otro lado me dice que tiene 10, tiene 1K de espacio de recepción, no le voy a mandar 2K, tengo que obviamente, obviamente tengo que obedecerlo. Bien. Entonces, dijimos, quien llena el buffer de recepción es el lado transmisión. ¿Y quién vacía el buffer de recepción? El receptor. No me hagan trampas, muchachos. Es como diciendo, ¿quién implementa el transporte? Y el transportador. ¿Quién vacía el buffer de recepción? Está muy relacionado con el diálogo que tenemos frente a nosotros. Si el buffer de recepción lo está llenando el lado transmisor, a medida que van llegando los segmentos se van poniendo acá y se va dejando listo, de vuelta son pedacitos, esa manguera infinita de bytes, son justamente secuencias de bytes, que se van, plin, plin, plin, plin, acá ordenando en el buffer de recepción. ¿Y quién me lo limpia el buffer de recepción? El protocolo TCP. Ah, ah, no. El reboot de la máquina me lo limpia. Uy, se llenaron los buffers de recepción. Control, alt, del, de. ¿Quién debería ser ahí el que esté recontra despiartito, así, no como ahora, sino así recién levantadito a la mañana o a la siesta, a la hora que sea que nos estamos exportando en esta época de pandemia, y decimos, uf, vamos a limpiar este buffer de recepción. ¿Quién es el que tiene que estar ahí atento y despejando buffer de recepción? Porque si yo me olvido de limpiar el buffer de recepción, ¿qué va a pasar? Vamos por ese camino y después volvemos sobre el quién. ¿Qué pasa si acá nadie atiende este buffer de recepción y seguimos con esta secuencia? Imaginemos que el lado transmisor tenía para transmitirnos un mega. Yo tengo 32K del lado receptor. El lado transmisor está siendo secuencial, ya vamos a ver cómo eso se hace realmente. Está mandando de un K siempre, ¿no? Un K, ok. Blink, act, a un K. Está todo divino acá en la red. Estamos en una LAN local, súper divino todo. Pero dice ventana 31, ventana 30, ventana 29, ventana, sigue pasando el tiempo, ventana 4K, el otro le escribe un K, ventana 3K, el otro le escribe un K, ventana 2K, ventana 1K, ventana, ventana 0. Y el otro lado del transmisor, pobre, tenía como un mega para transmitir, el cual solamente pudo enchublarle 32K hacia el otro lado. Porque esto 32K está con buffer lleno, básicamente, del lado receptor. ¿So? ¿Quién limpia el buffer receptor? El sistema operativo, no sé. Lo descarta, lo limpia, cada tanto pasa la... para escribir el protocolo de transporte. O la aplicación que va consumiendo. ¡Ah, bueno! Un protocolo de transporte no existe en sí mismo. Existe para brindar un servicio a la aplicación. Entonces la aplicación, la que tiene que vaciar, ¿cómo una aplicación vacía un buffer recepcion? De una manera elegante y difícil de decir que la aplicación está haciendo un... La aplicación vacía el buffer recepcion haciendo un... como en los crucigramos, le ponemos ahí en palabra en inglés, cuatro rayitas. Aplicación vacía buffer recepcion cuando hace qué. ¿Cómo interactúa la aplicación contra un socket abierto, contra un file descriptor? ¿Cuáles son las cosas que empieza a hacer una aplicación contra un socket? Dump, puede ser. Dump no existe. Como syscall, una syscall. Yo te doy un... hiciste connect, socket, hiciste connect, se te conectó, está todo divino, tenés un file descriptor, que es un numerito. Pero vos tenés una interfase de un SDK, el socket SDK, Berkeley socket SDK, pero en definitivo, en el caso de los sistemas que estamos acostumbrados a programar, es un descriptor, y ya un descriptor, ya sea de archivo o de socket, ¿qué le hago? Como flujo de I/O de la aplicación. ¿Qué puedo hacer contra un descriptor de archivo? ¿Qué le hago típicamente? ¿Puedes abrir una aplicación, muchachos? Si abren un archivo, ¿qué le hacen? Mmm... No, no. Open file. Y después, ¿qué hago? Imagínense que, no sé. Un read. Bien, read or write. Sí, read or write. Sí. Sí, read or write. Así de simple, read or write. El lado de transmisor de TCP, lo que hace es responder a los writes de la aplicación, y la aplicación, la desgraciada aplicación, me hizo un write de un mega, yo tengo nada más que 32k de ventana al otro lado, entonces le voy empujando a pedacitos de un k, que es lo que me permite la red abajo. Pero tengo que tener la colaboración de la aplicación, ¿y cómo entonces? Ahí vamos de vuelta a la preguntita de cruciagrama. La aplicación despeja el buffer de recepción haciendo un... Read, read. Read. Muy bien. Ahí. Sucesivo read, en realidad. Y es ahí donde la aplicación tiene que estar despierta. Tendrá algún mecanismo de señalización, tal que la aplicación se la avise, y acá hay algo en este descriptor, viene la aplicación, y yo estoy teetralizando, estoy rápido despeja, ¿por qué es importante que la aplicación rápido despeje y haga algo con esos bytes? No sé, qué sé yo, depende de qué está haciendo. Por ahí la aplicación es un browser que está recibiendo un flujo HTTP con contenido HTML para desplegarlo en su navegador, entonces el browser irá consumiendo este socket y irá... y mostrándoselo a ustedes. O puede ser un descargador de torrents que tiene que despejar este buffer y empezar a escribir los segmentitos de datos, los pedacitos, los chunks de datos en el torrent de ese ISO que se están bajando, ¿no? Pero ¿por qué es importante que la aplicación esté despierta y vaya rápido y haga el read? Y para la parte de la aplicación, para completar el archivo que esté utilizando, como decíamos, el HTML, no se lo puede mostrar en completo. Porque si no hay el... no me sale la palabra... el que está enviando los datos no puede seguir enviando, digamos. ¿Por qué no puede seguir enviando? Porque se llena el buffer. Ok, bien, ahí está, se llena el buffer. De todos los aspectos estos que habíamos visto en la diapo 3, ¿de cuál estamos hablando ahora, entonces? Control de flujo. Control de flujo, exacto. Y ese es cómo se materializa el control de flujo en el caso de TCP. En el caso de TCP, el control de flujo es justamente esto, y quien implementa eso byte a byte es la ventana de recepción. Y de hecho hay momentos en donde el TCP receptor puede decir, listo, acá la aplicación se fumó, no vino a leer más el socket, yo tengo 32K super lleno, lado transmisor, sorry, ventana cero, pling, ventana cero, listo, vos tendrás gigas para transmitirme, pero acá hay ventana cero, y no podés transmitirme, los perderías, porque acá no tengo más para buffer, no te voy a inventar espacio de buffer acá. Buffer se llenó, chao, ventana cero, no transmitís más. Cuando la aplicación se despierte y empieza a consumir, entonces yo te voy diciendo, ah, bueno, acá hay un K de buffer, 2K de buffer, 15K de buffer, entonces eso te va a dar a vos, lado transmisor, el, entre comillas, permiso de poder seguir enviándome segmentos para yo seguir acá, ¿no? ¿Se entiende eso? Entonces es como que la aplicación es importante siempre, en cualquier escenario, que despeje esos buffers, porque eso le da oxígeno al lado receptor para poder decir al lado transmisor que sigue enviando. Estamos... Sí, quería solamente un ejemplito, un último ejemplo. Yo tengo una duda. Decime. Y eso de que le envíe, le dice que me queda 30 espacios o 20 espacios, ¿cómo se llama o qué le está enviando? Ventana Reception, RxWindow. Ahora lo vamos a ver, justamente la clase que viene con los cerebros de usted y los nuestros, mucho más fresco. Vamos a ver estos dos, que acá vamos a hablar mucho de todo eso. Pero es Ventana Recepción. Y se escribe en la cabecera, Visión al futuro, fíjense que acá está la cabecera y acá hay Windows. Acá se escribe literalmente. Estos bits, 16 bits que tengo acá, son para decir al otro lado, tengo cero o tengo... Les miento, 32K, porque fíjense que dice que tiene 16 bits nada más. No, siempre 32K, miento, me auto-miento. Tengo 32K, tengo 10K, tengo cero. Y eso lo escribo yo del lado receptor en ese. Fíjense que no es opcional, forma parte de la cabecera TCP y tiene un lugar dedicado para siempre en la cabecera. Porque es muy importante decir al lado receptor cuánto espacio, cuánto permiso tiene para escribir. Solamente quería ponerles, quería... ¿Sabes que los buffer tienen como máximo 65K? Lo vamos a ver, en realidad hay un truco, hay un hack de TCP para aumentarlo. Hay un hack. Que le agrega unos bits más para poder llevarlo, se pueden llevar hasta a un giga. Pero es con extensiones de TCP. Es como que imaginate, dijera, "Uh, muchachos, nos quedamos recortos". Bueno, pongamos una opción a TCP y le aumentamos la cantidad de bits. Es como que vos hubieras... Se llaman literalmente... ¿Cómo es? Ventana Amplified... No me sale la palabra, pero es una extensión de TCP que te permite expresar una ventana más grande. Pero está muy bien tu observación, está muy muy bien. 2A16. Pregunta. A ver si tengo acá... No tengo ningún USB. Ah, sí, acá tengo. Tengo un disco USB 2.0. No se lo estoy tratando de vender ahora. Esto no es un add-on, un bonus track de venderle este disco viejo USB 2.0. USB 2.0 ¿a qué velocidad graba? ¿Más o menos? ¿Más o menos? 600 GB por segundo. 1K por segundo, 10 MB por segundo. ¿A cuánto graba más o menos? 500 MB. No, no, eso es USB 3.0. Bueno, no importa. Vamos a asumir que este es tan viejo que graba a 1 MB por segundo. 1 MB por segundo. Vieja, asaso. Ustedes capaz que nunca han visto... En realidad es USB 3.0, pero estamos teatralizando el problema. Imagínense que acá yo tengo algo que es capaz de escribir acá a 1 MB por segundo. ¿A cuánto labura una red de 1 GB? De vuelta, números grandes, números, potencias de 10. 1 GB por segundo. ¿A cuánto puedo escribir de un lado a otro? 1024 MB. No, eso sería 1 GB. Es a 1000 MB por segundo. Sí, es 1 GB. ¿Cuántos bytes? Redondeando, súper redondeando. ¿Cuántos bytes? Que están más cerca a lo que... Que están en la misma unidad que yo les digo acá, 1 MB por segundo. ¿A cuánto escribe una red de 1 GB por segundo? ¿A cuánto mueve, no a cuánto escriba? ¿A cuánto puedo mover? ¿Bit a byte? 125. Bien, ahí estamos, 125 MB por segundo. A mí me encanta porque por suerte tenemos la excusa de las cabeceras, así que podemos redondear muy tranquilo a 100 MB. Si tengo 1000 MB, ¿cómo puedo redondear? ¿Cómo puedo redondear? Así que podemos redondear muy tranquilo a 100 MB. Si tengo 1000 MB por segundo, en vez de dividirlo en 8 lo divido en 10 porque le agrego ahí burocracia cabecera, qué sé yo. Y de paso, no, y sobre todo me da un orden de magnitud. Entonces, 100 MB por segundo, 100 veces más rápido que esto. Esto, 1 MB por segundo. ¿Qué pasa si yo tengo lo siguiente? Imagínense. Conecto esto a un host destino. Plac, lo conecto a un host destino. Host destino acá. Host origen y yo quiero copiar algo directamente al disco, sin pasar por el disco interno del host, porque bien puede no tenerlo, puede ser, no sé, puede ser un, como un router WRT, esos que tienen USB. Yo quiero escribir directo desde acá a ese disco. Estoy haciendo un backup remoto, ¿sí? Estoy tomando, no sé, archivos que yo tengo en esta máquina satélite y lo estoy backupeando a este disco que lo tengo conectado a este host remoto. Las especificaciones son tales que tengo discos súper rápidos acá porque tengo una máquina como la que tenemos hoy, como NessSD, que tienen literalmente gigabytes por segundo de ancho de banda, de disco, acá, en esta máquina. Pero tengo una red que es capaz de mover a lo que acabamos de discutir, 100 megabytes por segundo y tengo un destino final, este, que escribe a un megabyte por segundo. ¿Qué les parece? ¿Cómo se van a comportar, si yo tuviera que medir el promedio de velocidad que yo absorbo en la red, cuál va a ser ese promedio de velocidad? Y el más lento. ¿Cuánto? El más lento, uno. Bien, bien. No va a ser 100, yo voy a tener como bursts, ¿no? Voy a ver como... De 100, porque la red no tiene un potenciómetro para trabajar a uno o a 100, siempre trabaja 100 megabytes por segundo, o un gigabit por segundo. Entonces yo voy a tener estos bursts. ¿Y quién va a ser ahí el que va a terminar ajustando y decir "no, loco, esto es divino, acá tenés SSDs, acá tenés una red de 100 megabytes por segundo, pero el destino final es un megabyte por segundo"? ¿Qué va a ocurrir con ese buffer ahí en el medio, ese 32K, el buffer de recepción? ¿Va a estar la mayor parte del tiempo lleno o vacío? Lleno. ¿Por qué? Sí, porque se va a estar escribiendo más rápido lo que se puede ir leyendo. Bien. Y la red le va a ir diciendo "esperá que tengo que terminar de escribir". Muy bien, muy bien. Perfecto, ahí la aplicación no es que sea, no es que sea, que esté "lazy", que esté, ¿cómo es? ¿Qué vendría a ser? No es que la aplicación sea lenta o esté mal diseñada, sencillamente que la aplicación lo que hace es leer del socket y escribir en el disco y no le queda otra que un megabyte por segundo, entonces va a sacar el socket y leer ese disco lento al ritmo que le permita, como muy bien dijeron, el más lento de todos estos. Por lo tanto, este buffer va a estar fundamentalmente lleno. ¿Sí? A medida que la aplicación es capaz de escribir, a medida que el disco le permite decir "ah, bueno, ahí te voy escribiendo más", le va a ir despejando pedacitos de buffer al otro lado del transmisor y eso le va a ir dando permiso al otro transmisor para seguir enviando segmentos. Pero va a ser una cosa medio "varsity", ¿no? No es que voy a llenar de 100 megabytes por segundo, 1 gigabyte por segundo, constante, sino que va a ser... Es más, literalmente sería 1 cada 100. Es como que... Pasa 100 veces... Porque hay una relación de 1 a 100 entre la velocidad del disco y la velocidad de la red, ¿no? Va a haber una cosa así. Si uno tuviera que reflejarlo sería un cosito rápido, un palito que es 100 veces más chiquito que todo el silencio, 99 de silencio, 1 de envío, 99 de silencio, 1 de envío. ¿Sí? Y el que va a estar haciendo, literalmente, buffereando en el medio es el buffer de recepción. Bien, solamente quería dejarles esa idea como para terminar de bajar el concepto de cuál es la misión del control de flujo en un buffer de recepción en un caso como este. Así que, bueno. Muy bien, estamos terminando por hoy, voy a terminar la grabación y, Salvo que tengan alguna duda concreta respecto a lo que hablamos hoy. Yo sí. Sí. Cuando hablábamos de puertos, que dice que los puertos identifican un proceso o servicio. ¿Está limitado un puerto por proceso? O si uno quiere puede tener todo un proceso. No, no, no, es interesante, muy buena pregunta. Es interesante porque típicamente uno piensa que es 1 a 1. Vos tenés un web server atendido en un puerto 80. Pero bien puede ser, en ambos sentidos, bien puede ser que el web server no tenga un solo proceso web server, atiende el 80, atiende el 443 y quizás tenga un puerto administrativo en el 8080, por el cual vos te conectás para administrarlo. Es decir que un proceso puede tener varios puertos. Y a su vez lo opuesto, que es quizás el caso más interesante, un solo puerto con multiproceso. A lo 80 este lo están atendiendo 4 instancias de mi web server. Y ocurre, oh, qué casualidad que yo tengo 4 cores, 4 CPU en esta máquina. ¿Para qué sería eso? ¿Qué les parece? Claro, exacto. Entonces yo, bien puede ser un solo puerto, no digo una conexión, ahí ya es otro problema más complejo. Pero un puerto, por ejemplo, especialmente en modo pasivo, ¿qué ocurriría? Imagínense, somos 4 cerebritos, 4 procesos, atendiendo nuevas conexiones en el 80. ¿Y qué ocurriría a medida que van llegando las conexiones activas del lado cliente? Abre Control 80. Va a un proceso. A un proceso. Y ese se queda dedicado a esa conexión. El proceso A queda dedicado a esa conexión. ¿Qué pasa cuando viene la próxima conexión? Va a otro proceso. Proceso B. Y así se multiplexan las conexiones. ¿Por qué? Porque yo, por ejemplo, he atado cada proceso a un CPU para poder hacer un mejor uso de este hardware. Entonces fíjate que es interesante, ¿no? Puede ser el mismo puerto contra múltiples procesos, o un solo proceso abriendo muchos puertos. El caso más típico, más simple a entender es 1 a 1, pero no necesariamente es así. Perfecto. Gracias. No, de nada. ¿Estamos? ¿Alguna otra duda de lo que acabamos de hablar? ¿Y eso en qué capas estaría, se manejaría? ¿O ya sería algo del sistema operativo, otra parte del sistema operativo? Estamos hablando de la interfaz de transporte de aplicación acá. ¿Sí? El socket, que es esto, el puerto, es en realidad como la capa de transporte, son las reglas que le pone la aplicación. La aplicación tiene que entender puertos para identificarse. Entonces, justo como siempre esta implementación de capas, siempre hay interfaces, ¿no? Porque son como niveles de capas y interfaces justamente la rayita. Estamos hablando literalmente de esto, ¿no? Acá, no sé si se ve el color, justo en el transporte de aplicación. Los sockets están ahí. Entonces, es esa, el contrato, si se quiere, en donde hablamos puertos cuando hablamos de estos huecos que yo hago, sockets, para poder usar este protocolo de transporte, puertos. No sé si eso responde a tu pregunta. Sí, yo como que tengo, se me está empezando a mezclar. Me acuerdo que en un momento me puse a leer, a estudiarlo y ahora como que... Porque, por ejemplo, yo mi navegador, yo lo abro y puedo tener el Google Chrome y el Edge, los dos abiertos y los dos pueden estar utilizando protocolo HTTP y encima los dos pueden tener distintas ventanas abiertas. Y estarían todos usando el mismo puerto. Origen, destino, ¿de qué puerto me estás hablando? Sí, todos están utilizando-- Bueno, ahí no hemos llegado a ese punto, pero imaginate, imaginemos por un momento Bostonets, Brave, Chrome, Firefox, abiertos todos contra Google. Imaginemos que Google te haga una sola IP de endpoint, es decir que es como que Google estuviera en un solo lugar, lo que vos haces cuando haces un ping Google Chrome, eso. Y están todas estas ventanas y tabs de los navegadores contra el mismo destino. Y ahí tendríamos en principio un problema porque se habla de una 5UPLA, que es lo que identifica unívocamente una conexión. Una parte de la UPLA, esa de la 5UPLA, es el protocolo, TCP, listo. Me quedan cuatro grados de libertad. IP destino, recién acabo de decir que me dio una sola. Puerto destino es 443, que es HTTPS. IP origen, yo tengo una sola IP. Entonces, ¿qué me queda como variable para poder diferenciar esta conexión de este tab de navegador, de esta otra, de esta otra, de esta otra, de esta otra? Si tengo toda esta fija. Una sesión. No, no hablemos del mismo término que estamos hablando. No hablemos de sesión, estamos hablando de transporte. Contra la aplicación. Dijimos, IP origen e IP destino. Dijimos, puerto destino que está fijo porque es 443. ¿Y qué me queda libre entonces? El puerto de... Los mis puertos, digamos. Puerto origen, exactamente, claro. Entonces, ese es el juego. Y tu sistema operativo en realidad va a poder diferenciar una conexión distinta de la otra porque tiene la libertad de elegir el puerto de origen cualquiera. No tiene por qué elegir el 80443. De hecho, no elige eso, sino que elige randómicamente dentro de un rango que típicamente está arriba de 1024. Ah, en realidad, por RFC está arriba de 1024. Y va a picotear dentro de los puertos libres que yo tengo, que son, vamos a ver, que son 65K puertos que tengo yo de mi lado. Y cuando voy contra el mismo voy a ir mordiendo distintos puertos justamente para permitir hacer que esta conexión sea distinta a la otra y no sé, entre comillas, confundan la conexión que viene al crome del Firefox. Sencillamente porque justamente como sus puertos de origen son distintos, permite diferenciar una de otra, por más que vayan al mismo destino. No sé si se explica... Sí, perfecto, perfecto. Se me había pisado. Buenísimo, buenísimo, sí. Y también siempre presente la cincupla y dónde vos tenés ese grado de libertad y generalmente lo vas a encontrar en esa posibilidad de definir, de usar un puerto distinto del lado cliente. Bien, buenísimo. ¿Alguna otra duda, muchachos? Bueno, estamos. Gracias por los 29 minutos extras. Pero... [AUDIO_EN_BLANCO]Porque lo voy a necesitar seleccionar el drive... ah tengo a ver... ah si, increíblemente bien, se está viendo ahí, ¿no? recuerden que era el borroneo que habíamos hecho que habíamos hecho sobre la sobre la cabecera IP, acá les copio el link acá en Slack, es el link del whiteboard que estamos trabajando y muy convenientemente, excusando las 9 de la noche en la clase pasada yo le esquivé a fragmentación porque vamos a ver que fragmentación tiene casi todo un apartado en sí mismo recordemos, retomemos un poco, vimos todas las cabeceras estuvimos explorando un poco los tamaños yo le hice algunas preguntas respecto de bitianas respecto del ancho del campo en bits calcular máximos de tamaños, etc. vimos con un poco más de detalle el time to live que en realidad luego entendimos que no es un time sino es un hop count, es cantidad de saltos digamos, que nosotros le habíamos dicho coloquialmente cantidad de nafta que le ponga un datagrama y que solamente puede pasar tales cantidades de saltos le hago un par de preguntitas al respecto ¿cuál es el máximo TTL que yo puedo leer en un cable? es decir, imagínense el siguiente escenario imagínense que en cualquier lugar del internet yo me pongo a espiar lo que pasa en un cable no soy ninguno de los routers sino que me pongo ahí le hago un clamp a los cables y me pongo a ver los paquetes que pasan asumiendo que no hay ningún paquete extraño sino que son todos paquetes que han sido legítimamente creados por decir, ¿cuál es el máximo TTL que yo puedo observar ahí? máximo, perdón, quise decir mínimo el mínimo como uno, le queda un hop digamos ajá, bien, ¿puede ser cero? no, porque cuando es cero dijimos que lo dropeaba correcto, correcto, esa es la respuesta correcta ¿y qué significaría el uno? ¿cuál es la única chance que tiene de vida ese datagrama que yo he observado en el cable que dice, ups, tiene TTL igual a uno? ni que el próximo router sea el destino bueno, claro, exacto, tal cual la única chance de vida sería que sea el destino final el próximo bien puede ser un host, ¿no? puede ser, acá hay routers y hay un host final pero básicamente el destino que tenga acá es la única chance, de hecho no va a vivir más que cuando sea tomado por la MAC que corresponde a esa trama lo levante el protocolo, sea la IPSA y básicamente o es la IP final con lo cual puede ser alguien accediendo a este router para administrarlo, este nodo, este host directamente porque es el destino final y justo si es el que está cagando la nafta y si no, es descartarlo con todo este proceso que habíamos visto de este mecanismo para poder generar, le salió un trace route que me mostraba todos los hops intermedios a medida que se le iba cagando la nafta y obteniendo los ICMP de error al no poder seguir su camino perfecto, correcto, esa es muy buena respuesta bien, entonces vamos a ver el tema de fragmentación ahora primera observación algunas notas antes de meternos en lo que es lo técnico si quieren los detalles de la fragmentación una nota general nos interesa ver cómo está escrito la cabecera de un paquete no para que le memoricemos, de hecho en nuestra cátedra ustedes pueden venir todo al libro abierto, pueden venir con si quieren un imprinto de las cabeceras de los protocolos que vemos no hay problema porque lo que nos interesa a nosotros es ver cuál ha sido el problema de ingeniería para expresar el comportamiento a través de protocolos de campo de un protocolo, que ese campo está bien, quizás pocos de nosotros escribamos un protocolo pero vamos a tener que escribir quizás una estructura de datos entonces ver cómo expresamos comportamientos a través de los campos en este caso, campos de la cabecera de un protocolo y eso a nosotros, con Diego, es lo que nos parece sumamente rico porque aprendemos cómo se tiene que comportar y de paso aprendemos protocolos es como que el fin realmente no es aprender per se la cabecera estrictamente que está en la posición tanto, en el reglón tanto sino entender por qué está escrita así qué efectos tiene el comportamiento de protocolo, que es lo que a nosotros nos interesa saber que todo lo que hemos aprendido hasta ahora de IP de que es stateless, de que es best-of-fourth de cómo expresa, de que la red, el feedback lo provee a través de CNP y todo este tipo de cosas que vamos aprendiendo en el camino eso es importante aclararlo entonces, ese es un punto en general en particular ahora con lo que vamos a ver hoy que es el reglón 2 el que aparece ahí como identification flags en fragment offset es cómo hace IP para soportar una propiedad que tiene el protocolo que es capacidad de fragmentar capacidad de fragmentar es tal que la capa de transporte de arriba, TCP o UDP puedan escribir puedan escribir datagramas que no necesariamente entren en el alguien me completa la frase en el de la capa de enlace paquete eso pero tiene una palabra con tres letritas muy específicas nuevamente, es decir cuál es el problema, veamos cuál es el problema de ese plan TiP recuerde que básicamente toda la idea de de las capas de protocolo es que dan servicio al de arriba resuelven un problema al de arriba para un problema que tienen con la capa de abajo es decir, prestan un servicio de adaptación entre capas, la capa de transporte hacia abajo le dice IP, por ejemplo imaginemos UDP que es el más simple imaginemos que UDP escribe un datagrama de 3500 bytes puede escribir un datagrama IP de 3500 bytes UDP o redondemos, pongámosle 4000 bytes ¿tiene permitido UDP escribir un datagrama de 4000 bytes a IP? ¿qué le parece? ¿por qué no? porque el máximo era de 1500 eso es capa de enlace ¿cuál es el máximo tamaño? y está escrito en rojo en la pantalla ¿cuál es el máximo tamaño de un datagrama IP? 64k ok mientras vos juegues con eso a mí tengo el protocolo de transporte dice papi la RFC dice 64k acá va un datagramón de 64k, 60k y IP tiene que arreglárselas justamente es parte del servicio que provee y por eso el campo de fragmentación como lo vamos a ver ahora vos vemos un ejemplo más simple porque nos va a servir para dibujar un poquitito las cabeceras imaginemos que capa de arriba, capa de transporte UDP escriba un datagrama de 5k por lo que acabamos de ver es posible perfectamente posible cabecerita de 20 y van los 5k atrás si quieren 49, 80 pero digamos, imaginemos un payload de 5k y se lo escribe IP y todo perfecto, lo puede escribir bien como vemos ahí el tamaño máximo de 64k así que se puede escribir todo y cuál es el problema que tiene IP? IP tiene el problema de hacer entrar ese datagrama en la capa de enlace entonces necesito que me completen esa palabra en el cómo se llaman esos 1500? que pueden ser otro número en otras capas PDU cerca, si, PDU pero bien PDU se llama en algunos textos nosotros le llamamos MTU Maximum Transfer Unit entonces el problema que tiene IP es cómo hacer entrar esos 5k que le escribió el desgraciado la capa de transporte en el MTU que tiene abajo que solamente soporta 1500k y veamos cómo sería eso yo ahora voy a abrir otra página bien, perfecto vamos a ver si me salen los dibujitos no, esto es texto yo lo que necesito es un cuadradito no, no está decidido, no bastante chotin esto acá este pero no quiero un círculo, quiero barra, no cuál, si, bueno, barra se llamale barra ok entonces este ha sido un para ser correcto sería un mensaje UIP de 5k de payload quiere decir que obviamente esto mide 5k, lo voy a poner ahora acá tengo flechitas, algún tipo de cosa acá que me conviene acá alguien recuerda cuáles son las líneas acá acá era esto yo creo que podía la línea era con chip, sí, ahí está pero no sé si puedo dibujarle las puntitas bueno, se lo voy a dibujar a mano quiere decir que esto de punta a punta mide 5k creo que lo ha hecho bien, sabemos que tenemos abajo entonces acá está IP que va a tener que no le queda otra que partir este mensaje UDP de 5k de payload lo tiene que convertir en una cierta cantidad de datagramas tamaño máximo 1,5k que es lo que entra abajo en la capa de enlace entonces, ¿qué les parece? ayúdenme a dibujar entonces con el control V ¿qué medidas tenemos acá? ¿qué medidas tenemos acá? y el enlace en 1,500 ok, quiere decir que yo voy a tener que el todo esto va a tener el 500 bytes hacer el circulete 500 bytes, bien ¿cuánto del payload viene acá? es decir, de todo este payload que es todo esto yo lo voy a poner así lo voy a ensuciar un poquito para mostrar que es el payload que es la data de usuario si se quiere ¿dónde vendría acá si yo tuviera que dibujarlo? ¿le dibujo todo? ¿le dibujo así todo? no, porque o sea, si lo voy a fragmentar cada fragmento tiene la cabecera pero tiene 1,500 ok, bien pero me gustó lo último que dijeron por ahí dijiste cabecera de estos 1,500 bytes que en realidad es el tamaño máximo recordemos que esto es en capa de transporte es decir, esto que está acá a ver si lo puedo editar esto es lo que quieras le vamos a poner el texto encima le vamos a poner transporte recordemos que acá ya estamos viendo el problema desde el punto de vista de capa de red por lo tanto yo tengo que aquí sí o sí no me queda otra que hacer un departamento de transporte ¿qué es esto? es decir, es un departamento de transporte que es el que va a estar aquí sí o sí no me queda otra que hacer un datagrama de 1,500 bytes ¿por qué? es la limitación que tengo de la capa de enlace de abajo capa de enlace de internet estamos suponiendo ok, bien entonces, ¿cómo se dibujaría esto? si yo tengo que dibujar el payload acá ¿cómo vendría esto? si tuvieran que dibujarlo ustedes tendríamos un pedacito y acá tenemos payload que ocuparía esto de acá ¿sí? esto tendría que ser el payload de la data del usuario y acá en esta cabecerita en realidad yo lo estoy simplificando porque acá viene también la cabecera de la capa de transporte pero vamos a suponer vamos a hacer una cosa para hacerlo correcto y así nos queda bien correcto vamos a hacerlo que acá viene la cabecera de la capa de transporte ¿sí? a ver si lo puedo pintar un poquito lo vamos a pintar de esta vendría a ser la cabecera de la capa de transporte donde están por ejemplo puerto, origen y destino y en realidad el payload tiene un poquitito menos de 5k bien cuéntenme entonces esto que está acá en rojo le vamos a poner la cabecera de la capa de red quiere decir que estos 5k ¿cuántos he metido acá? ¿cuánto sería lo que queda acá? es casi matemática simple ¿cuánto me queda acá? más o menos un tercio sí, pero el número exacto que tengo acá de bytes ¿qué meto acá? creo que era como 1450 puede ser recordemos asumamos una cabecera de red estándar 5k tenemos acá en total acá ¿cuánto quedarían? matemática súper simple 480 ¿sí? ¿dónde está la cabecera de transporte? ¿dónde quedó acá? obviamente ha quedado acá lo voy a dibujar acá esto sería en situaciones normales ¿cómo se conforma un datagrama normal? donde tiene la cabecera de red le vamos a poner acá el colorcito en rojo y la cabecera de transporte y después viene todo el payload ¿cómo vendrá el nuevo? está claro que acá esto no entró por lo tanto esto se corta lo interesante de este corte si ustedes ven es que el corte este en realidad si se quiere viene así ¿no? está como desfasado porque tengo que contemplar esos 20 bytes extra que me está ocupando la cabecera IP no me queda otra que fragmentarlo bien ¿cómo será el segundo fragmento? este viene a ser el fragmento número uno ¿cómo será el segundo fragmento? ¿qué les parece? tendría una nueva cabecera de red pero prácticamente la misma de transporte y un poco más de payload prácticamente la misma de transporte ¿sí? misma de transporte IP no sabe nada de transporte IP sabe de red nada más ¿no? claro quiere decir que acá en realidad lo que va a tener es la cabecera de red acá en rojito y después va a venir directamente un pedazo del payload si este payload decía hola mundo ¿cómo te va? acá estamos con esta pandemia en el 2021 acá viene hola mundo ¿cómo te va? sumiendo que es más largo y se corta y acá en vez de venir una cabecera de transporte viene acá estamos con esta pandemia en el 2021 ¿sí? fíjense esto esto es súper interesante no se han trasladado las cabeceras de transporte esta es una horripilancia este datagrama porque en su viaje por la red lo único que lo sostiene es la cabecera de red vos lo observás a este datagrama en viaje y no sabes si es UDP si es TCP miento en realidad acá adentro dice hay un CAMPOC si ustedes recuerdan que decía protocolo acá protocolo entonces puedo saber si es UDP o TCP pero no sé a qué puertos va de qué puertos viene porque no tengo ninguna otra data que lo que la sostiene la cabecera de la red en realidad se entiende eso no? si cabecera si vamos puede ser que cuando era TCP en la cabecera de red iba cuántos paquetes eran el orden y cuántos paquetes se había subdividido veremos TCP yo no saber TCP a esta altura lo veremos en su momento en TCP lo que pasa es que es importante porque están a niveles totalmente distintos la fragmentación por eso ahora si no hay fragmentación debería quedar un poco más clara tu pregunta en todo caso si no queda clara después la revisamos no quiero introducir TCP aún siendo que no lo hemos hablado para no meter ruido por eso acá estamos en barebones estamos súper en lo básico de IP ¿cómo llevamos la cuenta ahí muchachos? teníamos 5k 5 mil ¿cuántos nos quedan por armar acá? hay que me ayude con la cuenta podemos usar la calculadora ¿cuántos más tengo que armar? voy a tener 3 y un pedacito o sea 3 y uno sí, más o menos 4 bien, ok ok lo que queremos notar en este momento es que en realidad fíjense que por cada datagrama estoy pagando entre comillas sobre G de esos -20 bytes no me queda otra porque si no voy a tener que enviar el payload solito justamente para que el payload llegue a destino tiene que tener la cabecerita si hacemos la cuenta tenemos 1480 por 3 y si le hacemos 5k -1480 por 3 el último es de 560 ahora podría haber elegido más chiquito o no pero bueno yo estoy en esta dámoslo esto puedo coger acá sí estos son todos de 1480 y después me queda un último ahí dice 560 pero en realidad tiene son 560 payloads en todos estos se ha dado lo mismo acá así que tiene 580 yo lo voy a poner acá directamente adentro esto tiene 560 bytes sí ahora la verdad que es muy arcano esta pizarra de google o sea no te la han sacado corriendo sin demasiados razones pero bueno esto es lo que tenemos                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  en el código de Y ahí nos vemos enseguida.Bien, la situación del problema que estamos hablando es la siguiente. Habíamos resuelto que había una red 1, esa red 1 tenía un router central, router de sucursales con ese direccionamiento de enlaces y le debía hacer otra red de cada sucursal con un host. Este es el problema original, lo que habíamos hablado era de implementar dos sucursales y un router central. ¿Estamos de acuerdo? Sí, pero... A ver, puse compartir, nunca compartí, perdón, estaba dibujando en el aire, perdón. El problema, de nuevo digo, teníamos un router central y teníamos que implementar dos sucursales, cada una con su router, una red de la sucursal y un host en cada sucursal. Este es el problema que teníamos que resolver. Lo que yo les mostré el otro día que podíamos hacer era usar esta herramienta, que era el editor de Mininet, para en parte tratar de tener el dibujo de las máquinas. Yo voy a tratar de hacerlo a mano para que destrabemos el problema de implementación del problema de desarrollo. Digamos que este va a ser el router central. Vamos a poner RC. Este router central va a tener un router en cada sucursal. Después de cada sucursal va a haber un switch y va a haber un host en cada sucursal. Esto es más o menos así. Entonces vamos a decir que este es el router central, este le vamos a decir que es el router sucursal 1, este es el router de la sucursal 2, este va a ser el host de la sucursal 1 y este va a ser el host de la sucursal 2. Esto está conectado acá, esto está conectado acá. Estoy haciéndolo a mano para que la gente que no tocó nada se dé cuenta que la verdad que aunque sea a mano lo podrían haber resuelto. Este es el dibujo de la red que necesitamos implementar. De acá yo lo puedo grabar. Vamos a ponerle caso 2, grabar. No le puse ningún IP. Le voy a decir que me haga el script para poder correrlo. Así lo veo. Caso 2. Listo. Bien, si yo hago sudo python caso 2, acá dice que tengo el router central, router sucursal 1, router sucursal 2, host 1 y host 2. Voy a hacer una terminal en el router central. Este es el router central. Voy a poner así. Voy a hacer una terminal en el router sucursal 1. Voy a hacer otra terminal en el router sucursal 2. Esta es la partecita de arriba de la red. Bueno, si vamos al esquemático, estamos haciendo este pedazo acá, ¿no? Está claro que estamos dibujando este pedazo acá. Este router central, ¿qué direcciones IP tiene? En estos enlaces que los llevan a las sucursales. 168, 166, 6/29 y la 14, sí? Es decir que... Creo que la 6 es la eterna del cielo. Bien, vamos a probar. Gracias. Bueno, entonces yo lo primero que quiero que... no sé si se alcanza... lo voy a poner un poquito más grande. Al menos yo hubiera esperado que alguno de ustedes me hubiera hecho esto a mano. Aunque lo hiciera, lo hubiera hecho a mano para probarlo y después viera cómo programarlo, que es lo que vamos a hacer después, pero me interesa en este estadio, al menos, que lo hubieran programado. Este router, está claro que tiene dos enlaces, sí? Vino con un IP, tiene un enlace que es la rcth0 y rcth1. IP address, tiene un address. Ahora asignado, que no me interesa, le voy a decir ip address del 1001/8 rcth0. Ahora no tengo address. Entonces, lo primero que voy a hacer es crearle el address. Voy a decir ip address... perdón, lo primero que hago es mirar quién enlaces tiene, ip link, me dice que tiene la eth0 y la eth1. Todavía la verdad que no sé bien cuál es cuál. ¿Qué puedo probar? Podría haber dicho, bueno, mirá, hago ip address add 192.168.100, era 6, ¿no? /29 /dev/rcth0 brd +. Eso me asigna esa dirección y la otra que tengo que hacer... perdón, me asigna esa dirección, ¿no? Si yo hago ip address, me dice que tengo acá la 106. Supuestamente, este que es el router de la sucursal 1, también debe tener dos enlaces. ip address... perdón. ip address, no tengo... bueno, este también tiene ip address del 002/8. Podría no sacarla, no hace falta que la saque, la estoy sacando solo para que les quede limpio. Voy a poner esto en una letra un poco más grande. Ahí se ve bien. /dev/rcth0 /brd +. Oh, gracias, profe. /brd +. Perdón. ip address, no tengo address. Entonces voy a decir, si yo quiero hacer la contrapartida de esta, ¿qué le pongo? Hay que asignarle la 192.168.101. /dev/rc1.th0 /brd +. Como pro, si está bien, le tiro a la 106. Listo. Es decir que ahí hice... ¿qué pedacito hice? Hice este enlace. Jomón. Entonces acá puedo agarrar y decir, ip address... lo voy a agrandar también. Pero... ahí está. ip address, add. Perdón. ip address, add. /rc... perdón. ip address, add. 192.168.100. ¿Cuánto era la otra? 14. /dev/rcth1.brd +. Es decir que ahí tengo ahora las dos direcciones. La 106 y la 114. Si miro la tabla de ruteo, me dice que yo tengo ruta, la 100/29, la 108, scope link, significa que estoy conectado. Esto es lo que hemos visto en los papeles cuando hablábamos de las tablas. Vamos a este router. Este es el router de la sucursal 2. ip address, que me dice que tengo, le voy a decir ip address del 1003/8dr. ¿Por qué le estoy borrando esto? Se ve que cada equipo tiene el nombre que tiene el equipo y la interfaz, porque es la manera que Mininet lo hace. Si no hubiera sido, si fuera una máquina entera, acá estaría el THC. La verdad que la interfaz es lo de menos. Lo importante que ustedes tienen que saber acá es a dónde está conectada. Entonces, ahora, ¿qué IP le toca a este? ¿Qué IP le tengo que asignar al router? 192.168.109 Bien, entonces hago ip address add rc2 eth0 192.168.109/29 Perdón, estoy así. d rc2 eth0 vrd + ¿Cómo pruebo si anda? Un pringala 14. Ah, esta no estaba acá. Entonces, este address del... Estaba en la otra interfaz probablemente. Ahí está. ¿Se ve por qué dice? Lo di vuelta porque eso... Igual, eso chicos, lo pueden ver si ustedes miran... Cerré la term donde estaba el Mininet. No, pará. Sí. Creo que sí. No la veo. ¿La cerré? Sí, creo que no se puede tener el entorno gráfico con... No, no, pero la que tenía, la que tenía. Está acá atrás. A nosotros nos pasó que cuando minimizamos las cosas, como que se pierden. Entonces tuvimos que configurar un poco el... El escritor. No, no, está faltando... Pantallas. No, nos está faltando acá... Ahí está. Ahí, profe, en el cosito de arriba si pone agregar. Claro. Panel. Panel, add new items y... Nos falta el de las ventanas. Sí, Windows. Windows, creo que decía. Windows buttons, eso. Igual había que agregar otros más, ¿o no? Este. No, no, ahí está. Ah, no le falta. Este no. Esto. Acá, notes. Net. Net, perdón. Fíjense, acá, cuando usted pone el comando net, le dice, el router central tiene la interfaz rceth0 y la rceth1. La rceth0 está al switch1 eth1. ¿Se ve? Sí, profe. Y fíjense, el switch1 eth1, dice que tiene el rceth0 y tiene el rceth1 eth0. Vieron que cuando conectamos el router de la sucursal 1, la interfaz era la eth0. Este. Este anduvo bien, porque era rceth1 eth0. ¿Está bien? Lo que les quiero decir es que acá está mapeado. Por ejemplo, acá se va a ver. Los links. Claro, los links entre los switches. Porque rsucursal2 está a la eth1 conectada con la rceth1 a la eth1, que estaba dado vuelta. Por eso nos pareció que estaba dado vuelta recién acá. Acá en el router de la sucursal 2, la interfaz que lo lleva es la eth1. Lo pueden mirar el mapeo en esta tablita. Bueno, acá tengo entonces. Ahora tengo ruta a... Acá, y cada uno es miembro. ¿Qué debería, qué me está faltando agregar acá? Que no he levantado todavía. La red del propio router de la sucursal. Me falta aprender. Vamos a poner el XTERM, el host1, el host2. ¿Se ve? El host2 lo voy a poner acá, si les parece. Y el host1, para seguir un poco la... Sí, el diseño. Sí, se nota ahí la jerarquía. Para que ustedes vean la jerarquía. Bien. Entonces, si este tiene una interfaz, ¿qué IP tiene la otra interfaz? Ahora no tiene ninguna. Hay que asignarle la 10. ¿Cuál le falta? Bien. ¿Cuál es? 10.0.1 Ok. Bien. Entonces tengo que hacer IP address add al rs1 eth1. Perdón. 10.0.1.1/24 al device. Router sucursal 1 eth1 brd +. Es decir que esto ahora tiene una interfaz en la red 100 y otra en la red 10. Y este muchacho... Voy a hacer IP address del 10.0.0.5. dbh1 eth0. Vamos a darle IP address add 10.0.1.254/24 dbh1 eth0 brd +. Bien. Es decir que de acá llevo a mi router ahora. ¿Cómo pruebo si este llega al host 10.0.1? 1.254. Bien. ¿Se ve? Es decir que acá tengo... Este está andando, este está andando. Este que tendrá IP address del 10.0.0.4 dbh2 eth0. IP address add 10.0.2.254/24 dbh2 eth0 brd +. ¿Cómo pruebo? ¿Qué me falta? No está puesto en el router. Bien. IP address add 10.0.2.1.24 dbh2 eth0 brd +. Así que este muchacho tiene una I, una K, PIN, ¿a quién? 10.0.2.1.1. Bien. ¿Qué he terminado de hacer hasta acá? Asignar las IPs. Bien. Todos tienen IPs a sus redes. ¿Está claro? De hecho, si hago IPR0 acá. Recuerden, IPR0 me muestra la tabla de routeo. ¿Qué me está mostrando esto? Que cada tabla de routeo, la pregunta es, ¿el host 2, si tuviera que llegar a cualquier red, quién lo puede llevar a cualquier red? El router 2. Está claro eso. Que la única decisión que puede tomar es darle sus paquetes. Entonces nosotros tenemos que agregar una ruta. ¿Cómo se agrega esa ruta? Con el comando IP también. IP route add, y entonces me pregunto, ¿qué me tenía que preguntar? ¿Dónde estoy? ¿Dónde estoy? Estoy en el host 2. Segunda pregunta. ¿A dónde quiero ir? Al router central, podríamos ir. Ok. ¿Cómo describo a dónde quiero ir? Si yo le quisiera decir, bueno, la verdad que este, a cualquier lado que quiera ir, ¿qué tendría que hacer? Lo mismo. Sí, claro. ¿Cuál es la ruta a cualquier lado? 0, 0, 0. Bien, destino 0, 0, 0. Barra. 0. Vía, ¿quién me puede llevar? 10. 0, 2, 1. 1. ¿Ok? ¿Qué hizo eso? Creó la ruta por default que se llama, porque el destino es todo el mundo. Entonces, dice acá, hiperro, dice default vía este que está acá arriba. Este muchacho está en la misma situación. Hiperro, add. 0, 0, 0, 0. Barra 0. Vía, lo mismo. 10, 0, 2, 1. No, la 1. 10, 0, 1. 1, 1, 1. Ah, ¿por qué cambia? Porque el lado es su router. Bien, porque uno me pregunté, ¿dónde estoy parado? ¿Dónde estoy parado? No, estoy en otro lado. Entonces, cambia toda la-- ¿Cambia el destino al que quiero ir? No cambia. ¿Qué cambia? Uniforme de salida. ¿Quién me puede llevar? ¿Y quién me puede llevar? 10, 0, 1. 1. Bien. Bien. Vamos a la situación de estos dos muchachos. ¿Qué le puede pasar a alguno de ellos? ¿Qué destino le puede necesitar alcanzar? ¿Y quién lo puede llevar? Puede querer ir al-- Al router central y-- Al router central es miembro de esa red porque lo tiene de un lado. Puede querer ir, por ejemplo, del router 1, le quiere mandar algo al router 2, por ejemplo. Pasar a la otra red. Es decir, que algo que viene de la 10, 0, 1, barra 24, quiere ir a la 10, 0, 2. Entonces, tomémoslo en la 1. ¿A dónde quiero ir? Está claro que me faltan rutas, ¿no? Tengo que poner rutas. Sí. [INGLÉS] 10, 0, 2, 0, barra 24. Ahora, si yo les pregunto a ustedes, estamos en este router, ¿no? ¿OK? Imagínense que este problema tiene todas las sucursales ya dadas. ¿Qué destinos, si esto tuviera 6 sucursales, como dice el problema? ¿Qué destinos son las sucursales? ¿Hay una manera de describir a todas las sucursales de una sola manera? Porque si no, yo voy a tener que hacer una ruta para la sucursal 2, otra ruta para la 3, otra para la 4. ¿Y por dónde siempre voy a ir? ¿Quién me va a llevar siempre? [VOCES INTERPUESTAS] ¿Y para mí quién es? ¿Vía a quién? 190, 168, 106. Es decir, que voy a tener muchas rutas. ¿Qué va a ir cambiando? Va a ir cambiando. 2, 3, 4, 5, 6, 7. 6 sucursales sería hasta la sucursal 6. ¿Hay alguna manera que yo pudiera englobar? Sí. Si le ponemos la 10, 0, 0, 0. Y ahí va a cambiar el barra. ¿Cuántos bits necesito morder? Creo que dice 6. No. Bueno. Sería el más-- ¿Cuántos menos que 24? 8, dijo alguien. 8. ¿Sí? No, no son 8 menos. Son la cantidad de bits que necesito para representar 8. ¿Cuánto le muerdo a la máscara? 3. Es decir, que es un barra-- 21. Así. Está claro que si le pongo barra 16 entrarían, pero entrarían muchas más redes. ¿OK? Fíjense. Entonces, acá tengo ruta. Tengo ruta. Una forma que yo puedo probar la tabla de ruteo que es muy útil es, por ejemplo, mirá, quiero saber hiperroguet 10, 0, 2, 100. Le puedo interrogar a la tabla de ruteo con un destino para que me diga por dónde agarraría. Fíjense, dice, mirá, hiperroguet, decime por dónde irías al 300. Y me va a decir, y 3, vía. Es como si yo le hubiera hecho machear la tabla de ruteo. Está bueno. ¿Se ve? Sí. Excelente. OK. Entonces, tengo ruta. Ya tengo ruta para allá. ¿OK? ¿Qué otro destino le puede-- ¿Qué me puede pasar que no voy a poder alcanzar si no le aviso a esto, viendo este dibujo? La red barra 8. O sea, perdón, la red 198, 108. 108 es la otra red, la que tengo acá al lado. Es decir, otro destino de la red 1 que no sea ninguno de estos 2, yo no voy a llegar porque no tengo ruta. ¿Está claro? Si yo digo, hiperroguet, 192, 168, 116. No hay valor dicho. Entonces, le podría decir, ¿cómo le digo que toda la one-- ¿Qué le tengo que decir yo? Che, mirá, toda la one, todos los demás one, ¿dónde están? Y atrás del router central. Hiperroguet, 192, 100, 0, 24, vía. Ahí está. ¿Sí? Hiperroguet, 192, 108, 100, 23. Pum, se va para allá. ¿Se ve? Sí. Bien. ¿Qué es lo otro que-- Vamos a entonces hacer lo mismo a este que es un par de la misma altura que él. ¿Qué hay que decirle acá? Hiperroguet, 10, 0, 0, 0, barra 21, vía. ¿Quién? 14. Muy bien, 14. Y hiperroguet, 192, 108, 100. Perdón, 0, 0, 24. Perdón. 100 también por allá. Entonces, veamos. Hiperro. Hiperro. Hiperro. ¿Está listo? No. Le falta-- Faltaría el-- Power de paquete. Claro. Bien. Faltan algunas cosas, pero ¿qué falta acá, por ejemplo? ¿Qué no sabe este? Hiperroguet, 10, 0, 2, 1. Sí. Claro, el nodo central no sabe de qué lado tiene, por ejemplo, las 10. Le pongo-- Puede salir por cualquier lado, por una misma ruta, todo el router central. No, el router central sí tiene que tener bien especificado qué red tiene-- Claro, por el lugar que le toca, tiene que saber por dónde va. Entonces, ¿a dónde quiere ir? Hiperro. A la 10, 1. 10, 0, 1, 0, 24. ¿Quién lo puede llevar? El router 1. 1, 10, 1. Y a la red 2 también va por el 1. No, va por el 2. No, no. O sea, va por el router 2. Pero, ¿cómo--? Seguiría el 9. El 9. La 9. OK. Es decir, que este muchacho tiene rutas, fíjense, tiene rutas. Y ahí, ¿lo voy a poder generalizar o voy a tener que poner una por una? Una por una. Porque son caminos distintos. Quien lo pueden llevar siempre van a ser distintos. Es decir, que acá va a haber tantas entradas adicionales como sucursales tenga. Bien. Preguntemos, entonces, hiperro, get. 10, 0, 2, 23. El 14. Bien. 1, 22, el 6. Listo. Entonces, hago ping. 10, 0, 1, 2, 54. ¿Qué me está faltando? Estas máquinas, porque como están hechas, requieren en Linux, ninguna máquina, si yo no le aviso, arranca por seguridad como router. Eso se ve porque hay un-- En Linux, la configuración en tiempo de ejecución de parámetros del sistema se hacen a través de esto que parece un file system. En realidad es como las estructuras de control del proceso del sistema operativo. Lo que hay acá bajo /proc es una ilusión óptica, en realidad. No son archivos que están ahí. Es como el mapeo de la estructura del sistema operativo. Este parámetro, /proc sysnet, bueno, /proc sys tiene un parámetro de configuración de todo el sistema operativo. Este parámetro en particular le está diciendo a este router, a este equipo, que él no tiene activado el forwardeo de paquete. Por lo tanto, por más que yo tenga las tablas de routeo, no voy a hacer nada porque no tiene la orden de ser un router. Para cambiar eso, hago así. Activo /proc sysnet/ipv4/ip/forward. Le activo el forwardeo de paquete. A todos, a las máquinas host también. No, a las host no, solo a los routers. Claro. ECO1/proc sysnet/ipv4/ip/forward. Entonces, si ahora pruebo, PIN 10.0.2.1. ¿Cómo está haciendo este paquete? Está cambiando en tres redes. 10.0.1.2.54. ¿Cómo puedo ver si los paquetes están pasando? Muy bien, muy simple. Pongo acá tcpdump en la rs1. Este h0. Fíjese que se ve pasar el paquete que va y el que vuelve. Bueno, acá están andando los dos, pero vamos a cortar este de acá. Yo estoy haciendo PIN. Vamos a hacer. Estoy en el host de acá, voy a hacer al host del otro lado. Si pusiera, ahí voy a poder ver las macadres. Fíjense, ahí va la macadres. Desde dónde hasta dónde va. Si ustedes la miran, en realidad acá está yendo la macadres de acá. Entonces. Perdón. Así se ven todas las tablitas de rute. Así, así, así y así. Y así. Este es el problema que tendríamos que resolver. A ver, al margen de, al margen que ahora sí lo van a tener que hacer y lo van a tener que entregar con fecha de entrega. Al margen de. Lo importante, primero que nada, es que entendamos cómo funciona el ruteo. Fíjense que lo que hicimos fue ir por cada uno de los lugares y haciéndonos las preguntas. ¿A dónde quiero ir? ¿Quién me puede llevar a dónde quiero ir? Y obviamente debería ser vecino. El comando que hace eso en Linux se llama IPRoute, que me muestra la tabla de ruteo y a su vez me permite manipularla. Previo a eso, lo que hicimos fue agregar las direcciones IP. A nivel código, y esto es lo que quiero mostrarles que, para que. A ver, en ingeniería, ustedes tienen que aprender siempre a, primero tratar de resolver el problema y después lidiar con la implementación de la solución. La verdad que no me gusta mucho el enfoque de ingeniería que han usado en no tratar de ni hacer la prueba de concepto. Si alguno me hubiera dicho "mire, yo traté de hacerlo aunque sea así y le puse la ruta", la mayoría, que no lo pudo completar, lidió con la implementación. Pero se puede resolver un problema y se puede tener problemas con la implementación. No es que no lo resuelva un problema porque no lo implementó directamente. Eso es un mal antecedente para la mente de ingeniería de ustedes. Y la verdad que para mí es poco tolerable que no se quemen un poco los ojos tratando de resolverlo. Por lo menos que alguno hubiera dicho "mire, lo hice así, lo tengo acá dentro de la instancia, lo prendí". Y esperaría que no vuelva a suceder. Por lo menos que tengan la actitud de resolver el problema. Vamos al problema de la implementación. Y para que ustedes vieran, a ver si había acá algo... Caso dos. Que se podría haber hecho por ingeniería inversa. Si lo voy a mostrar con un... No, no lo voy a mostrar. Lo voy a mostrar con un... No, no lo voy a mostrar. Lo voy a mostrar con un... No, no lo voy a mostrar. Lo voy a mostrar con un... No, no lo voy a mostrar. Lo voy a mostrar con un... No, no lo voy a mostrar. No, no lo voy a mostrar. No, no lo voy a mostrar. No, no lo voy a mostrar. No, no lo voy a mostrar. No, no lo voy a mostrar. No, no lo voy a mostrar. No, no lo voy a mostrar. No, no lo voy a mostrar. No, no lo voy a mostrar. No, no lo voy a mostrar. No, no lo voy a mostrar. No, no lo voy a mostrar. ¿Lo ven? Aquí está el router central. RC2, RC1, H2, H1. ¿Se ve? Sí, pero falta configuración. Por eso, ¿pero dónde habría que poner la configuración? Ahí mismo. Por eso, yo acá podría decir, che, una vez que prendo post configure, acá, podría decir, che, para RC.comand y acá podría ponerle ip adres ad-firi-fifi-fifi-fifi-fifi Eso es lo que hicimos nosotros, profe. Por eso, como mínimo, ustedes pueden correr todos estos comandos. La pregunta es, ¿esa es la solución que hubiera esperado? Mínima. ¿Esa solución, qué problema tiene? ¿Qué es el problema que yo les voy a dar ahora? ¿Y qué van a tener que entregar? ¿Qué problema tendría eso si mañana decimos, che, agregame dos sucursales más? Que les falte escalabilidad, digamos. Claro. De hecho, lo que les pedí que hicieran esta semana no es lo que... El caso dos que van a tener que entregar es, quiero un programa, como haría un ingeniero o estudiante de ingeniería, que soporte que yo le pueda dar la cantidad de sucursales que quiera. Si yo iba a hacer eso, no llegué por el tiempo. Bueno, ese es el caso dos que van a tener que entregar. Quiero un programa que escale, para lo cual van a tener que ver cómo lo hacen escalar. ¿Sí? Pero algo que se parezca a esto. ¿Sí? ¿Sí? Ok, yo le puedo decir, che, no, mira, quiero ocho sucursales. Fíjense. ¿Sí? ¿Sí? Este es el router de la sucursal ocho. Este es el host uno. Este es el host de la sucursal ocho. ¿Sí? Quiero un programa así. ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? ¿Sí? es que, perdón, en el internet ya lo vamos a ver qué generaliza para cerrarlo, pero no se pueden ahorrar este paso, tienen que hacerlo y lo que yo les pido es que intenten, por favor, intenten, cada uno aunque sea hacer esto como lo hice yo a mano, para entender y ponganse, vean esta clase, vean el video, ponganse uno por uno y mirá, usen el analizador de protocolo para ver cómo van y vienen los paquetes, porque la verdad que el trabajo de networking termina siendo más o menos el mismo y si no hacemos esto que es la ABC, las cosas que podemos hacer arriba son muchísimo más complejas y si no entendemos lo mínimo estamos en el aire. Quisiera cerrar el problema y les voy a habilitar cuál es el problema y les voy a poner la fecha de entrega, la fecha de entrega probablemente sea dentro de un par de semanas. Quisiera saber si hay alguna duda respecto a esto, si alguno tiene alguna inquietud de algo que no comprenda. No, que bastante gran duda. Bueno, bueno, perdón. Cerremos aquí. Déjenme ver si tenemos en el sitio. Sí, tenemos. Sí, tenemos. Sí, tenemos. Sí, tenemos. Sí, tenemos. Sí, tenemos. Sí, tenemos. Sí, tenemos. Sí, tenemos. Bueno, lo voy a dejar publicado en el sitio de la cátedra. El problema para que sea escalado, sí, y ya le voy a dejar publicada la fecha de entrega. Estaba tratando de ver si lo tenían puesto acá. Me parece que lo tengo oculto. Ya lo terminamos y lo dejamos publicado ahí. No sé si está Juanjo ahí. Juan? Sí, claro. Me quedaría que insertáramos el tema de routing en escala en internet y los prefijos, ¿no? Y ya lo tenemos. Bueno, bueno, bueno, bueno. Bueno, bueno, bueno. Bueno, bueno, Vamos.